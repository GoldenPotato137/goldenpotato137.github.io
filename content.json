{"meta":{"title":"GoldenPotato137的小屋","subtitle":"","description":"GoldenPotato137的个人博客，主要记录了自己的一些开发与学习记录、旧有的OI知识点。","author":"GoldenPotato137","url":"http://www.goldenpotato.cn","root":"/"},"pages":[{"title":"所有分类","date":"2025-02-26T07:23:45.724Z","updated":"2025-02-26T07:23:45.724Z","comments":true,"path":"categories/index.html","permalink":"http://www.goldenpotato.cn/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2025-02-26T07:23:45.724Z","updated":"2025-02-26T07:23:45.724Z","comments":true,"path":"friends/index.html","permalink":"http://www.goldenpotato.cn/friends/index.html","excerpt":"如你所见，这个界面很空，因为我是个没什么朋友的死肥宅（悲 欢迎朋友们与我互换友链~ 具体信息请参考本文末尾。","text":"如你所见，这个界面很空，因为我是个没什么朋友的死肥宅（悲 欢迎朋友们与我互换友链~ 具体信息请参考本文末尾。 一场史无前例的大浩劫已然降临 （其实就是搬迁博客的时候才发现wordpress导出的xml文件竟然不包含友链，服务器又早已因为过期惨遭削除了）（悲 成为朋友！ 欢迎新朋友将你的信息类通过邮件发送，我看到邮件后会立刻与你签订契约，成为马猴烧酒（bushi 12345678public interface Info&#123; public string Name(); // 你的昵称 public string Title(); // 网站标题 public string Url(); // 网站超链接 public string AvatarUrl(); // 头像 public string? Des(); // 你的描述 （可选）&#125; 以下为我的信息~ 12345678public GoldenPotatoInfo : Info&#123; public string Name() =&gt; &quot;GoldenPotato137&quot;; public string Title() =&gt; &quot;GoldenPotato137的小屋&quot;; public string Url() =&gt; &quot;https://potatox.moe&quot;; public string AvatarUrl() =&gt; &quot;https://s3.bmp.ovh/imgs/2024/01/01/218717ae3abfb558.png&quot;; public string Des() =&gt; &quot;HITer/LLer/前ACMer/废萌gal玩家&quot;;&#125;"},{"title":"","date":"2025-02-26T07:23:45.724Z","updated":"2025-02-26T07:23:45.724Z","comments":true,"path":"about/index.html","permalink":"http://www.goldenpotato.cn/about/index.html","excerpt":"","text":"About this blog 这里是GoldenPotato137的个人博客，主要用来记录一些个人记录，包括但不限于踩过的坑/做成与没做成的事/发电/一些想法。 如你所见，这里的文章上可追溯至2018年（因为我把之前反复搭建的博客网站内容搬过来/导入过来了。 这是这个博客的发展史（bushi 2018/04 - 2019/02 博客园，记录自己的OI刷题记录，直到WC2019。 2019/02 - 2019/05 WC2019上不务正业天天折腾服务器，成果就是：wordpress，启动！ 记录自己省选期间的刷题记录，直到省选暴毙 2019/05 - 2020/02 省选暴毙之后回归文化，狠狠开卷。期间只更新了AFO后记、CSP-S 2019暴力记 高考结束后开摆了，备份了一下网站之后就不管了 2021-02 - 2022-02 大一年度项目学搞深度学习被狠狠折磨了，想到应该记录一下又重新买了个服务器。wordpress，启动！结果还是太摆了，简单写一点之后就没动了，乐。 摆！ 2024-01 被毕设(在cuda上计算一种零知识证明)与自己的一个winui3项目狠狠折磨了，又想到应该记录一下。联想到之前wordpress备份起来非常麻烦，觉得自己还是应该搞一个静态的博客。hexo，启动！ 以下为这个网站的运行逻辑： 在本地的git仓库里面写文章，写好后push到github远程仓库 简单撸了github action，监听修改。当有修改的时候自动执行deploy动作：编译html到gh-pages分支，并发布到backup.potatox.moe(一个github page)。 github action继续执行job：ssh到服务器上并执行git pull来获取更新过后的编译结果，这个服务器上跑的就是现在你看到的界面。 为什么要搞这么麻烦呢？我们分步拆解一下： 为什么要发布到backup.potatox.moe：因为我很摆，万一到时候又开摆了我可以直接cname到github page上接着奏乐接着舞（。 为什么要搞一个服务器：因为github page在国内访问奇慢无比 About me GoldenPotato137， aka 土豆 HITer, 计算数学大四在读。 准备继续在哈尔滨多呆5年（希望真只有五年）做高性能计算方向学习与研究 拉拉人 μ’s forever！ Galgame玩家，喜欢纯爱废萌 （什么five (曾经)打OI 与 ACM （可惜疫情，一次线下都没去成（悲 很高兴认识你！"},{"title":"所有标签","date":"2025-02-26T07:23:45.730Z","updated":"2025-02-26T07:23:45.730Z","comments":true,"path":"tags/index.html","permalink":"http://www.goldenpotato.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"cute::Tensor 学习笔记","slug":"cute-Tensor-学习笔记","date":"2025-02-26T04:47:09.000Z","updated":"2025-02-26T04:47:09.000Z","comments":true,"path":"2025/02/26/cute-Tensor-学习笔记/","permalink":"http://www.goldenpotato.cn/2025/02/26/cute-Tensor-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本笔记为个人学习记录，仅供参考 推荐学习连接： https://zhuanlan.zhihu.com/p/661182311 https://zhuanlan.zhihu.com/p/662089556 https://zhuanlan.zhihu.com/p/663093816 Layout 用来表述一个复杂的高维数据结构 一个layout由两部分组成：shape 和 stride，前者表示数据结构的形状，后者描述这个数据结构拍扁成一维后应该如何寻址。 其中，shape和stride均为一系列二元组的嵌套，行在前，列在后。如shape:(3,2)表示一个3行2列的矩阵。 具体应该如何理解shape和stride请看下图（图片出自：https://zhuanlan.zhihu.com/p/661182311） 其中，矩阵里的数字表示这个位置的元素在矩阵被拍扁为1维数组后对应的下标（位置）；矩阵的描述中上半部分为shape、下半部分为stride Tensor Layout与其对应的数据的组合。","categories":[],"tags":[]},{"title":"基于LXD集群部署实验室GPU共享服务器","slug":"基于LXD集群部署实验室GPU共享服务器","date":"2025-02-24T07:32:41.000Z","updated":"2025-02-24T07:32:41.000Z","comments":true,"path":"2025/02/24/基于LXD集群部署实验室GPU共享服务器/","permalink":"http://www.goldenpotato.cn/2025/02/24/%E5%9F%BA%E4%BA%8ELXD%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E5%AE%9E%E9%AA%8C%E5%AE%A4GPU%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"注： 本文内容部分来自GPT生成，实锤有效 部署LXD的知识很多来自于yuanyu dalao，推荐各位有需要部署单机LXC/LXD的小伙伴参考他的文章~ 动机 &amp; LXD集群好处 很多实验室由于各种因素（没钱）的制约，很难给所有成员各自分配一台乃至多台服务器，导致共用服务器的需求产生。 很不幸的是，每个人对环境的需求是千差万别的，有的人可能需要新版本的GCC，有的人可能需要老版本的GCC，这种需求不同尚可解决，明确声明版本即可处理。但有些情况下不同需求是没法调和的，比如说对显卡驱动版本的需求。再者，有些人需要安装一些软件，这些软件可能会在各种地方与现有的东西产生矛盾，产生很多问题。 机器不够用，但又想实现“一人一台机器”，很容易让人想到虚拟机的解决方案。linux上常见的硬件级虚拟方案为KVM。但这种虚拟方法有严重的问题：资源无法共享，分配给一台虚拟机的资源（比如说某块显卡）没法被另一台机器占用，容易造成严重的资源浪费。 基于以上的一人一虚拟机，且虚拟机资源能共享的需求，我找到的解决方案为LXD（集群），它可以让每个人都有一个虚拟机的同时共享硬件资源。使得不同用户能不互相干扰，和谐共享服务器资源。 以下为LXD（集群）的好处： 一人一台虚拟机，各位成员的行为不互相干扰，同时能较大程度的确保宿主机稳定 （集群好处）：不同机器可以通过网络共享镜像、配置，从而不需要在每台服务器上都进行繁琐的配置过程，新机器可以快速加入集群上岗。同时可以透过网络在任意机器（节点）管理所有机器，大幅减少网管工作量。 以下我将介绍如何从零开始配置一个LXD集群。 开始操作之前 选择一台机器作为一号节点，这台机器将会成为我们第一个配置的节点，也将成为LXD集群leader。（之后下线也不要紧，集群会自动推选leader节点） 配置宿主机网络 在内网中，我们有的是ip，完全没必要通过端口转发去访问容器。因此，我这里将介绍使用网络桥接的方案，让容器直接找路由器dhcp获取ip来上网。 首先，确认你的网络端口，输入 1ip addr 可能获得形如以下的输出，找到其中的有内网ip的那个，那个就是你机器上用来上网的网卡，记住它的名字，并确认你的内网网段（我们待会要给宿主机设置静态ipv4地址） 比如说在我这里的例子中，网卡名为eno1np0，内网网段为192.168.66.0/24 12345678910111213141516171819201: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever2: eno1np0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 10:ff:e0:a9:8c:1d brd ff:ff:ff:ff:ff:ff altname enp97s0f0np0 inet 192.168.66.172/24 brd 192.168.66.255 scope global dynamic noprefixroute eno1np0 valid_lft 86367sec preferred_lft 86367sec inet6 fd77:9bdf:765e::ddb/128 scope global noprefixroute valid_lft forever preferred_lft forever inet6 fd77:9bdf:765e:0:d3f7:c207:d6b3:baa6/64 scope global temporary dynamic valid_lft 604768sec preferred_lft 85838sec inet6 fd77:9bdf:765e:0:ef89:f3cc:72fe:359b/64 scope global mngtmpaddr noprefixroute valid_lft forever preferred_lft forever inet6 fe80::d213:e835:1202:7e04/64 scope link noprefixroute valid_lft forever preferred_lft forever... 编辑文件etc/netplan/50-cloud-init.yaml （有可能不是这个名字，请自行tab） 修改为形如以下的内容： 1234567891011121314151617network: version: 2 ethernets: eno1np0: # 这里要修改为你刚刚看到的网卡端口名 dhcp4: no optional: true bridges: br0: # 给新建的桥接端口起个名，我这里以br0为例，后续将沿用这个名字 interfaces: [eno1np0] # 和上面的网卡端口名保持一致 dhcp4: no addresses: [192.168.66.41/24] # 根据你的内网网段自行选择一个静态ipv4，请提前确认这个ip无其他设备使用 routes: - to: default via: 192.168.66.1 # 网关，一般为把你的内网ip最后一位改成1，如果不一致请自行确认 metric: 100 nameservers: addresses: [1.1.1.1, 8.8.8.8] 如果你发现你的网络配置是cloudinit下发的，可以选择关闭cloudinit，或是自行修改cloudinit配置，这里以关闭cloudinit为例： 123sudo tee /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg &lt;&lt;EOFnetwork: &#123;config: disabled&#125;EOF 输入以下命令，以检查配置是否有效并应用网络配置。 1sudo netplan try 安装LXC与LXD 123sudo apt updatesudo apt install lxcsudo snap install lxd 配置一号节点 输入以下命令开启交互式配置，系统会一句一句问你需要什么样的配置，以下给出我的回答案例供参考 1sudo lxd init 123456789101112131415Would you like to use LXD clustering? (yes/no) [default=no]: yes #是否要启用集群，yesWhat IP address or DNS name should be used to reach this server? [default=100.64.0.14]: 100.64.0.14 # 这里填入要访问这台机器控制端api的域名或ip，对于普通情况下，填入内网ip即可Are you joining an existing cluster? (yes/no) [default=no]: noWhat member name should be used to identify this server in the cluster? [default=4080-2]:Do you want to configure a new local storage pool? (yes/no) [default=yes]:Name of the storage backend to use (zfs, btrfs, dir, lvm) [default=zfs]:Create a new ZFS pool? (yes/no) [default=yes]:Would you like to use an existing empty block device (e.g. a disk or partition)? (yes/no) [default=no]: # 是否要用一个单独的硬盘或分区来作为存储池，按实际需求填写即可Size in GiB of the new loop device (1GiB minimum) [default=30GiB]: 1000GiBDo you want to configure a new remote storage pool? (yes/no) [default=no]:Would you like to connect to a MAAS server? (yes/no) [default=no]:Would you like to configure LXD to use an existing bridge or host interface? (yes/no) [default=no]: yes #是否使用配好的网络接口，yes（我们刚刚配了桥接接口）Name of the existing bridge or host interface: br0 #这里填入刚刚给桥接接口起的名Would you like stale cached images to be updated automatically? (yes/no) [default=yes]:Would you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]: 其他节点加入集群 首先，要在一号节点上（事实上，任何节点都能执行节点配置命令，只不过目前我们只有一号节点配置好了）设置集群的加入密码 1lxc config set core.trust_password 你的密码 在执行以下操作之前，请在每台机器上都完成配置宿主机网络与安装LXC和LXD这两步。 类似的，输入sudo lxd init进入交互式配置 以下以我的交互为例： 123456789101112131415Would you like to use LXD clustering? (yes/no) [default=no]: yesWhat IP address or DNS name should be used to reach this server? [default=172.17.0.1]: 100.64.0.15 #同上，一般填这台机器的内网地址Are you joining an existing cluster? (yes/no) [default=no]: yesDo you have a join token? (yes/no/[token]) [default=no]: noWhat member name should be used to identify this server in the cluster? [default=ubuntu]: 3080-2IP address or FQDN of an existing cluster member (may include port): 100.64.0.14 #这里填一号节点刚刚填入的访问地址Cluster fingerprint: fb04d9240aef4ce4dc0137afc50fc2bbe29dbaca1d9c587b42882d21400c07bbYou can validate this fingerprint by running &quot;lxc info&quot; locally on an existing cluster member.Is this the correct fingerprint? (yes/no/[fingerprint]) [default=no]: yesCluster trust password:All existing data is lost when joining a cluster, continue? (yes/no) [default=no] yesChoose &quot;size&quot; property for storage pool &quot;local&quot;:Choose &quot;source&quot; property for storage pool &quot;local&quot;:Choose &quot;zfs.pool_name&quot; property for storage pool &quot;local&quot;:Would you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]: 使用你的LXD集群 到此，我们集群就算配置好啦 ★,°:.☆(￣▽￣)/$:.°★ 。 接下来我们需要配置一个容器模板（或者说如果你喜欢直接用最原生态的什么都没装的容器（比如说原版ubuntu-server）并直接分发给组员，倒也不是不行（逃） 首先，创建一个基于原版ubuntu server的容器，版本以24.04为例： 123456# 以下命令在任意LXD节点执行均可，LXD集群的最大魅力就是一处配置处处同步# 启动一个基于ubuntu 24.04的容器，容器名为template，在名为node1的宿主机上启动（不填这个--target node1也行，会自动选一个最合适的宿主机）sudo lxc launch ubuntu:24.04 template --target node1# 进入容器（使用刚刚创建的template容器的bash）sudo lxc exec template bash 输入完上述命令后会进入容器template的bash，接下来是配置这个容器的环节，之后这个容器会被导出成镜像作为新容器的创建模板，按照你的喜好来做即可 以下为我的操作，仅供参考 12345678910111213141516171819timedatectl set-timezone Asia/Shanghai # 修改时区apt update &amp;&amp; apt install ssh openssh-server #安装ssh-server# 在我的实践中，发现这样安装的ssh会被cloud init设置为不允许密码登录，需要手动取消。在我这里，这个设置的文件是etc/ssh/sshd_config.d/60-cloudimg-settings.conf，把里面的PasswordAuthentication no 去掉即可nano /etc/ssh/sshd_config.d/60-cloudimg-settings.conf# 安装显卡驱动wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2404/x86_64/cuda-keyring_1.1-1_all.debdpkg -i cuda-keyring_1.1-1_all.debapt-get updateapt-get install -y nvidia-open-570 #显卡驱动版本要和宿主机一模一样，注意调整这里的版本号reboot #重启容器让驱动生效nvidia-smi #检查驱动是否生效# 重新连接容器，在任意宿主机上输入：sudo lxc exec template bashapt-get -y install cuda-toolkit-12-8 # 安装cudaadduser user # 创建一个新用户给之后别人使用（或者直接用root也行）usermod -G sudo user # 赋予管理员权限（在容器内别人爱怎么搞都没事）nano /home/user/.bashrc # 往bashrc里写cuda的地址，具体怎么搞就不在这篇文章中赘述了 完成模板容器配置后，在任意节点输入 12lxc stop template #停止刚刚修改的容器lxc publish template --alias templateName --public #把刚刚的容器打包成一个名为templateName的模板发布 这些模板是跨节点的，可以在任意节点使用，要分配容器时，只需： 1sudo lxc launch templateName containerName --target node1 #在节点node1上使用templateName模板启动一个名为containerName的容器 找到容器ip（看路由器/lxc list找均可），把这个ip（以及创建的默认账户密码）告诉你的师门，搞定~ 配置共享目录 （选做） 有的时候部分数据是需要跨容器共享的，需要在宿主机上划分一个目录以供各个容器挂载并共享。如果你没有多容器（同一台宿主机上的，若需要跨宿主机共享一些存储，可以考虑进一步的网络数据盘方案）共享目录的需求，可以跳过本小节。 在所有节点上准备同名目录 要在每台机器的硬盘上都划分一个区域（目录）用来存放共享数据，并将这个位置挂载到容器里。那么首先，需要在集群每个节点上都以相同的路径创建一个目录，比如： 1234sudo mkdir -p /srv/data# 赋予容器读写权限需要的权限/用户组sudo chown root:root /srv/datasudo chmod 755 /srv/data 该目录名称 /srv/data 只是示例，你也可以用其他路径，只要各节点一致即可。 若你真的想要所有节点“共享”同一份数据（即完全相同的内容），则需要在各节点上把 /srv/data 这个目录挂载同一个网络卷，例如 NFS、GlusterFS、CephFS 等。那时容器里看到的就是同一份数据。 如果你只想让每台节点的 /srv/data 独立存放各自的数据（但容器模板统一），只需在各节点上创建相同的目录即可，无需共享存储。 通过 LXD 配置文件/Profiles 的方式挂载目录 在 LXD 中，可以通过创建一个新的 profile，将主机上的目录挂载到容器里。这样你在给容器应用该 profile 时，就能自动加载挂载点。 创建一个新的 profile，假设叫做 myshared： 1lxc profile create myshared 使用编辑器打开该 profile： 1lxc profile edit myshared 在 profile 的配置文件里添加一个 devices 节点，把 /srv/data（主机路径）映射到 /data（容器内路径）： 12345678config: &#123;&#125;description: &quot;profile for mounting local /srv/data into container&quot;devices: mydata: path: /data source: /srv/data type: diskname: myshared 保存退出之后，profile 就创建好了。 当你要基于同一个容器镜像创建容器时，直接指定要使用 myshared profile： 12# 假如你有一个叫 ubuntu:20.04 的镜像，并希望它在node1节点启动lxc launch ubuntu:20.04 mycontainer -p default -p myshared --target node1 这样创建出来的容器就会自动在 /data 挂载宿主机的 /srv/data 目录。 只要每个节点（宿主机）都具备同名目录 /srv/data，这个 profile 在不同节点上都能生效，而容器本身用的镜像模板是同一个，不需要为每个节点做单独的镜像。","categories":[],"tags":[]},{"title":"基于caddy反向代理内网/vpn内网站","slug":"基于caddy反向代理内网-vpn内网站","date":"2025-02-23T07:32:41.000Z","updated":"2025-02-23T07:32:41.000Z","comments":true,"path":"2025/02/23/基于caddy反向代理内网-vpn内网站/","permalink":"http://www.goldenpotato.cn/2025/02/23/%E5%9F%BA%E4%BA%8Ecaddy%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%86%85%E7%BD%91-vpn%E5%86%85%E7%BD%91%E7%AB%99/","excerpt":"","text":"要反向代理内网的网站，主要难点来自于caddy默认的HTTP-01证书获取模式是没法使用的（因为域名指向内网，而认证服务器显然没法访问内网地址），需要走DNS-01模式。本文主要以腾讯云（dnspod）为例，介绍如何将腾讯云dns模块编译进caddy中并完成认证过程。 科学上网 腾讯云dns模块在github上。总所周知，裸连github是个非常玄学的事情，强烈建议提前准备魔法上网并将http/https代理写入source中以避免天朝特有的网络问题。 12345678# 编辑文件 ~/.bashrc# 在最底下添加这几句export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot;export HTTP_PROXY=&quot;$http_proxy&quot;export HTTPS_PROXY=&quot;$https_proxy&quot;export no_proxy=&quot;localhost,127.0.0.1,.example.com&quot;export NO_PROXY=&quot;$no_proxy&quot; 加载source 1source ~/.bashrc 安装Go &amp;&amp; 编译工具 （xcaddy） Caddy官方的编译工具 xcaddy需要go语言环境，请参考https://go.dev/wiki/Ubuntu安装。 1go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest 指定dns模块编译caddy 1~/go/bin/xcaddy build --with github.com/caddy-dns/tencentcloud 其中，命令里–with后填入要编译的模块仓库，请自行替换为你需要的dns挑战模块。 可同时添加多个模块，如： 1xcaddy build --with github.com/user/module1 --with github.com/user/module2 验证编译结果 1~/go/bin/caddy list-modules | grep tencentcloud #替换成你的模块名 如果出现了你要的模块，证明编译成功了，接下来就是把这个二进制文件替换原有的二进制文件。 二进制替换 1234sudo systemctl stop caddy # 停止caddy服务# 可以考虑替换前备份原有的二进制文件sudo cp ~/go/bin/caddy /usr/local/bin/caddysudo cp /usr/local/bin/caddy /usr/bin/caddy 修改你的caddy配置 请你参考你的dns模块README修改你的caddy配置文件，如腾讯云（dnspod）是这样填的： 123456789101112# 修改这里的全局配置，如果没有全局配置自行添加即可&#123; acme_dns tencentcloud &#123; secret_id 你的腾讯云SECRET_ID secret_key 你的腾讯云SECRET_KEY &#125;&#125;# 以下为你的各个网站your.site &#123; reverse_proxy 192.168.66.1:80&#125; 搞好啦，撒花~ ★,°:.☆(￣▽￣)/$:.°★ 。","categories":[],"tags":[]},{"title":"cuda异步复制数据","slug":"cuda异步复制数据","date":"2024-12-13T02:28:38.000Z","updated":"2024-12-13T02:28:38.000Z","comments":true,"path":"2024/12/13/cuda异步复制数据/","permalink":"http://www.goldenpotato.cn/2024/12/13/cuda%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE/","excerpt":"","text":"本文主要记录如何在device代码内异步把数据从全局内存复制至shared内存，有关如何异步把数据从主机端拷贝到设备端，可以参考How to Overlap Data Transfers in CUDA C/C++ | NVIDIA Technical Blog 本文主要内容来源于英伟达博客：Controlling Data Movement to Boost Performance on the NVIDIA Ampere Architecture | NVIDIA Technical Blog 引言 早期，使用CudaDMA可以通过多分配一个warp用来搬运数据，剩余的计算warp异步执行计算动作。随着Ampere架构（30系）的推出，借助新硬件架构的支持，英伟达推出了新的数据异步搬运方案：cuda::memcpy_async，无需多余的搬运线程即可异步从global内存往shared内存搬运数据。 使用传统的每个线程搬数据的方案 some_shared_memory[threadIdx.x] = some_global_memory[threadIdx.x]时，数据会经过L2缓存-&gt;L1缓存-&gt;寄存器-&gt;Shared这一流程。其中需要借用到寄存器来中转数据。但使用 cuda::memcpy_async无需把数据临时放置到寄存器中，在部分情况下可以有效提高并发性（有时warp的启动数目会受到寄存器不足的限制，这种情况多半是每个thread（或warp）使用了过多的寄存器）。 参考资料 Controlling Data Movement to Boost Performance on the NVIDIA Ampere Architecture | NVIDIA Technical Blog","categories":[],"tags":[{"name":"hpc","slug":"hpc","permalink":"http://www.goldenpotato.cn/tags/hpc/"}]},{"title":"TensorCore","slug":"TensorCore","date":"2024-11-22T02:09:47.000Z","updated":"2024-11-22T02:09:47.000Z","comments":true,"path":"2024/11/22/TensorCore/","permalink":"http://www.goldenpotato.cn/2024/11/22/TensorCore/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CUB 学习笔记","slug":"CUB-学习笔记","date":"2024-09-10T01:40:10.000Z","updated":"2024-09-10T01:40:10.000Z","comments":true,"path":"2024/09/10/CUB-学习笔记/","permalink":"http://www.goldenpotato.cn/2024/09/10/CUB-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本文中所有的例程改编于CUB文档 什么是CUB 一个提供了一系列基于thread、warp、block、device等维度的便利函数的库，如：block级的基数排序（可以把一个block能访问到的数据都排好序）、warp级的读入函数（按照warp从核函数实参中的数组读入数据到thread的数组上）。 以下为一个使用block级的基数排序的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cub/cub.cuh&gt;//// Block级的基数排序（aka只能排序同个block的数据）//template&lt;int BLOCK_THREADS, int ITEMS_PER_THREAD&gt;__global__ void BlockSortKernel(int *d_in, int *d_out)&#123; // 使用using缩写需要用到的cub函数（类） using BlockLoadT = cub::BlockLoad&lt; int, BLOCK_THREADS, ITEMS_PER_THREAD, cub::BLOCK_LOAD_TRANSPOSE&gt;; using BlockStoreT = cub::BlockStore&lt; int, BLOCK_THREADS, ITEMS_PER_THREAD, cub::BLOCK_STORE_TRANSPOSE&gt;; using BlockRadixSortT = cub::BlockRadixSort&lt; int, BLOCK_THREADS, ITEMS_PER_THREAD&gt;; // block级的cub函数需要某种shared memory来作为临时变量，这里使用union来让不同的cub函数复用 __shared__ union &#123; typename BlockLoadT::TempStorage load; typename BlockStoreT::TempStorage store; typename BlockRadixSortT::TempStorage sort; &#125; temp_storage; // 使用cub的block级的load函数读取数据到thread的数组里 int thread_keys[ITEMS_PER_THREAD]; int block_offset = blockIdx.x * (BLOCK_THREADS * ITEMS_PER_THREAD); BlockLoadT(temp_storage.load).Load(d_in + block_offset, thread_keys); __syncthreads(); // 因为要重用临时的shared变量，需要同步，下同 // block级基数排序，如果原先每个thread里的数据分别为：[1,4,6],[8,7,3],[9,4,7]，排序过后就会变为：[1,3,4],[4,6,7],[7,8,9] BlockRadixSortT(temp_storage.sort).Sort(thread_keys); __syncthreads(); // 临时变量重用所需 // 使用cub的block级别的保存函数把数据输出到实参数组里 BlockStoreT(temp_storage.store).Store(d_out + block_offset, thread_keys);&#125;int main()&#123; int *in_d, *out_d; static const int n = 128 * 16; cudaMallocManaged(&amp;in_d, sizeof(int) * n); cudaMallocManaged(&amp;out_d, sizeof(int) * n); for (auto i = 0; i &lt; n; i++) in_d[i] = n - i; BlockSortKernel&lt;128, 16&gt;&lt;&lt;&lt;1, 128&gt;&gt;&gt;(in_d, out_d); //需要注意每个thread的线程数和cub函数里设置的线程数（在本例子中使用模板参数传入）应该保持一致，因为cub本质上也是给手写的方法包一层，并不会凭空增加或减少内存 cudaDeviceSynchronize(); for (auto i = 0; i &lt; n; i++) printf(&quot;%d &quot;, out_d[i]); cudaFree(in_d); cudaFree(out_d); return 0;&#125; CUB食用方法 CUB 方法分类 CUB方法分为四层，分别是thread级、warp级、block级与device级。一般来说，thread级的函数是内部实现使用的，不会作为API暴露出来。 下表展示了各个层级方法的特点: 层级 合作调用 并行执行 最大线程数 结果存于 thread - - 1 该线程 warp + + 32 第一个线程 block + + 1024 第一个线程 device - + $\\infty$ 全局内存 表中，合作调用指的是某个方法是否会一次性调用一大堆。比如说warp级与block级的方法，本质上都是每个thread都要执行某些函数并合作完成这个方法（一个典型例子为block级的归并排序，每个thread都要完成自己thread的内部归并，再一层层把结果归并到第一个thread上）。调用device层级的方法就像调用了一个cuda核函数，不太可能一次性调用多个（多流情况暂不考虑）。 并行执行为字面义，指某个方法是否为并行的。对于thread级的方法，显然其是串行执行的（比如说thread级的reduce，就是某个线程把值从头加到尾（和的reduce））。 结果存于第一个线程指的是对于warp和block层级的方法，其第一个线程拿的变量才代表真正的结果（一个典型的例子是shuffle_down，显然结果会被规约到第一个线程）。对于device层级的方法，其结果会被作为一个实参输出出来（这个实参会被先放到全局显存中，调用者再自行选择是否cudaMemcpy到host）。 值得注意的是，CUB中的warp与硬件上的warp（一个warp32线程）并不完全一样。CUB中的warp为一个虚拟概念，可以自由分配1-32个线程。当线程数正好为32时（这也是默认值），任务会被交由一个真实的硬件warp执行。其他情况下，该warp并不直接对应任何的硬件单元。 CUB 基本知识 所有CUB方法都是按照模板类来提供的，例如block级的reduce方法： 12345678910111213141516171819template&lt;typename T, int BLOCK_DIM_X, BlockReduceAlgorithm ALGORITHM = BLOCK_REDUCE_WARP_REDUCTIONS, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1, int LEGACY_PTX_ARCH = 0&gt;class BlockReduce...//调用：__global__ void ExampleKernel(...)&#123; // Specialize BlockReduce for a 1D block of 128 threads of type int using BlockReduce = cub::BlockReduce&lt;int, 128&gt;; // Allocate shared memory for BlockReduce __shared__ typename BlockReduce::TempStorage temp_storage; // Obtain a segment of consecutive items that are blocked across threads int thread_data[4]; ... // Compute the block-wide max for thread0 int aggregate = BlockReduce(temp_storage).Reduce(thread_data, cub::Max()); 方法（block级、warp级）都需要临时的shared变量（该变量会用一个struct打包所有需要的临时值，可以用 方法类名::TempStorage获取该方法所需的临时变量的struct） 根据传入参数的不同（比如说warp级的方法中的线程数是不是2的偶数倍）会在编译期或运行期选用不同的实现。 warp级、block级方法的线程数需要在编译期确定下来。 CUB 使用流程 无论是什么层级的CUB方法，基本上都按照下面的流程进行调用： 选择要使用的方法类（并确定参数）：如` using BlockReduce = cub::BlockReduce&lt;int, 128&gt;; 查询该方法需要的临时shared变量的类型（某种struct），如： using TempStorage = typename BlockReduce::TempStorage; 创建该临时变量，如：__shared__ TempStorage temp_storage; 创建方法类并调用，如：auto result = block_reduce&#123;temp_storage&#125;.Sum(data); //这个result只在第一个线程中才是真的，参考本大节第一小节 以下为一个完整的block级方法的调用例子： 1234567891011121314151617181920212223__global__ void kernel(int* per_block_results)&#123; // (1) Select the desired class // `cub::BlockReduce` is a class template that must be instantiated for the // input data type and the number of threads. Internally the class is // specialized depending on the data type, number of threads, and hardware // architecture. Type aliases are often used for convenience: using BlockReduce = cub::BlockReduce&lt;int, 128&gt;; // (2) Query the temporary storage // The type and amount of temporary storage depends on the selected instantiation using TempStorage = typename BlockReduce::TempStorage; // (3) Allocate the temporary storage __shared__ TempStorage temp_storage; // (4) Pass the temporary storage // Temporary storage is passed to the constructor of the `BlockReduce` class BlockReduce block_reduce&#123;temp_storage&#125;; // (5) Invoke the algorithm // The `Sum()` member function performs the sum reduction of `thread_data` across all 128 threads int thread_data[4] = &#123;1, 2, 3, 4&#125;; int block_result = block_reduce.Sum(thread_data); per_block_results[blockIdx.x] = block_result;&#125;","categories":[],"tags":[{"name":"HPC","slug":"HPC","permalink":"http://www.goldenpotato.cn/tags/HPC/"}]},{"title":"MSM GPU加速相关文章阅读笔记","slug":"MSM-GPU加速相关文章阅读笔记","date":"2024-09-07T01:40:37.000Z","updated":"2024-09-07T01:40:37.000Z","comments":true,"path":"2024/09/07/MSM-GPU加速相关文章阅读笔记/","permalink":"http://www.goldenpotato.cn/2024/09/07/MSM-GPU%E5%8A%A0%E9%80%9F%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"文章 会议 等级 阅读情况 Accelerating Multi-Scalar Multiplication for Efficient Zero Knowledge Proofs with Multi-GPU Systems2024 ASPLOS 2024 CCF-A [] GZKP: A GPU Accelerated Zero-Knowledge Proof System 2023 - 5 并行化方法 称把一个桶的点加起来的计算位一个点合并任务。将多个点合并任务分配到一个block上。每个点合并任务都分配一个warp。 其中，warp内使用合作组（cooperative groups）来并行执行点加运算。同一个warp会被拆分为多个合作组，每个合作组都独立执行点加运算。 考虑到不同点合并任务的负载（点的个数）不同，文章会按照任务负载将任务分配到不同的blcok上，一个block可能会被分配多个任务。 预计算 与其于把各个window分开计算并最后通过window reduction合并到一起，本文预先计算了每个点在各个windows下经过对应偏移量的值(i.e. 乘以对应窗口的系数)。如此操作过后，不同窗口但标量相同的点就可以使用同一个桶了。从而增大了单个桶的大小，去除了窗口合并时的点乘。 核心原理： 原来的Pippenger计算方法为把标量$k_i$按位分块，从而把原本完整的MSM计算拆分位多个在不同位上的MSM子问题（窗口），如下公式所示。 $$\\sum k_i \\cdot P_i = \\sum_j 2^{(j-1) \\cdot S} \\sum_i k_{ij} \\cdot P_i$$ 其中，$S$为每个子问题位长，$k_{ij}$表示第$i$个标量的第$j$段。 上式可以变为： $$\\sum_j \\sum_i k_{ij} \\cdot (2^{j-1} \\cdot P_i)$$ 考虑到对于固定问题的ZKP，其$P_i$是在不同批次的MSM中保持不变的，变的只有标量，故预计算只需要进行一次即可。 但是预计算需要存储巨量的点在显存中，会造成巨大的显存压力。故文章是分段预计算的，没有被预计算覆盖过的点需要在点合并的时候找到最近的有预计算的点，再点乘相应的位数后才能被加到桶中。 有限域计算优化 不只是运用SM上的整数计算单元，把浮点计算单元也利用上以共同执行大整数计算。 Load-Balanced Parallel Implementation on GPUs for Multi-Scalar Multiplication Algorithm 2024 - 3 朴素方法分析 double-and-add方法 需要计算$n\\lambda$次PADD与$\\lambda -1$次PDBL，其中$\\lambda$为椭圆曲线群所在的有限域阶数的二进制位数。 Pippenger $\\lceil \\frac{\\lambda}{c} \\rceil (n + 2^{c+1} - 3)$次PADD及$c(\\lceil \\frac{\\lambda}{c} \\rceil - 1)$次PDBL，其中$c$为窗口位数。 并行化方法 点合并阶段 每个block处理一个窗口（pippenger子问题），每个thread处理固定范围的连续点：$\\left[threadid \\cdot \\lceil n / N \\rceil, (threadid + 1) \\cdot \\lceil n / N \\rceil \\right)$。计算完的结果会被存放到一个不会冲突的全局内存中（下解释） 考虑到不同的标量可能会跨过每个线程分管的范围，若所有线程直接公用同一个global memory存放结果，势必会造成冲突：如上图所示($a_i$表示标量(pippenger分块过后的))，线程0和线程1均分别计算了标量为1的部分桶。文章分配了一个较大的全局内存并采用了一种偏移机制来避免这个问题。 $$offset_{tid} = tid + min\\left[ \\left\\lceil \\frac{a_i + 1}{2} \\right\\rceil \\right]$$ 式中，$tid$为线程id，$offset_{tid}$表示每个线程写bukkit位置的起始偏移量。显然对于某个线程，前面至少有$tid$个结果。后者考虑最坏情况下每个线程都是满的（aka每个标量都独自出现），原文用了一些标量变换的方法使得标量只有奇数的，故需要除以2后上取整。 记录下每个位置上放了什么bukkit，这个数组必然是单调递增的，可以采用二分查找的方法把分处于不同缓存区域的bukkit给加起来。 桶累积阶段 标量变换&amp;预计算 原先每个$k_{i,j} \\in [0, 2^c - 1]$，考虑到椭圆曲线上取反操作廉价，将原先的$k_{i,j}$变为有符号数$k’_{i,j} \\in [- 2^{c-1} -1, 2^{c-1} -1]$，将大于等于$2^{c-1}$的标量变为负数，并将对应$P$取反。 PADD优化","categories":[],"tags":[{"name":"HPC","slug":"HPC","permalink":"http://www.goldenpotato.cn/tags/HPC/"}]},{"title":"c++笔记","slug":"c++笔记","date":"2024-07-24T03:19:29.000Z","updated":"2024-09-14T03:19:29.000Z","comments":true,"path":"2024/07/24/c++笔记/","permalink":"http://www.goldenpotato.cn/2024/07/24/c++%E7%AC%94%E8%AE%B0/","excerpt":"","text":"cmake https://subingwen.cn/cmake/CMake-primer/index.html consteval与constexpr https://tjsw.medium.com/潮-c-20-consteval-constexpr-的好兄弟-bfbcfdd4c763 运算小寄巧 虽然跟c++没啥关系，但懒得开新post了，就放这吧。 向上取整到整数$x$的某个最近倍数上：num = (num + x - 1) &amp; (0-x)。 检查某个数$x$是不是2的幂次方：!(x &amp; (x-1)) 获取某个数$x$的最低位的1以及其之后所有的0：x &amp; (0-x)，如：$x =(11100100)_2, x\\ &amp; \\ (0-x) = (00000100)_2$ 将2,3配合到一起可以把一个数变为一个比该数小的最近2的幂次方的数： 12while(x &amp; (x-1)) x -= x &amp; (0-x);","categories":[],"tags":[]},{"title":"caddy笔记","slug":"caddy笔记","date":"2024-07-12T17:47:41.000Z","updated":"2024-07-12T17:47:41.000Z","comments":true,"path":"2024/07/13/caddy笔记/","permalink":"http://www.goldenpotato.cn/2024/07/13/caddy%E7%AC%94%E8%AE%B0/","excerpt":"","text":"https://u.sb/xcaddy/","categories":[],"tags":[]},{"title":"ColorOS关闭应用安装安全检查","slug":"ColorOS安装应用关闭安全检查","date":"2024-07-11T15:22:51.000Z","updated":"2024-07-11T15:22:51.000Z","comments":true,"path":"2024/07/11/ColorOS安装应用关闭安全检查/","permalink":"http://www.goldenpotato.cn/2024/07/11/ColorOS%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%E5%85%B3%E9%97%AD%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5/","excerpt":"","text":"如果你擅长使用adb，请直接跳转到STEP5 STEP1 下载ADB 如果你电脑上有ADB可以跳过此步 在google官网上下载adb https://dl.google.com/android/repository/platform-tools-latest-windows.zip?hl=zh-cn 将其解压到你喜欢的位置即可，建议把解压出来的目录加到path里面方便powershell里面直接调用adb而不是夹带一长串的完整路径 可选步骤：把adb添加到path里： 如何添加环境变量: https://jingyan.baidu.com/article/47a29f24610740c0142399ea.html 后续步骤会假设你已经把adb添加到path里了。如果你没有添加并且在后续步骤中出现了类似无法将“adb”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。的报错并且你不知道这个报错是什么意思，请把adb添加到path里来解决这个报错。 STEP2 开启开发者模式 https://jingyan.baidu.com/article/ca00d56c49a8b1a89eebcfe8.html STEP3 打开无线调试 操作前请确保手机与电脑在同一网络环境下（比如说连上相同的wifi） 设置/其他设置/开发者选项/无线调试 记下里面的ip地址与端口 在我的例子中，ip地址与端口为：192.168.20.127:38143 STEP4 使用ADB链接手机 按下WIN+R打开运行窗口，输入wt后回车 如果显示你的电脑上没有wt，那么可以改为输入：powershell 在打开的窗口中输入adb connect 刚刚你看到的ip:端口 STEP5 禁用绿厂的软件安装器与安全管家 禁用安全管家：adb shell pm disable-user com.coloros.phonemanager 禁用软件安装器：adb shell pm disable-user com.oplus.appdetail DONE! 现在可以自由无阻地安装软件啦，撒花~","categories":[],"tags":[]},{"title":"代理大合集","slug":"代理大合集","date":"2024-01-16T11:37:29.000Z","updated":"2024-01-16T11:37:29.000Z","comments":true,"path":"2024/01/16/代理大合集/","permalink":"http://www.goldenpotato.cn/2024/01/16/%E4%BB%A3%E7%90%86%E5%A4%A7%E5%90%88%E9%9B%86/","excerpt":"","text":"代理git http流量： https://ericclose.github.io/git-proxy-config.html 代理apt https://linux.cn/article-15815-1.html 代理docker https://yeasy.gitbook.io/docker_practice/advanced_network/http_https_proxy 为jellyfin配置代理 https://blog.csdn.net/AAMahone/article/details/128966904 在source中配置代理 123456789101112131415161718192021222324# 代理服务器地址和端口PROXY_SERVER=&quot;127.0.0.1&quot;PROXY_PORT=&quot;7890&quot;# 代理开关函数proxy_on() &#123; export http_proxy=&quot;http://$PROXY_SERVER:$PROXY_PORT&quot; export https_proxy=&quot;http://$PROXY_SERVER:$PROXY_PORT&quot; export HTTP_PROXY=$http_proxy export HTTPS_PROXY=$https_proxy export no_proxy=&quot;localhost,127.0.0.1,::1&quot; export NO_PROXY=$no_proxy echo &quot;代理已开启: $http_proxy&quot;&#125;proxy_off() &#123; unset http_proxy unset https_proxy unset HTTP_PROXY unset HTTPS_PROXY unset no_proxy unset NO_PROXY echo &quot;代理已关闭&quot;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-01-05T04:34:51.000Z","updated":"2024-01-05T04:34:51.000Z","comments":true,"path":"2024/01/05/hello-world/","permalink":"http://www.goldenpotato.cn/2024/01/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://www.goldenpotato.cn/categories/uncategorized/"}],"tags":[]},{"title":"pyTorch填坑实录","slug":"pytorch填坑实录","date":"2021-03-14T11:51:10.000Z","updated":"2021-03-14T11:51:10.000Z","comments":true,"path":"2021/03/14/pytorch填坑实录/","permalink":"http://www.goldenpotato.cn/2021/03/14/pytorch%E5%A1%AB%E5%9D%91%E5%AE%9E%E5%BD%95/","excerpt":"","text":"pytorch: grad can be implicitly created only for scalar outputs: 1z.backward(torch.ones_like(x)) 原因：backward必须使用标量来进行 python本身看起来数据类型不敏感，但是pytorch极其敏感，int与double不能直接相加，出现相关错误后应查看数据类型： 12print(tx.dtype) tx=tx.to(dtype=torch.float64) torch.nn.functional.Softmax 和 torch.nn.softmax不是一个东西 前者本质是一个函数，用于最后的lost计算，后者是一个神经元节点的定义 小心tensor的维度，用xxx.size()查看tensor的维度及范围 1print(out.size())","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://www.goldenpotato.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Linux小寄巧","slug":"ubuntu-20-02lts-填坑实录","date":"2021-02-25T14:44:43.000Z","updated":"2025-01-25T14:44:43.000Z","comments":true,"path":"2021/02/25/ubuntu-20-02lts-填坑实录/","permalink":"http://www.goldenpotato.cn/2021/02/25/ubuntu-20-02lts-%E5%A1%AB%E5%9D%91%E5%AE%9E%E5%BD%95/","excerpt":"","text":"Ubuntu启动时如何显示或隐藏启动消息？ https://qastack.cn/ubuntu/248/how-can-i-show-or-hide-boot-messages-when-ubuntu-starts cuda版本查看 https://blog.csdn.net/qq\\_41368074/article/details/107785536 cudnn安装 https://blog.csdn.net/weixin\\_44002829/article/details/111500287 注：在运行demon前需安装freeimage库 sudo apt-get install libfreeimage3 libfreeimage-dev cli连接wifi: https://ubuntu.com/core/docs/networkmanager/configure-wifi-connections cuda测试程序（自用） 123456789101112131415161718192021#include &lt;cstdio&gt;__global__ void test()&#123; printf(&quot;%d\\n&quot;, threadIdx.x);&#125;int main()&#123; test &lt;&lt;&lt;1, 1&gt;&gt;&gt;(); cudaDeviceSynchronize(); auto last_err = cudaGetLastError(); if (last_err != cudaSuccess) &#123; char s[200]; sprintf(s, &quot;CUDA error %s&quot;, cudaGetErrorString(last_err)); printf(&quot;%s\\n&quot;, s); exit(1); &#125; return 0;&#125; 查看某个端口被什么占用了 1sudo lsof -i :8080 赋予promtail docker用户访问/var/log/caddy/.log的权限 为日志文件添加对其他用户 (o) 的读权限：1chmod o+r /var/log/caddy/*.log 或者使用 ACL（Access Control List）让 UID 10001（容器中的 loki 用户）有读权限：1setfacl -m u:10001:r /var/log/caddy/*.log","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://www.goldenpotato.cn/categories/uncategorized/"}],"tags":[]},{"title":"NOIp(大雾)  CSP-S 2019 暴力记","slug":"noip大雾-csp-s-2019-暴力记","date":"2019-11-17T04:36:40.000Z","updated":"2019-11-17T04:36:40.000Z","comments":true,"path":"2019/11/17/noip大雾-csp-s-2019-暴力记/","permalink":"http://www.goldenpotato.cn/2019/11/17/noip%E5%A4%A7%E9%9B%BE-csp-s-2019-%E6%9A%B4%E5%8A%9B%E8%AE%B0/","excerpt":"","text":"咕咕咕 没了，打了整整两天暴力，我太菜了，嘤 目测分数远低于高一那场NOIp 开 倒 车","categories":[{"name":"游记/自闭记/滚粗记","slug":"游记-自闭记-滚粗记","permalink":"http://www.goldenpotato.cn/categories/%E6%B8%B8%E8%AE%B0-%E8%87%AA%E9%97%AD%E8%AE%B0-%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}],"tags":[]},{"title":"AFO后记","slug":"afo后记","date":"2019-04-25T15:00:57.000Z","updated":"2019-04-25T15:00:57.000Z","comments":true,"path":"2019/04/25/afo后记/","permalink":"http://www.goldenpotato.cn/2019/04/25/afo%E5%90%8E%E8%AE%B0/","excerpt":"","text":"我的OI生涯 咕咕咕 接下来的博客计划 接下来呢，我可能就没法刷太多题了，可能只会久不久写一点OI题目。 之后我的博客只要内容会更新学文化课的进度，感想，希望能帮助有困惑的同学，并希望证明一点:OIer是不会被打倒的！ Update 2020/8/2 高考 全国三卷 655 大家哈工大见！ 致谢 感谢无私帮助我的学长们，他们是： zyb学长 (泅荼) hb学长 (nnez_hb) lx学长 (LQAQC) xlw学长 (nnez_xiaoliwei) … 感谢一路上与我并肩作战的同级同学们，他们是： wzj神仙 (Maxwei_wzj) lbc同学 (lizbaka) sry同学 (OrionM42) wpy同学 (Capacitance_core) hzq同学 (Villard) lyj同学 (Uchiha_Obito) … 感谢一路上陪伴我的学弟们，他们是：hjq学弟 (ComputerEngine) hrb学弟 (HRLYB) cwt学弟 (Mireco) … 感谢父母的一路支持，感谢教练的指点教育 感谢所有值得感谢但因为各种原因未在该列表中出现的人","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://www.goldenpotato.cn/categories/uncategorized/"}],"tags":[]},{"title":"GXOI2019 退役记","slug":"gxoi2019-游记","date":"2019-04-11T09:52:17.000Z","updated":"2019-04-11T09:52:17.000Z","comments":true,"path":"2019/04/11/gxoi2019-游记/","permalink":"http://www.goldenpotato.cn/2019/04/11/gxoi2019-%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"DAY1被神题打爆狗头，T1骗了50分就持续自闭了。 DAY2开题5分钟立马锤了一个T1的假DP，然后还对这个假做法有蜜汁自信，拍都没拍就跑路了。 T2有点想法但又没有，总感觉隐隐约约可做但又不会写，最后锤的暴力。 T3暴力很显然，又用splay锤了一个20分的链。 结果是很凄惨的，T1爆零，T2，T3没有意外发生，RANK10退役。 怎么说呢，T1写爆是自己的策略严重失误。平时模拟赛的时候犯这种错误总是安慰自己说考场上不会犯的，事实证明，考场也只是自己平时状态的延续罢了。 如果我T1没有去写DP,就算写那20分的暴力也进队了；如果我T3没有去锤那20分的链，好好去检查T1也进队了；如果我NOIp分数正常一点，DAY2好好写T1不锤T2也进队了 … 可是，人生哪来的如果呢？ 发生这种情况，真的也的确是人菜，活该退役。 想想自己的OI生涯，的确是有很多的失误，比如说不善于反省自己，总是找外部原因，而不去找自身的问题；比如说自己不擅长总结，写题不能做到举一反三什么的… 心里有很多话，可是真的到了落笔的时候却什么也写不出。 但是，我相信，OIer们在文化考场上一定能重振旗鼓，一样能通过文化考上自己理想的大学。 各位，我们2020年高考见！ 关于其他内容，还请移步AFO后记。 说是这样说，但是还是要强烈谴责南宁三中，胜之不武的行为会永远被世人所唾弃！","categories":[{"name":"游记/自闭记/滚粗记","slug":"游记-自闭记-滚粗记","permalink":"http://www.goldenpotato.cn/categories/%E6%B8%B8%E8%AE%B0-%E8%87%AA%E9%97%AD%E8%AE%B0-%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}],"tags":[{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/tags/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}]},{"title":"[Luogu P3975] [TJOI2015]弦论","slug":"luogu-p3975-tjoi2015弦论","date":"2019-04-10T04:19:42.000Z","updated":"2019-04-10T04:19:42.000Z","comments":true,"path":"2019/04/10/luogu-p3975-tjoi2015弦论/","permalink":"http://www.goldenpotato.cn/2019/04/10/luogu-p3975-tjoi2015%E5%BC%A6%E8%AE%BA/","excerpt":"","text":"题面 P3975 [TJOI2015]弦论 Solution 看到题面要求不同情况下的$K$小串，给人一种自动机上做DP就可以写的感觉。 因此，我们考虑用后缀自动机来解决这个问题。我们先建出SAM。 对于$k=0$的情况，肥肠好写。根据SAM的常识，在SAM上任意走都是原串的一个子串。题目要求求出第$k$小不重复子串，既是让我们求出SAM的前$k$条路径。因为这里的$k$很大，我们是不能暴力走的。 因此，我们可以设$f[i]$表示从$i$出发有多少条路径，转移非常显然，$f[i]=\\sum f[j]$(j为i能到的点)。我们用记忆话搜索/拓扑序DP即可求出。 接下来，我们在SAM上做dfs即可。 对于$k=1$的情况，我们则必须求出每个串的出现次数。这需要sam的一点性质。我们知道，SAM的fail树上的任何一个节点所代表的的字符串一定是它的孩子节点所代表的的字符串的后缀。 因此，当前节点所表示的串的出现次数就是1+子孙出现次数，这里要注意一点，复制出来的节点不需要+1，如果+1就会计算重复。计算出来每个串的出现次数后的事情就和$k=0$的做法一模一样了。 时间复杂度$O(n)$ 就酱，这道题就被我们切掉啦ヾ(^Д^*)/ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;//const int N=500;const int N=500000*2+200;struct SAM&#123; static const int M=26; struct node &#123; int son[M],fail,len,size; bool IsNew; &#125;nd[N]; int last,to; void Init() &#123; last=to=1; &#125; void Insert(char c) &#123; int x=c-&#x27;a&#x27;,now=last,n_now=++to; nd[n_now].len=nd[now].len+1; last=n_now; for(;now!=0 and nd[now].son[x]==0;now=nd[now].fail) nd[now].son[x]=n_now; if(now==0) nd[n_now].fail=1; else &#123; int tmp=nd[now].son[x]; if(nd[tmp].len==nd[now].len+1) nd[n_now].fail=tmp; else &#123; int n_tmp=++to; nd[n_tmp]=nd[tmp],nd[n_tmp].len=nd[now].len+1,nd[tmp].fail=n_tmp,nd[n_tmp].IsNew=true; nd[n_now].fail=n_tmp; for(;now!=0 and nd[now].son[x]==tmp;now=nd[now].fail) nd[now].son[x]=n_tmp; &#125; &#125; &#125; vector &lt;int&gt; e[N]; void Build() &#123; for(int i=1;i&lt;=to;i++) e[i].reserve(4); for(int i=1;i&lt;=to;i++) e[nd[i].fail].push_back(i); &#125; int dfs(int now,bool type) &#123; nd[now].size=(nd[now].IsNew==false); for(int i=0;i&lt;int(e[now].size());i++) nd[now].size+=dfs(e[now][i],type); if(type==0) nd[now].size=1; return nd[now].size; &#125; int mstack[N],top,cnt[N]; int dfs2(int now) &#123; if(cnt[now]!=0) return cnt[now]; cnt[now]+=nd[now].size; for(int i=0;i&lt;M;i++) if(nd[now].son[i]!=0) cnt[now]+=dfs2(nd[now].son[i]); return cnt[now]; &#125; bool OK; void dfs3(int now,int K) &#123; if(OK==true) return; K-=nd[now].size; if(K&lt;=0) &#123; OK=true; for(int i=1;i&lt;=top;i++) printf(&quot;%c&quot;,mstack[i]+&#x27;a&#x27;); return; &#125; for(int i=0;i&lt;M;i++) if(nd[now].son[i]!=0) &#123; if(cnt[nd[now].son[i]]&gt;=K) &#123; mstack[++top]=i; dfs3(nd[now].son[i],K); &#125; else K-=cnt[nd[now].son[i]]; &#125; &#125;&#125;sam;char s[N];int K,type;int main()&#123; scanf(&quot;%s%d%d&quot;,s+1,&amp;type,&amp;K); int len=strlen(s+1); sam.Init(); for(int i=1;i&lt;=len;i++) sam.Insert(s[i]); sam.Build(); sam.dfs(1,type); sam.nd[1].size=0; sam.dfs2(1); sam.dfs3(1,K); if(sam.OK==false) printf(&quot;-1&quot;); return 0;&#125;","categories":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"最小树形图构造(朱刘算法)学习笔记","slug":"最小树形图构造朱刘算法学习笔记","date":"2019-04-09T23:33:01.000Z","updated":"2019-04-09T23:33:01.000Z","comments":true,"path":"2019/04/10/最小树形图构造朱刘算法学习笔记/","permalink":"http://www.goldenpotato.cn/2019/04/10/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%E6%9E%84%E9%80%A0%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是最小树形图 最小树形图就是给定一个$n$个点的有向图，我们钦定一个根，现在要找$n-1$条边，在根能到达其他所有点的前提条件下，使得$n-1$条边的总长度尽可能小。 怎么找最小树形图 这里就得用到朱刘算法了。朱刘算法是一个$O(n \\cdot m)$的算法。当然，还有Tarjan巨神的$O(nlogn)$的算法。但我太菜了，并学不会 图出自这里 上面这张图很好的诠释了朱刘算法的主要内容： 我们算法主要有以下几个步骤： 找到到达每个点的长度最小的入边（根节点不找） 这些边如果连成一颗树则结束； 如果这些边中除了根节点以外有孤独一个的点的话，则无解； 否则一定会连出一些环，我们把这些环缩起来，答案加上这些环上边权和，然后构建新图：所有连向这些环的边的边权减去对应的点之前的最小的入边的边权（即步骤1找到的那一条）。建完新图之后回到步骤1。 朱刘算法如何实现 从上面的口胡，我们可以发现，我们要实现一个动态缩点，动态构图的过程。可想而知，算法并不好写。 笔者个人的写法是开两个图，辗转使用。魔改Tarjan来实现找环的过程。 代码在这里(丑不忍赌) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//Luogu P4716 【模板】最小树形图//Apr,9th,2019//朱刘算法求有向图最小生成树#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=2*100+10;const int inf=0x3f3f3f3f;struct edge&#123; int t,w; edge (int x=0,int y=0) &#123; t=x,w=y; &#125;&#125;;vector &lt;edge&gt; e[2][N];edge e2[N];int n,m,r,id[N],cnt,t_now;bool vis[N],gone[N],IsNew[N];int mstack[N],top;int dfs(int now)&#123; int t_ans=0; mstack[++top]=now; vis[now]=gone[now]=true; if(vis[e2[now].t]==true) &#123; cnt++; while(mstack[top+1]!=e2[now].t) IsNew[mstack[top]]=true, id[mstack[top--]]=cnt; t_ans+=e2[now].w; &#125; else if(gone[e2[now].t]==false) &#123; t_ans=dfs(e2[now].t); if(id[now]==cnt) t_ans+=e2[now].w; &#125; vis[now]=false; return t_ans;&#125;int GetID(int x)&#123; if(id[x]==0) return x; return id[x]=GetID(id[x]);&#125;int ZhuLiu(int S)&#123; int ans=0; while(1) &#123; for(int i=1;i&lt;=n;i++) e2[GetID(i)].w=inf; for(int i=1;i&lt;=cnt;i++) for(int j=0;j&lt;int(e[t_now][i].size());j++) if(e[t_now][i][j].t!=S and e[t_now][i][j].w&lt;e2[e[t_now][i][j].t].w) e2[e[t_now][i][j].t].t=i, e2[e[t_now][i][j].t].w=e[t_now][i][j].w; for(int i=1;i&lt;=n;i++) if(i!=S and e2[GetID(i)].w==inf) return -1;//有单独点 memset(gone,0,sizeof gone); memset(vis,0,sizeof vis); memset(IsNew,0,sizeof IsNew); int t_ans=0; for(int i=1;i&lt;=n;i++) if(gone[GetID(i)]==false and i!=S) top=0, t_ans+=dfs(GetID(i)),gone[cnt]=true; ans+=t_ans; if(t_ans==0) &#123; memset(vis,0,sizeof vis); bool OK=false; for(int i=1;i&lt;=n;i++) if(i!=S and vis[GetID(i)]==false) OK=max(OK,e2[GetID(i)].t==S), ans+=e2[GetID(i)].w,vis[GetID(i)]=true; if(OK==false) ans=-1; break; //无环，完成 &#125; int mnext=(t_now+1)%2; for(int i=1;i&lt;=cnt;i++) e[mnext][i].clear(); for(int i=1;i&lt;=cnt;i++) for(int j=0;j&lt;int(e[t_now][i].size());j++) if(GetID(i)!=GetID(e[t_now][i][j].t)) &#123; if(IsNew[e[t_now][i][j].t]==true) e[mnext][GetID(i)].push_back(edge(GetID(e[t_now][i][j].t),e[t_now][i][j].w - e2[e[t_now][i][j].t].w)); else e[mnext][GetID(i)].push_back(edge(GetID(e[t_now][i][j].t),e[t_now][i][j].w)); &#125; t_now=(t_now+1)%2; &#125; return ans;&#125;int main()&#123; freopen(&quot;4716.in&quot;,&quot;r&quot;,stdin); freopen(&quot;4716.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(),r=read(); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(),w=read(); if(s==t) continue; e[t_now][s].push_back(edge(t,w)); &#125; cnt=n; int ans=ZhuLiu(r); printf(&quot;%d&quot;,ans); return 0;&#125; 朱刘算法的应用 目前好像只有模板题","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"UVA10972 RevolC FaeLoN","slug":"uva10972-revolc-faelon","date":"2019-04-09T03:47:47.000Z","updated":"2019-04-09T03:47:47.000Z","comments":true,"path":"2019/04/09/uva10972-revolc-faelon/","permalink":"http://www.goldenpotato.cn/2019/04/09/uva10972-revolc-faelon/","excerpt":"","text":"题面 UVA10972 RevolC FaeLoN Solution 这题就比较牛皮。 我们先来考虑一下图联通的话怎么做。显然，我们可以先把图按边双缩点，边双内部是肯定不用加任何一条有向边就能改成强连通分量的（易证）。 缩完点之后，图一定会变成一颗树。接下来我们依旧可以像这道题那样贪心。我们数一下广义叶子数有多少，要加的边的个数一定为$sum/2$（向上取整）。 连边方式如图所示： 接下来再来考虑不连通的情况。显然，我们可以发现，对于多颗树来说，我们依旧可以照样刚刚那样贪心。我们左右两棵树在叶子那里连边即可。 因此，我们的总答案依旧是$sum/2$（向上取整） 时间复杂度$O(n)$ 就酱，这题就被我们切掉啦(*≧▽≦) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//UVA10972 RevolC FaeLoN//Apr,9th,2019//边双#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=1000+10;vector &lt;int&gt; e[N],e2[N];int dfn[N],dfn_to,low[N],mstack[N],top,belong[N],cnt;bool vis[N],InStack[N];void Tarjan(int now,int father)&#123; vis[now]=InStack[now]=true; mstack[++top]=now; dfn[now]=low[now]=++dfn_to; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; Tarjan(e[now][i],now); low[now]=min(low[now],low[e[now][i]]); &#125; else if(e[now][i]!=father and InStack[e[now][i]]==true) low[now]=min(low[now],dfn[e[now][i]]); if(low[now]==dfn[now]) &#123; cnt++; while(mstack[top+1]!=now) InStack[mstack[top]]=false, belong[mstack[top--]]=cnt; &#125;&#125;int n,m;int dfs(int now,int father)&#123; vis[now]=true; int t_ans=0; for(int i=0;i&lt;int(e2[now].size());i++) if(e2[now][i]!=father) t_ans+=dfs(e2[now][i],now); if(e2[now].size()==1) t_ans++; if(e2[now].size()==0) t_ans+=2; return t_ans;&#125;int main()&#123; for(int o=1;;o++) &#123; if(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==EOF) break; for(int i=0;i&lt;=n;i++) e[i].clear(),e2[i].clear(); for(int i=1;i&lt;=n;i++) e[i].reserve(4),e2[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; memset(vis,0,sizeof vis); memset(mstack,0,sizeof mstack); dfn_to=cnt=0; for(int i=1;i&lt;=n;i++) if(vis[i]==false) Tarjan(i,i); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;int(e[i].size());j++) if(belong[i]!=belong[e[i][j]]) e2[belong[i]].push_back(belong[e[i][j]]); memset(vis,0,sizeof vis); if(cnt==1) printf(&quot;0\\n&quot;); else &#123; int ans=0; for(int i=1;i&lt;=n;i++) if(vis[belong[i]]==false) ans+=dfs(belong[i],belong[i]); printf(&quot;%d\\n&quot;,ans/2+ans%2); &#125; &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"边双/点双","slug":"边双-点双","permalink":"http://www.goldenpotato.cn/categories/%E8%BE%B9%E5%8F%8C-%E7%82%B9%E5%8F%8C/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"UVA610 Street Directions","slug":"uva610-street-directions","date":"2019-04-09T01:31:53.000Z","updated":"2019-04-09T01:31:53.000Z","comments":true,"path":"2019/04/09/uva610-street-directions/","permalink":"http://www.goldenpotato.cn/2019/04/09/uva610-street-directions/","excerpt":"","text":"题面 UVA610 Street Directions Solution 先来解释一下题面意思：我们现在有一个联通的无向图，我们要把整个图改造为有向图，在保证强连通的情况下使得双向边尽可能少。 我们不妨思考一下：如果一条双向边被我们改造为了单向边，会导致某一个方向上的断开。因此，我们先对原图做边双缩点，桥边是不可能被改造为单向边的（因为改造后直接导致边双间不能互相联通）。 除了桥边之外，其他边都是可以改造为单向边的。 因此，我们可以在每一个边双里面做一个dfs来连单向边，桥边直接连上双向边即可。 时间复杂度$O(n)$ 就酱，这题就被我们切掉啦ヾ(●´∀｀●) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Luogu UVA610 Street Directions//Apr,9th,2019//Tarjan求点双#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=1000+10;vector &lt;int&gt; e[N],e2[N];int dfn[N],dfn_to,low[N],mstack[N],top,belong[N],cnt;bool vis[N],InStack[N];void Tarjan(int now,int father)&#123; vis[now]=InStack[now]=true; mstack[++top]=now; dfn[now]=low[now]=++dfn_to; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; Tarjan(e[now][i],now); low[now]=min(low[now],low[e[now][i]]); &#125; else if(e[now][i]!=father and InStack[e[now][i]]==true) low[now]=min(low[now],dfn[e[now][i]]); if(low[now]==dfn[now]) &#123; cnt++; while(mstack[top+1]!=now) InStack[mstack[top]]=false, belong[mstack[top--]]=cnt; &#125;&#125;int Find(int now,int x)&#123; for(int i=0;i&lt;int(e[now].size());i++) if(e[now][i]==x) return i; return -1;&#125;void dfs2(int now)&#123; if(vis[now]==true) return; vis[now]=true; for(int i=0;i&lt;int(e[now].size());i++) if(belong[e[now][i]]==belong[now]) &#123; printf(&quot;%d %d\\n&quot;,now,e[now][i]); e[e[now][i]][Find(e[now][i],now)]=0; dfs2(e[now][i]); &#125;&#125;int n,m;int main()&#123; for(int o=1;;o++) &#123; n=read(),m=read(); if(n==0 and m==0) break; for(int i=0;i&lt;=n;i++) e[i].clear(),e2[i].clear(); for(int i=1;i&lt;=n;i++) e[i].reserve(4),e2[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; memset(vis,0,sizeof vis); memset(mstack,0,sizeof mstack); dfn_to=cnt=0; Tarjan(1,0); printf(&quot;%d\\n\\n&quot;,o); memset(vis,0,sizeof vis); for(int i=1;i&lt;=n;i++) dfs2(i); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;int(e[i].size());j++) if(belong[i]!=belong[e[i][j]] and e[i][j]!=0) printf(&quot;%d %d\\n&quot;,i,e[i][j]); printf(&quot;#\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"边双/点双","slug":"边双-点双","permalink":"http://www.goldenpotato.cn/categories/%E8%BE%B9%E5%8F%8C-%E7%82%B9%E5%8F%8C/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[USACO06JAN]冗余路径Redundant Paths","slug":"usaco06jan冗余路径redundant-paths","date":"2019-04-08T15:02:19.000Z","updated":"2019-04-08T15:02:19.000Z","comments":true,"path":"2019/04/08/usaco06jan冗余路径redundant-paths/","permalink":"http://www.goldenpotato.cn/2019/04/08/usaco06jan%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84redundant-paths/","excerpt":"","text":"题面 P2860 [USACO06JAN]冗余路径Redundant Paths Solution 首先，我们可以发现题目要求每一个点到其他所有点的路径不只有一条，这本质上就是要我们把这个图所有的桥都消除掉。 要消除掉桥，首先必须要把边双先缩起来。缩边双很简单：和求强连通分量一模一样，唯一要注意的是我们要多记录一个$fa$，防止我们求$low$的时候直接把$fa$算进来。 求完边双之后，我们会发现原图变成一个树的形式。想象一下：我们要把这个树上所有的单边去掉，我们只需要把叶子节点两两连起来即可。（注意，这里的叶子节点是广义的（即根也有可能是叶子节点）） 还有一个小细节：对于直接就是一个环的情况，我们要特判一下，直接输出0即可。 时间复杂度$O(n)$ 就酱，这题就被我们切掉啦︿(￣︶￣)︿ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//Luogu P2860 [USACO06JAN]冗余路径Redundant Paths//Apr,8th,2019//边双#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=5000+100;vector &lt;int&gt; e[N],e2[N];int n,m;int dfn[N],low[N],dfn_to,InStack[N],mstack[N],top,belong[N],cnt;bool vis[N];void Tarjan(int now,int father)&#123; vis[now]=InStack[now]=true; dfn[now]=low[now]=++dfn_to; mstack[++top]=now; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; Tarjan(e[now][i],now); low[now]=min(low[now],low[e[now][i]]); &#125; else if(e[now][i]!=father and InStack[e[now][i]]==true) low[now]=min(low[now],dfn[e[now][i]]); if(low[now]==dfn[now]) &#123; cnt++; while(mstack[top+1]!=now) InStack[mstack[top]]=false, belong[mstack[top--]]=cnt; &#125;&#125;int GetAns(int now,int father)&#123; int ans=0; for(int i=0;i&lt;int(e2[now].size());i++) if(e2[now][i]!=father) ans+=GetAns(e2[now][i],now); return max(1,ans);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; Tarjan(1,0); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;int(e[i].size());j++) if(belong[i]!=belong[e[i][j]]) e2[belong[i]].push_back(belong[e[i][j]]); int ans=GetAns(belong[1],belong[1])+(e2[belong[1]].size()==1); if(cnt==1)//特判只有一个环 ans=0; printf(&quot;%d&quot;,ans/2+ans%2); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"边双/点双","slug":"边双-点双","permalink":"http://www.goldenpotato.cn/categories/%E8%BE%B9%E5%8F%8C-%E7%82%B9%E5%8F%8C/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P3225 [HNOI2012]矿场搭建","slug":"luogu-p3225-hnoi2012矿场搭建","date":"2019-04-08T13:44:54.000Z","updated":"2019-04-08T13:44:54.000Z","comments":true,"path":"2019/04/08/luogu-p3225-hnoi2012矿场搭建/","permalink":"http://www.goldenpotato.cn/2019/04/08/luogu-p3225-hnoi2012%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/","excerpt":"","text":"题面 P3225 [HNOI2012]矿场搭建 Solution 这题比较妙。 首先，根据常识，如果一个点爆了，当且仅当它是割点的时候才会影响整个图的连通性。 因此，我们考虑把这道题往点双那方面想。 接下来我们思考这个问题：对于一个点双，我们什么时候需要在它这里面放置逃生通道： 如果与它相连的点双块只有一个：如果爆的是割点，则必须在当前块中的任意点建一个通道；如果爆的是普通点，则当前块则可以与别的块照样联通。 如果与它相连的点双块有两个以上：无论爆的是割点还是普通点，都不影响它里面的其他点到其他块去逃生。 综上，我们发现我们只需要在只与1个其他点双块连接的点双块防止逃生通道即可。我在这里暂时称这种块为“叶子点双”。 如下图：我们只需要在紫色的点双块中每一个都放置一个逃生通道即可。 因此，要放置的逃生通道的总数为“叶子点双”的个数，总方案为$\\prod (size[x]-1)$ （x为叶子点双）（由乘法原理可得）。 但是，我们要小心一个细节：就是我们在做Tarjan的时候，无论如何都会把1号节点认为是割点。但是，1号节点有可能并不是割点。1号节点有可能属于某一个点双块，而且这个点双块是有可能为叶子节点的，我们做的时候要小心判断一下。 接下来，实现的话就随便写就好。笔者写的时候脑袋有点犯二，就用了圆方树来实现 时间复杂度$O(\\sum n)$ 就酱，这道题就被我们切掉啦(～￣▽￣)～ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//Luogu P3225 [HNOI2012]矿场搭建//Apr,8th,2019//Tarjan求点双+圆方树#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=2*500+20;vector &lt;int&gt; e[N],e2[N];int n,m;int dfn[N],low[N],dfn_to,mstack[N],top,cnt,size[N];bool vis[N];void Tarjan(int now,int father)&#123; vis[now]=true; low[now]=dfn[now]=++dfn_to; mstack[++top]=now; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; Tarjan(e[now][i],now); low[now]=min(low[now],low[e[now][i]]); if(low[e[now][i]] &gt;= dfn[now]) &#123; e2[now].push_back(n+ ++cnt); size[cnt]=1; while(mstack[top+1]!=e[now][i]) e2[n+cnt].push_back(mstack[top--]), size[cnt]++; &#125; &#125; else if(e[now][i]!=father) low[now]=min(low[now],dfn[e[now][i]]);&#125;long long ans,ans2;int dfs(int now)//返回now的子树内的方点个数&#123; int t_cnt=(now&gt;n); for(int i=0;i&lt;int(e2[now].size());i++) t_cnt+=dfs(e2[now][i]); if(now&gt;n and t_cnt==1) ans2++,ans*=(size[now-n]-1); return t_cnt;&#125;bool Check()//判断1所在块是否为叶子块&#123; int x=e2[1][0],t_cnt=0; for(int i=0;i&lt;int(e2[x].size());i++) if(e2[e2[x][i]].size()!=0) t_cnt++; return t_cnt==1;&#125;int main()&#123; for(int o=1;;o++) &#123; m=read(); if(m==0) break; for(int i=1;i&lt;=500*2+5;i++) e[i].clear(),e2[i].clear(); dfn_to=cnt=0; memset(vis,0,sizeof vis); n=0; for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); n=max(max(n,s),t); &#125; Tarjan(1,0); ans=1,ans2=0; dfs(1); if(e2[1].size()==1 and Check()==true)//特殊处理1号节点 ans*=(size[e2[1][0]-n]-1), ans2++; if(cnt==1)//特判只有一个连通块的情况 ans=(n*(n-1))/2,ans2=2; printf(&quot;Case %d: %lld %lld\\n&quot;,o,ans2,ans); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"圆方树","slug":"圆方树","permalink":"http://www.goldenpotato.cn/categories/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"边双/点双","slug":"边双-点双","permalink":"http://www.goldenpotato.cn/categories/%E8%BE%B9%E5%8F%8C-%E7%82%B9%E5%8F%8C/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P4606] [SDOI2018]战略游戏","slug":"luogu-p4606-sdoi2018战略游戏","date":"2019-04-08T10:09:27.000Z","updated":"2019-04-08T10:09:27.000Z","comments":true,"path":"2019/04/08/luogu-p4606-sdoi2018战略游戏/","permalink":"http://www.goldenpotato.cn/2019/04/08/luogu-p4606-sdoi2018%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/","excerpt":"","text":"题面 P4606 [SDOI2018]战略游戏 Solution 圆方树上圆方果， 圆方树下你和我。 圆方树前建虚树， 欢乐多又多。 好吧，我们来说正题。 这题就比较强。根据常识，如果我们爆掉的点能影响这个图的连通性，那么，这个点一定是割点。 因此，我们要先对原图做Tarjan求点双。接下来，我们考虑用圆方树来解决一个问题。 我们先考虑暴力怎么做，我们先对原图求出圆方树。 接下来，我们发现，对答案有贡献的点一定是孩子有被选定的点的圆点，并且这个点的总共被选定的孩子数不等于总共被选定数（因为如果这个点被割掉了，其被选定的孩子一定会与其他点断开来，且方点代表一个点双，并不能割）。 因此，我们可以直接统计一下有多少个有贡献的点即可。 接下来，我们进一步观察数据，发现$\\sum S$非常小，因此考虑用虚树来解决这个问题。 我们对每个询问的点构建虚树。这时候，我们就要多计算边的贡献，考虑一条边的贡献，即为这条边上有多少个原点，随便转移一下就好了。 好个鬼啊，细节比较多，大家注意一下 时间复杂度$O(\\sum S \\cdot log n)$ 就酱，这题就被我们切掉啦ヾ(●´∀｀●) Code 数据生成器 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;const int N=10;const int M=15;bool vis[N+5];int main()&#123; srand(time(NULL)); freopen(&quot;4606.in&quot;,&quot;w&quot;,stdout); cout&lt;&lt;&quot;1\\n&quot;; int n=N,m=M; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; for(int i=2;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;max(rand()%i,1)&lt;&lt;endl; for(int i=n;i&lt;=m;i++) &#123; int s=rand()%n+1,t=rand()%n+1; cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; &#125; int q=N; cout&lt;&lt;endl&lt;&lt;q&lt;&lt;endl; for(int i=1;i&lt;=q;i++) &#123; int t=max(2,rand()%n+1); memset(vis,0,sizeof vis); cout&lt;&lt;t&lt;&lt;&quot; &quot;; for(int j=1;j&lt;=t;j++) &#123; int tmp=rand()%n+1; while(vis[tmp]==true) tmp=rand()%n+1; vis[tmp]=true; cout&lt;&lt;tmp&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160//Luogu P4606 [SDOI2018]战略游戏//Apr,8th,2019//圆方树+虚树#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=2*100000+100;vector &lt;int&gt; e[N],e2[N],e3[N];int n,m,q;int low[N],cnt,dfn_to,dfn[N],mstack[N],top;bool vis[N];void Tarjan(int now,int father)&#123; vis[now]=true; dfn[now]=low[now]=++dfn_to; mstack[++top]=now; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; Tarjan(e[now][i],now); low[now]=min(low[now],low[e[now][i]]); if(low[e[now][i]]&gt;=dfn[now]) &#123; e2[now].push_back(n+(++cnt)); while(mstack[top+1]!=e[now][i]) e2[n+cnt].push_back(mstack[top--]); &#125; &#125; else if(e[now][i]!=father) low[now]=min(low[now],dfn[e[now][i]]);&#125;int fa[N][21],depth[N],pre[N];void dfs(int now,int father)&#123; fa[now][0]=father,depth[now]=depth[father]+1; dfn[now]=++dfn_to; pre[now]=pre[father]+(now&lt;=n); for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;int(e2[now].size());i++) if(e2[now][i]!=father) dfs(e2[now][i],now);&#125;int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(depth[x]-(1&lt;&lt;i) &gt;= depth[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;bool cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;bool sp[N];int f[N];int GetSum(int x,int y) //(x,y)&#123; return pre[y]-pre[x]-(y&lt;=n);&#125;int dfs2(int now)&#123; f[now]=0; for(int i=0;i&lt;int(e3[now].size());i++) f[now]+=dfs2(e3[now][i])+GetSum(now,e3[now][i]); if(sp[now]==false and now&lt;=n and (now!=1 or e3[now].size()!=1)) f[now]++; if(now==1 and e3[now].size()==1 and sp[now]==false) f[now]-=GetSum(now,e3[now][0]); return f[now];&#125;int main()&#123; freopen(&quot;4606.in&quot;,&quot;r&quot;,stdin); freopen(&quot;4606.out&quot;,&quot;w&quot;,stdout); int T=read(); for(;T&gt;0;T--) &#123; n=read(),m=read(); for(int i=1;i&lt;=2*n;i++) e[i].clear(),e2[i].clear(),e3[i].clear(); memset(vis,0,sizeof vis); dfn_to=0; for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; Tarjan(1,1); dfn_to=0; dfs(1,1); q=read(); static int a[N],rec[N]; for(int i=1;i&lt;=q;i++) &#123; m=read(); for(int j=1;j&lt;=m;j++) a[j]=read(); sort(a+1,a+1+m,cmp); mstack[top=1]=1,cnt=0; for(int j=(a[1]==1?2:1);j&lt;=m;j++) &#123; while(LCA(mstack[top],a[j])!=mstack[top]) &#123; int lca=LCA(mstack[top],a[j]); if(depth[lca] &gt; depth[mstack[top-1]]) &#123; e3[lca].push_back(mstack[top]); rec[++cnt]=mstack[top],mstack[top]=lca; &#125; else &#123; e3[mstack[top-1]].push_back(mstack[top]); rec[++cnt]=mstack[top--]; &#125; &#125; mstack[++top]=a[j]; &#125; while(top&gt;1) &#123; e3[mstack[top-1]].push_back(mstack[top]); rec[++cnt]=mstack[top--]; &#125; rec[++cnt]=1; for(int i=1;i&lt;=m;i++) sp[a[i]]=true; printf(&quot;%d\\n&quot;,dfs2(1)); for(int i=1;i&lt;=cnt;i++) sp[rec[i]]=false,e3[rec[i]].clear(); &#125; &#125; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"圆方树","slug":"圆方树","permalink":"http://www.goldenpotato.cn/categories/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"缩点/强连通分量","slug":"缩点-强连通分量","permalink":"http://www.goldenpotato.cn/categories/%E7%BC%A9%E7%82%B9-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"虚树","slug":"虚树","permalink":"http://www.goldenpotato.cn/categories/%E8%99%9A%E6%A0%91/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P2617] Dynamic Rankings","slug":"luogu-p2617-dynamic-rankings","date":"2019-04-07T08:46:47.000Z","updated":"2019-04-07T08:46:47.000Z","comments":true,"path":"2019/04/07/luogu-p2617-dynamic-rankings/","permalink":"http://www.goldenpotato.cn/2019/04/07/luogu-p2617-dynamic-rankings/","excerpt":"","text":"题面 P2617 Dynamic Rankings Solution 这题需要一个比较妙的操作。 首先，我们阅读题面，发现题目要求我们处理区间K大带单点修改的问题。我们考虑用整体二分来解决这个问题。 总所周知，**整体二分中的修改只能以“添加”的形式进行，而不能以“覆盖”的方式进行。但这里，我们修改一个位置的数之后，新的数会把原来的数覆盖掉。**如果我们不能处理好这个问题，整体二分一定会错。 因此，我们考虑添加一个“删除”操作来解决这个问题。我们可以把这里的修改变为：删除原有的数+加入一个新的数。这样子，我们就把原来的“覆盖”问题转换为了“添加”问题。 接下来，我们的操作就很套路了。我们直接二分一个$mid$,把所有$ans&gt;mid$的询问和添加后的数$&gt;mid$的修改丢到右边，其他的丢到左边。对于删除操作，如果删除之前的数$&lt;=mid$，我们就把删除操作丢到左边，否则丢到右边。 （因为我们会在二分的时候计算右边对左边的贡献，如果改前的数$&lt;=mid$，有可能导致我们重复计算贡献，因此必须把这个删除操作丢到左边防止重复计算） 时间复杂度$O(nlogn^2)$ 就酱，这题就被我们切掉啦(～￣▽￣)～ Code 数据生成器 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;const int N=100000;const int MAX=2000;int main()&#123; freopen(&quot;2617.in&quot;,&quot;w&quot;,stdout); srand(time(NULL)); int n=N,m=N; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;rand()%MAX+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; int op=rand()%2; if(op==1) &#123; int r=rand()%n+1,l=rand()%r+1,k=rand()%(r-l+1)+1; cout&lt;&lt;&quot;Q &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;C &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%MAX+1&lt;&lt;endl; &#125; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151//Luogu P2617 Dynamic Rankings//Apr,7th,2019//整体二分妙题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int inf=0x3f3f3f3f;int a[N],n;struct BitTree&#123; int sum[N*400]; int lowbit(int x) &#123; return x&amp;(-x); &#125; void Add(int x,int w) &#123; int tmp=Query(x,x); if(tmp==1 and w==0) w=-1; if(tmp==1 and w==1) w=0; for(;x&lt;=n;x+=lowbit(x)) sum[x]+=w; &#125; int query(int x) &#123; int t_ans=0; for(;x&gt;=1;x-=lowbit(x)) t_ans+=sum[x]; return t_ans; &#125; int Query(int l,int r) &#123; return query(r)-query(l-1); &#125;&#125;bit;struct OP&#123; int l,r,x,no;&#125;op[N];struct OP2&#123; int l,r; vector &lt;OP&gt; op;&#125;;queue &lt;OP2&gt; dl;int m,q,ans[N];int main()&#123; freopen(&quot;2617.in&quot;,&quot;r&quot;,stdin); freopen(&quot;2617.out&quot;,&quot;w&quot;,stdout); int TIME=clock(); n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); char type[5]; for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%s&quot;,type+1); if(type[1]==&#x27;Q&#x27;) op[i].l=read(),op[i].r=read(),op[i].x=op[i].r-op[i].l+2-read(),op[i].no=++q; else op[i].l=read(),op[i].r=read(); &#125; OP2 now; now.l=1,now.r=inf; OP temp; for(int i=1;i&lt;=n;i++) temp.l=i,temp.r=a[i],temp.no=0, now.op.push_back(temp); for(int i=1;i&lt;=m;i++) &#123; temp.no=-1,temp.l=op[i].l; if(op[i].no==0) now.op.push_back(temp); now.op.push_back(op[i]); &#125; dl.push(now); while(dl.empty()==false) &#123; now=dl.front(); dl.pop(); if(now.op.size()==0) continue; if(now.l==now.r) &#123; for(int i=0;i&lt;int(now.op.size());i++) ans[now.op[i].no]=now.l; continue; &#125; int mid=(now.l+now.r)/2; OP2 L,R; for(int i=0;i&lt;int(now.op.size());i++) if(now.op[i].no==0) &#123; bit.Add(now.op[i].l,now.op[i].r&gt;mid); if(now.op[i].r&gt;mid) R.op.push_back(now.op[i]); else L.op.push_back(now.op[i]); &#125; else if(now.op[i].no==-1) &#123; if(bit.Query(now.op[i].l,now.op[i].l)==1) R.op.push_back(now.op[i]); else L.op.push_back(now.op[i]); bit.Add(now.op[i].l,0); &#125; else &#123; int tmp=bit.Query(now.op[i].l,now.op[i].r); if(tmp&gt;=now.op[i].x) R.op.push_back(now.op[i]); else &#123; now.op[i].x=now.op[i].x-tmp; L.op.push_back(now.op[i]); &#125; &#125; for(int i=now.op.size()-1;i&gt;=0;i--) if(now.op[i].no==0) bit.Add(now.op[i].l,0); L.l=now.l,L.r=mid; R.l=mid+1,R.r=now.r; dl.push(R); dl.push(L); &#125; for(int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,ans[i]); cerr&lt;&lt;clock()-TIME&lt;&lt;endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"整体二分","slug":"整体二分","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"手把手带你入门GUIDE","slug":"手把手带你入门guide","date":"2019-04-03T07:57:20.000Z","updated":"2019-04-03T07:57:20.000Z","comments":true,"path":"2019/04/03/手把手带你入门guide/","permalink":"http://www.goldenpotato.cn/2019/04/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8guide/","excerpt":"","text":"什么是GUIDE GUIDE(GAIT Universal IDE)是由北航GAIT研究组开发的、专门为NOI选手设计的轻型集成开发环境。GUIDE具有跨平台、操作简单、支持C/C++/Pascal三种语言和单文件编译调试等优点。经过近一年的试用和修改之后，GUIDE 1.0.1版目前正式发布。 ——www.noi.cn 换句话来说，GUIDE是一个NOI官方指定的，在NOI Linux系统上预装的一款pascal/c/c++ IDE(集成开发环境)。 GUIDE有什么优点 我们GUIDE有一点好，就是出了什么bug，用可视化gdb调试调得比什么人都快 首先，GUIDE作为一款IDE，高亮，代码补全，括号匹配什么的肯定是应有尽有。 但对于笔者来说，GUIDE最重要的功能莫过于它的可视化gdb调试，它可以方便地让我们定位bug的位置并解决问题。 其次，GUIDE设计在windows系统下非常简洁美观。 况且，我们平时用的IDE和考场上用的IDE一模一样,可以有效避免因为不习惯的问题造成的翻车，心态爆炸。 GUIDE的基本使用 GUIDE的安装 要使用GUIDE，显然，你必须要有一份GUIDE程序。考虑到读者们大多使用windows编程(以及我并不会用新版ubuntu装GUIDE)的问题，接下来的所有操作都在笔者的WINDOWS10系统下进行。如果有因系统不同而造成的报道上的偏差，请读者自行推广到其他的系统。 GUIDE可以到NOI官网下载 但是考虑到GUIDE对MINGW的版本要求比较特殊的问题，为了方便大家使用GUIDE，我为大家特意打包了一份： OFB（推荐） 度盘 提取码: bbvq 下载完压缩包并解压之后，文件夹内应有以下文件： 接下来，我们可以直接点开主程序GUIDE.exe 打开之后，它应该会让你选择gcc,g++,fpc的目录。**对于MinGW:**我们直接选定GUIDE/MinGW/bin这个文件夹即可；对于fpc，请自行安装目录下带有的fpc-2.2.2.i386-win32.exe。 为了让GUIDE的调试功能有效，请使用MinGW，如果您不需要gdb调试功能，可以选择MinGW_new 这样子，我们的安装工作基本上就告一段落了。 GUIDE的基本设置 俗话说得好，调好字体就是AC的一半。 因此，我们可以在编辑/选项/语法高亮显示/全部字体中选择一个好看的字体及大小。 接下来，我们也可以在这里设置自动补全及括号匹配相关的问题。调整为自己习惯的设定即可。 我们发现GUIDE主程序界面下还有编译结果及文件夹两个额外的文本框。这些都是可以任意拖动的。 我一般习惯关闭文件夹这个文本框，将编译结果框拖到左边来，因为这样子方便调试代码。 GUIDE的基本使用 搞完上述事情后，我们就可以正常使用GUIDE啦。 现在，我将以写P1706 全排列问题的事例来介绍如何使用GUIDE编辑，运行，调试一个程序。 首先，我们得创建一个新文件，左上角菜单文件/新文件或点击或CTRL+N，来创建一个新的代码文件。 接下来，我们必须先保存文件，这样GUIDE才知道要用什么语言的语法高亮。 按下CTRL+s或点击来保存文件 注意，这里我们设置文件名时一定要打上后缀名，如c语言应该命名为：xxx.c,c++: xxx.cpp,pascal: xxx.pas 接下来我们就可以在这个新文件里面打上我们的代码。 对于这道题，我们可以发现这题我们做一个全排列即可完成。 打完代码之后，你可以通过鼠标点击编译你的代码，也可以通过按下&quot;F7&quot;来编译。 在这里，我故意让程序有一点小问题无法通过编译。你可以通过双击编译结果中的某一个问题让你快速跳转到有问题的那一行。(截图并不能截到光标，大家意会一下光标在对应行即可) 在这里，我们发现我们漏写了一个分号，加上后就可以通过编译了。 接下来，我们可以通过鼠标点击运行代码，也可以按下CTRL+F5来运行。 我们输入样例： 注意到，和DEVC++类似，GUIDE是会自动帮你在末尾加上“按任意键继续”来方便你的观察的。 GUIDE的进一步使用 接下来的才是笔者最想介绍的地方：GUIDE的可视化gdb调试功能 如果您安装GUIDE时使用的是MinGW_new这个编译器，请在设置/重设编译器路径这里调整回MinGW以使用GUIDE的逐过程功能。（因为GUIDE并不资磁最新的编译器） 逐过程，顾名思义，我们可以按照我们的程序逐步逐步观察我们的代码的运行： 通过按下来进入gdb模式 我们发现，在调试模式下，在行号标旁边出现了一个小蓝箭头，表示当前程序运行到了第几行。 左边的编译信息框会自动切换到GDB信息框，同时，我们也可以通过点击小箭头以切换到不同的菜单夹并点击对应的按钮来进入对应的界面。 接下来，由笔者来介绍如何逐过程： 逐过程 顾名思义，就是按照一个一个过程来进行你的程序。对于函数，它将不会带领你进入函数，而是直接运行完这个函数后继续(比如说，我现在要执行cin函数，它将不会带领我进入iostream库中cin的对应位置，而是直接运行完这个函数继续下一行) 比如说，现在程序运行到了dfs这句话之前，如果按逐过程，则将直接执行完这个函数，然后进入下一行，而非把运行光标带到函数内部: 按下逐过程后，代码会执行到这一步：(即dfs函数完成之后的下一步) 逐语句 顾名思义，按照一个一个语句来执行你的程序。它会带领你的程序进入函数 例如说： 按下逐语句后： 跳出循环的功能我没用过，就不解释了。 运行到光标处就是字面意思，也不多做解释。 断点设置与运行到断点 我们可以通过按下F9来在光标行设置断点(断点以红心表示) 接下来，我们可以通过按下F5或 来让程序在断点处停下来(在此之前不能有别的中断事情，如别的断点，数据输入没有完成) 变量查看 我们在调试过程中，任何时刻都可以查看当前状态下每个变量的值，先点进变量查看栏 可以通过按下那个加号来查看某个名字的变量的值/函数运行结果。 也可以：先选定一段字符（变量名），右键：“添加到变量查看” 效果如下：(对于长度大于500的数组，我们还能选定显示起始位置和终止位置) 对于结构体，我们还可以展开来看到所有的元素 堆栈信息查看 我们还可以查看我们程序的堆栈情况： 有了以上调试功能，相信读者一定能如虎添翼，更快的DE出自己程序的BUG，AC掉各种各样的神题。 Tips 1.要让GUIDE的可视化调试能正常运行，必须使用5.1.4版本的(远古版本)的MinGW。但有时候，我们需要一些先进的编译器，可以暂时放弃调试，在编辑/重设编译器路径这里暂时设置为MinGW_new。这个时候，虽然不能调试，但是其他功能还是可以正常运行的。 2.请不要在展开巨大长度的数组时按下一步，这样操作很有可能导致GUIDE崩溃。 3.我们可以使用一切文本编辑常用快捷键CTRL F、S、C、V、Z、Y等 4.我们可以通过右键文件名来设置编译选项 后记 希望大家能用好GUIDE，祝大家在OI赛事中取的理想的成绩！ 以及别用DEVCPP了，来用GUIDE吧，DEVCPP的调试功能是在是emmmmmm 当然，各位julao也可以使用各种各样更优秀的编辑器：如Emacas，Vim等。但是考虑到其陡峭的学习曲线，如果您不是julao的话，GUIDE一样能称为您的解题利器。","categories":[{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"[Luogu P3233] [HNOI2014]世界树","slug":"luogu-p3233-hnoi2014世界树","date":"2019-04-01T01:09:42.000Z","updated":"2019-04-01T01:09:42.000Z","comments":true,"path":"2019/04/01/luogu-p3233-hnoi2014世界树/","permalink":"http://www.goldenpotato.cn/2019/04/01/luogu-p3233-hnoi2014%E4%B8%96%E7%95%8C%E6%A0%91/","excerpt":"","text":"题面 P3233 [HNOI2014]世界树 Solution 这是一道虚树妙题。 我们不妨先考虑一下每一次$O(n)$计算的暴力怎么做。 $O(n\\cdot m)$的暴力肥肠简单，我们只需要做两遍dfs。考虑设$f[i]$表示离$i$最近的聚居地是什么，$MIN[i]$表示$i$到最近的聚居地的距离。我们第一遍dfs先找出$i$到它子树内的聚居地的最小距离，之后再做一遍dfs来找$i$往祖先方向后头走能走到的最近聚居地的距离即可。 观察数据范围后发现，$\\sum m&lt;=300000$，因此考虑使用虚树。 建出来虚树之后，显然对于在虚树上的点，我们还是能直接暴力做，问题是怎么处理非虚树上的点。 我们会发现，**我们虚树上的一条边在原树种对应一条链(包括链上的子树)。**我们会发现，这条链上的点上一定是上半部分的最近距离在上面那个点，下半部分的最近距离在下面那个点。因此，我们考虑用倍增的思想来找出这个“分界点”，找到后计算一下上下分别贡献即可。 这里有个小细节，我们是在原树上做倍增的，因此我们倍增过程中不应该使用跟DP有关的量，这里理论上我们只需要使用上端点与下端点的$f,MIN$，以及每个点的深度，$fa$即可实现这个倍增。 时间复杂度$O(mlogn)$ 就酱，我们就把这题切掉啦(*≧▽≦) Code 本题细节较多，请各位dalao小心慢行 直接两行泪就完事了 数据生成器 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;cstring&gt;using namespace std;const int N=50;bool used[N+5];int main()&#123; srand(time(NULL)); freopen(&quot;3233.in&quot;,&quot;w&quot;,stdout); int n=N; cout&lt;&lt;n&lt;&lt;endl; for(int i=2;i&lt;=n;i++) cout&lt;&lt;max(rand()%i,1)&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;endl; for(int i=1;i&lt;=n;i++) &#123; memset(used,0,sizeof used); int m=rand()%n+1; cout&lt;&lt;m&lt;&lt;endl; for(int j=1;j&lt;=m;j++) &#123; int t=rand()%n+1; while(used[t]==true) t=rand()%n+1; used[t]=true; cout&lt;&lt;t&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//Luogu P3233 [HNOI2014]世界树//Apr,1st,2019//虚树+DP+倍增神题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=300000+1000;vector &lt;int&gt; e[N],e2[N];int n,q,a[N],b[N];int dfn[N],dfn_to,depth[N],fa[N][21],size[N];void dfs(int now)&#123; dfn[now]=++dfn_to; size[now]=1; for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;int(e[now].size());i++) if(dfn[e[now][i]]==0) &#123; depth[e[now][i]]=depth[now]+1; fa[e[now][i]][0]=now; dfs(e[now][i]); size[now]+=size[e[now][i]]; &#125;&#125;int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(depth[x]-(1&lt;&lt;i)&gt;=depth[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int cmp(int x,int y)&#123; return dfn[x]&lt;dfn[y];&#125;bool sp[N];int MIN[N],f[N],ans[N];inline int GetDis(int x,int y)&#123; if(depth[x]&lt;depth[y]) swap(x,y); return depth[x]-depth[y];&#125;void dfs2(int now)&#123; if(sp[now]==true) f[now]=now,MIN[now]=0; for(int i=0;i&lt;int(e2[now].size());i++) &#123; dfs2(e2[now][i]); if(MIN[e2[now][i]]+GetDis(e2[now][i],now) &lt; MIN[now] or (MIN[e2[now][i]]+GetDis(e2[now][i],now)==MIN[now] and f[now]&gt;f[e2[now][i]])) f[now]=f[e2[now][i]],MIN[now]=MIN[e2[now][i]]+GetDis(e2[now][i],now); &#125;&#125;void dfs3(int now,int fa) &#123; if(fa!=0) &#123; if(MIN[fa]+GetDis(fa,now) &lt; MIN[now] or (MIN[fa]+GetDis(fa,now)==MIN[now] and f[now]&gt;f[fa])) f[now]=f[fa],MIN[now]=MIN[fa]+GetDis(fa,now); &#125; ans[f[now]]++; for(int i=0;i&lt;int(e2[now].size());i++) dfs3(e2[now][i],now);&#125;void GetSum(int x,int y,int &amp;sum_x,int &amp;sum_y)&#123; bool IsSwap=false; if(depth[x]&lt;depth[y]) IsSwap=true,swap(x,y); int sx=x,dis_x=MIN[x]; for(int i=20;i&gt;=0;i--) if(dis_x+(1&lt;&lt;i) &lt; MIN[y]+depth[x]-depth[y]-(1&lt;&lt;i)) f[fa[x][i]]=f[x], x=fa[x][i],dis_x+=(1&lt;&lt;i); if(dis_x+1==MIN[y]+depth[x]-depth[y]-1 and f[x]&lt;f[y]) x=fa[x][0]; sum_x=size[x]-size[sx]; for(int i=20;i&gt;=0;i--) if(depth[sx]-(1&lt;&lt;i)&gt;depth[y]) sx=fa[sx][i]; sum_y=size[sx]-size[x]; if(IsSwap==true) swap(sum_x,sum_y);&#125;void dfs4(int now)&#123; int tmp=size[now]-1; for(int i=0;i&lt;int(e2[now].size());i++) &#123; int sum1,sum2; GetSum(now,e2[now][i],sum1,sum2); ans[f[now]]+=sum1,ans[f[e2[now][i]]]+=sum2; tmp-=(size[e2[now][i]]+sum1+sum2); dfs4(e2[now][i]); &#125; ans[f[now]]+=tmp;&#125;int main()&#123; freopen(&quot;3233.in&quot;,&quot;r&quot;,stdin); freopen(&quot;3233.out&quot;,&quot;w&quot;,stdout); n=read(); for(int i=1;i&lt;n;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; fa[1][0]=1; dfs(1); q=read(); for(int i=1;i&lt;=q;i++) &#123; int m=read(); for(int j=1;j&lt;=m;j++) b[j]=a[j]=read(); sort(a+1,a+1+m,cmp); static int mstack[N],top,rec[N],cnt; cnt=0; mstack[top=1]=1; for(int j=(a[1]==1?2:1);j&lt;=m;j++) &#123; while(LCA(mstack[top],a[j])!=mstack[top]) &#123; int lca=LCA(mstack[top],a[j]); if(depth[lca]&gt;depth[mstack[top-1]]) &#123; e2[lca].push_back(mstack[top]); rec[++cnt]=mstack[top],mstack[top]=lca; &#125; else &#123; e2[mstack[top-1]].push_back(mstack[top]); rec[++cnt]=mstack[top--]; &#125; &#125; mstack[++top]=a[j]; &#125; while(top&gt;1) &#123; e2[mstack[top-1]].push_back(mstack[top]); rec[++cnt]=mstack[top--]; &#125; rec[++cnt]=1; for(int j=1;j&lt;=m;j++) sp[a[j]]=true; for(int j=1;j&lt;=cnt;j++) MIN[rec[j]]=0x3f3f3f3f,ans[rec[j]]=0; dfs2(1); dfs3(1,0); dfs4(1); for(int j=1;j&lt;=m;j++) printf(&quot;%d &quot;,ans[b[j]]); printf(&quot;\\n&quot;); for(int j=1;j&lt;=m;j++) sp[a[j]]=false; for(int j=1;j&lt;=cnt;j++) e2[rec[j]].clear(),ans[rec[j]]=0; &#125; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%BD%A2DP/"},{"name":"虚树","slug":"虚树","permalink":"http://www.goldenpotato.cn/categories/%E8%99%9A%E6%A0%91/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P4297] [NOI2006]网络收费","slug":"luogu-p4297-noi2006网络收费","date":"2019-03-29T00:03:37.000Z","updated":"2019-03-29T00:03:37.000Z","comments":true,"path":"2019/03/29/luogu-p4297-noi2006网络收费/","permalink":"http://www.goldenpotato.cn/2019/03/29/luogu-p4297-noi2006%E7%BD%91%E7%BB%9C%E6%94%B6%E8%B4%B9/","excerpt":"","text":"题面 P4297 [NOI2006]网络收费 Solution 这题喵啊。 首先，我们会发现统计两个点互相的贡献是一个极其困难的问题。 但是，仔细观察那张收费表格后会发现，我们可以重新定义一下这个收费：我们假设路由器节点的颜色为叶子中数目较多的颜色，当一个叶子结点颜色与路由器节点颜色相同的时候不收钱，否则收一份钱。我们可以惊讶的发现，这样做之后我们的新收费做法就与原来题目要求的重合了，而且贡献由点对转到了点上。 接下来，我们就可以统计每个叶子节点对每个路由器产生的贡献了。**我们设$F[i][j]$表示第$i$个叶子节点在LCA为$j$情况下产生的贡献。**这个非常好搞，我们只需要枚举点对+计算LCA即可，复杂度$O(n^2logn)$ 我们会发现一个问题，一个叶子节点的贡献值与它到根路径上所有的路由器的颜色息息相关。因此，我们传统的基于子树的树形DP做法已经行不通了，我们现在需要一个基于某个点到根路径的DP做法。 考虑：设$f[i][j][k]$表示目前填到了第$i$个点，它到根的路径一路上的颜色为$j$(状压形式表现),它的孩子(叶子节点)要填$k$个颜色B。 转移非常简单，对于路由器节点，我们只需要像背包一样枚举左右孩子分别分配多少个颜色B即可；对于叶子节点，我们只需要直接一路算上去它的贡献即可。 但是我们会发现一个问题，这样子我们直接设的空间复杂度是$O(2^{3n})$的，并开不下。 我们观察后发现，对于任何一个节点，假设它的深度为$k$,那么，它的叶子节点最多有$2^{(n-k)}$个，它到父亲的距离的情况最多有$2^k$种。因此，我们发现这两位的状态可以直接压在一起（即放到一起存储，需要时再分开），空间复杂度就可以优化至$O(2^{2n})$,可以通过这一题。 时间复杂度$O(2^{2n}\\cdot n)$ 就酱，这题就被我们切掉啦=￣ω￣= Code 数据生成器 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;const int N=4;const int MAX=5000;int main()&#123; srand(time(NULL)); freopen(&quot;4297.in&quot;,&quot;w&quot;,stdout); int n=N,m=1&lt;&lt;n; cout&lt;&lt;n&lt;&lt;endl; for(int i=1;i&lt;=m;i++) cout&lt;&lt;rand()%2&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(int i=1;i&lt;=m;i++) cout&lt;&lt;rand()%MAX+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; for(int j=i+1;j&lt;=m;j++) cout&lt;&lt;rand()%MAX+1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Luogu P4297 [NOI2006]网络收费//Mar,28th,2019//树形DP+状压DP妙题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=2100;const long long inf=0x3f3f3f3f3f3f3f3fll;int n,m,a[N],c[N],w[N][N];long long F[N][N],depth[N],fa[N][21];//F[i][j]:i在LCA=j的时候的贡献void dfs(int now)&#123; for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; if(now&lt;(1&lt;&lt;n)) &#123; fa[now*2][0]=now,depth[now*2]=depth[now]+1,dfs(now*2); fa[now*2+1][0]=now,depth[now*2+1]=depth[now]+1,dfs(now*2+1); &#125;&#125;int LCA(int x,int y)&#123; if(depth[y]&gt;depth[x]) swap(x,y); for(int i=20;i&gt;=0;i--) if(depth[x]-(1&lt;&lt;i)&gt;=depth[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;long long f[N][N*2];long long dfs2(int now,int K)&#123; if(f[now][K]!=0) return f[now][K]; int c_now=0,cnt_B=K/(1&lt;&lt;depth[now]),cnt_A=(1&lt;&lt;(n-depth[now]))-cnt_B; if(cnt_B&lt;0 or cnt_A&lt;0) return f[now][K]=inf; if(cnt_B&gt;cnt_A) c_now=1; if(now&gt;=(1&lt;&lt;n)) &#123; int tmp=K%(1&lt;&lt;depth[now]),t_now=now/2; for(;t_now&gt;0;t_now/=2,tmp/=2) f[now][K]+=(c_now!=(tmp%2))*F[now][t_now]; f[now][K]+=c[now]*(a[now]!=c_now); return f[now][K]; &#125; long long t_ans=inf; for(int i=0;i&lt;=cnt_B;i++) &#123; long long L=dfs2(now*2,((K%(1&lt;&lt;depth[now]))&lt;&lt;1)+c_now+i*(1&lt;&lt;depth[now*2])); long long R=dfs2(now*2+1,((K%(1&lt;&lt;depth[now]))&lt;&lt;1)+c_now+(cnt_B-i)*(1&lt;&lt;depth[now*2+1])); t_ans=min(t_ans,L+R); &#125; return f[now][K]=t_ans;&#125;int main()&#123; n=read(); m=(1&lt;&lt;(n+1))-1; for(int i=(1&lt;&lt;n);i&lt;=m;i++) a[i]=read(); for(int i=(1&lt;&lt;n);i&lt;=m;i++) c[i]=read(); for(int i=(1&lt;&lt;n);i&lt;=m;i++) for(int j=i+1;j&lt;=m;j++) w[i][j]=w[j][i]=read(); dfs(1); for(int i=(1&lt;&lt;n);i&lt;=m;i++) for(int j=i+1;j&lt;=m;j++) F[i][LCA(i,j)]+=w[i][j], F[j][LCA(i,j)]+=w[i][j]; long long ans=inf; for(int i=0;i&lt;=(1&lt;&lt;n);i++) ans=min(ans,dfs2(1,i)); printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://www.goldenpotato.cn/categories/%E7%8A%B6%E5%8E%8BDP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%BD%A2DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P4438] [HNOI/AHOI2018]道路","slug":"luogu-p4438-hnoi-ahoi2018道路","date":"2019-03-28T07:28:09.000Z","updated":"2019-03-28T07:28:09.000Z","comments":true,"path":"2019/03/28/luogu-p4438-hnoi-ahoi2018道路/","permalink":"http://www.goldenpotato.cn/2019/03/28/luogu-p4438-hnoi-ahoi2018%E9%81%93%E8%B7%AF/","excerpt":"","text":"题面 4438 [HNOI/AHOI2018]道路 Solution 这是一道树形DP妙题。 平时，我们设计树形DP的状态一般都是以子树为基础来设计的。很不幸的是，这题因为那个蜜汁柿子无法化简，导致了极其严重的后效性。因此，我们这里并不能以子树为基础来设计状态了。 这题妙就妙在这个状态设计。这题我们考虑以链为基础来设计状态。 设$f[i][j][k]$表示从根节点到达第$i$个点，一路上经过了$j$条没有修过的公路及$k$条没有修过的铁路，把它的孩子全部连同到根所需的最小代价。 这样一来，我们惊讶的发现这样设就没有后效性问题，因为链的状态已经被我们包含在DP的状态里了。 转移非常简单，我们只需要讨论一下是这个点是修铁路还是公路就好。 即：$f[i][j][k]=min(f[lson][j][k]+f[rson][j][k+1],f[lson][j+1][k],f[rson][j][k])$ 但是这样做还有一个问题，就是我们的空间复杂度是$O(n\\cdot40\\cdot40)$的，开不下。 仔细观察后可以发现我们上面开辣么大的数组，很多地方是用不到的。因此，我们可以考虑只记录一个映射，然后把值记到一个统一的一维数组里面去。 时间复杂度$O(n\\cdot 40 \\cdot 40)$ 就酱，这题就被我们切掉啦(～￣▽￣)～ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Luogu P4438 [HNOI/AHOI2018]道路//Mar,27th,2019//你从未见过的船新树形DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=20000*2+200;const int M=40+3;const long long inf=0x3f3f3f3f3f3f3f3fll;int f[N][M][M],a[N],b[N],c[N];long long ans[20000000];int n,s[N],t[N],to;long long dfs(int now,long long cnt_s,long long cnt_t)&#123; if(f[now][cnt_s][cnt_t]!=0) return ans[f[now][cnt_s][cnt_t]]; f[now][cnt_s][cnt_t]=++to; if(now&gt;=n) return ans[f[now][cnt_s][cnt_t]]=c[now]*(a[now]+cnt_s)*(b[now]+cnt_t); long long t_ans=inf; t_ans=dfs(s[now],cnt_s,cnt_t)+dfs(t[now],cnt_s,cnt_t+1); t_ans=min(t_ans,dfs(s[now],cnt_s+1,cnt_t)+dfs(t[now],cnt_s,cnt_t)); return ans[f[now][cnt_s][cnt_t]]=t_ans;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; s[i]=read(),t[i]=read(); if(s[i]&lt;0) s[i]=-s[i]+n-1; if(t[i]&lt;0) t[i]=-t[i]+n-1; &#125; for(int i=1;i&lt;=n;i++) a[i+n-1]=read(),b[i+n-1]=read(),c[i+n-1]=read(); //int tim=clock(); printf(&quot;%lld&quot;,dfs(1,0,0)); //cerr&lt;&lt;endl&lt;&lt;clock()-tim; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%BD%A2DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P3332][ZJOI2013]K大数查询","slug":"luogu-p3332zjoi2013k大数查询","date":"2019-03-27T07:55:12.000Z","updated":"2019-03-27T07:55:12.000Z","comments":true,"path":"2019/03/27/luogu-p3332zjoi2013k大数查询/","permalink":"http://www.goldenpotato.cn/2019/03/27/luogu-p3332zjoi2013k%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"题面 P3332 [ZJOI2013]K大数查询 Solution 这是一道不辣么模板的整体二分题。 首先，我们先来假设一下只有一个询问应该怎么搞。 考虑这样做：我们先二分一个答案，修改中，如果所要修改的数大于mid，则在这段区间中每个数加上1。否则什么都不做。这样一来，最后我们只需要看一下询问的区间的区间和是否大于$K$即可。 接下来，我们考虑如何把所有询问一起来二分。 同样还是二分一个答案，把所有答案大于mid的询问丢到右边，其余丢到左边即可。 接下来，我们可以显然发现对于右边的区间，所有修改$&lt;=mid$的修改都是没有意义的。因此，我们考虑把所有$&lt;=mid$的修改放在右边，其余的放在左边。显然，对于左边所有的询问，$&gt;=mid$的修改一定会对左边造成影响，因此还要把所有在左边的询问减上对应的值（在这个询问之前所有的操作对它产生的1的数量）。 对于询问和修改的顺序问题：我们分别保证询问与修改按照时间有序，用两个指针分开处理，每次询问之前把在它之前的修改全部做了即可。这样就可以保证时间合法。 时间复杂度$O(nlog^2n)$ 就酱，我们又切掉一道题啦(ﾉ≧∀≦)ﾉ Code 数据生成器 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;const int N=500;const int NUM=1000;int cnt[N+5];int main()&#123; srand(time(NULL)); freopen(&quot;3332.in&quot;,&quot;w&quot;,stdout); int n=N,m=N; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=m;i++) &#123; int op=rand()%2,a=rand()%n+1,b=rand()%n+1,c=rand()%NUM+1; if(a&gt;b) swap(a,b); if(op==1) &#123; cout&lt;&lt;op&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl; for(int j=a;j&lt;=b;j++) cnt[j]++; &#125; else &#123; int mtot=0; for(int j=a;j&lt;=b;j++) mtot+=cnt[j]; if(mtot==0) &#123; i--; continue; &#125; c=rand()%mtot+1; cout&lt;&lt;&quot;2&quot;&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl; &#125; &#125; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//Luogu P3332 [ZJOI2013]K大数查询 //Mar,27th,2019//整体二分+线段树#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=50000+100;struct SegmentTree&#123; #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) #define mid ((now_l+now_r)&gt;&gt;1) long long sum[N&lt;&lt;2]; int lazy[N&lt;&lt;2]; inline void update(int now) &#123; sum[now]=sum[lson]+sum[rson]; &#125; inline void pushdown(int now,int now_l,int now_r) &#123; if(now_l!=now_r) &#123; sum[lson]+=lazy[now]*(mid-now_l+1),sum[rson]+=lazy[now]*(now_r-mid); lazy[lson]+=lazy[now],lazy[rson]+=lazy[now]; &#125; lazy[now]=0; &#125; void Change(int l,int r,int w,int now,int now_l,int now_r) &#123; pushdown(now,now_l,now_r); if(now_l&gt;=l and now_r&lt;=r) &#123; lazy[now]=w,sum[now]+=1ll*w*(now_r-now_l+1); return; &#125; if(l&lt;=mid) Change(l,r,w,lson,now_l,mid); if(r&gt;mid) Change(l,r,w,rson,mid+1,now_r); update(now); &#125; long long Query(int l,int r,int now,int now_l,int now_r) &#123; pushdown(now,now_l,now_r); if(now_l&gt;=l and now_r&lt;=r) return sum[now]; long long t_ans=0; if(l&lt;=mid) t_ans+=Query(l,r,lson,now_l,mid); if(r&gt;mid) t_ans+=Query(l,r,rson,mid+1,now_r); return t_ans; &#125; #undef lson #undef rson #undef mid&#125;sgt;struct OP&#123; int l,r,no; long long w;&#125;op1[N],op2[N];//op1:询问，op2:修改struct DL&#123; int l,r; vector &lt;OP&gt; op,qur;&#125;mqueue[2*N];int n,m,q,p,K=2*N-20;//q:询问，p:修改int ans[N];int main()&#123; freopen(&quot;3332.in&quot;,&quot;r&quot;,stdin); freopen(&quot;3332.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int op=read(); if(op==1) op2[++p].l=read(),op2[p].r=read(),op2[p].w=read(),op2[p].no=i; else op1[++q].l=read(),op1[q].r=read(),op1[q].w=read(),op1[q].no=i; &#125; int front=0,tail=0; mqueue[tail].l=-N,mqueue[tail].r=N; for(int i=1;i&lt;=p;i++) mqueue[tail].op.push_back(op2[i]); for(int i=1;i&lt;=q;i++) mqueue[tail].qur.push_back(op1[i]); tail++; memset(ans,0x3f,sizeof ans); while(front!=tail) &#123; //cerr&lt;&lt;front&lt;&lt;&quot; &quot;&lt;&lt;tail&lt;&lt;&quot; &quot;&lt;&lt;mqueue[front].l&lt;&lt;&quot; &quot;&lt;&lt;mqueue[front].r&lt;&lt;endl; if(mqueue[front].l==mqueue[front].r) &#123; for(int i=0;i&lt;int(mqueue[front].qur.size());i++) ans[mqueue[front].qur[i].no]=mqueue[front].l; &#125; else if(mqueue[front].qur.size()&gt;0) &#123; int mid=int(floor((mqueue[front].l+mqueue[front].r)/2.0)),T=0; DL L,R; for(int i=0;i&lt;int(mqueue[front].qur.size());i++) &#123; for(;T&lt;int(mqueue[front].op.size()) and mqueue[front].qur[i].no&gt;mqueue[front].op[T].no;T++) &#123; sgt.Change(mqueue[front].op[T].l,mqueue[front].op[T].r,mqueue[front].op[T].w&gt;mid,1,1,n); if(mqueue[front].op[T].w&gt;mid) R.op.push_back(mqueue[front].op[T]); else L.op.push_back(mqueue[front].op[T]); &#125; long long t=sgt.Query(mqueue[front].qur[i].l,mqueue[front].qur[i].r,1,1,n); if(t&gt;=mqueue[front].qur[i].w) R.qur.push_back(mqueue[front].qur[i]); else &#123; mqueue[front].qur[i].w-=t; L.qur.push_back(mqueue[front].qur[i]); &#125; &#125; for(int i=0;i&lt;T;i++) sgt.Change(mqueue[front].op[i].l,mqueue[front].op[i].r,-(mqueue[front].op[i].w&gt;mid),1,1,n); L.l=mqueue[front].l,L.r=mid; R.l=mid+1,R.r=mqueue[front].r; mqueue[tail]=L,tail=(tail+1)%K; mqueue[tail]=R,tail=(tail+1)%K; &#125; front=(front+1)%K; &#125; for(int i=1;i&lt;=m;i++) if(ans[i]!=0x3f3f3f3f) printf(&quot;%d\\n&quot;,ans[i]); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"整体二分","slug":"整体二分","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P3527] [POI2011]MET-Meteors","slug":"luogu-p3527-poi2011met-meteors","date":"2019-03-27T07:38:06.000Z","updated":"2019-03-27T07:38:06.000Z","comments":true,"path":"2019/03/27/luogu-p3527-poi2011met-meteors/","permalink":"http://www.goldenpotato.cn/2019/03/27/luogu-p3527-poi2011met-meteors/","excerpt":"","text":"题面 P3527 [POI2011]MET-Meteors Solution 我是一直奉行坚决不写树状数组只写线段树理论的，直到这题… 这题是一道整体二分的模板题。 首先，我们考虑只有一个国家的情况。这不SB问题么 我们可以二分一个答案，然后我们用线段树暴力模拟，暴力Check,复杂度$O(mlogn)$。 显然，如果我们每一个国家都这么搞一轮，复杂度达到了惊人的$O(n\\cdot m logn)$，这显然是要T飞的。 因此，我们就得请出伟大的整体二分了。整体二分，顾名思义，就是把所有询问一起二分答案。 考虑这样做，一开始，所有询问的答案均在$1,m+1$这个范围内(+1是为了方便判断不可行的情况)。接下来，我们二分一个$mid$，然后把所有答案$&lt;=mid$的询问丢到$1,mid$区间，把所有在mid时间内不能完成的询问丢到右区间。 怎么判断一个询问是否能在mid时间内完成呢？暴力啊。我们直接用线段树暴力做个mid次修改，然后再暴力看每个国家是否满足即可。 接下来，我们只需要把这个东西递归下去做，直到区间长度为$1$为止。 什么你说，这玩意复杂度很大？的确很大，$O(nlog^2n)$呢。 怎么证呢？显然，我们发现这个递归最多log层，每层我们会把所有的修改操作都会做一遍，因此总复杂度两个log。 再给一个参考数据，30w数据下，2个log算出来的东西接近两个亿。好了，我想你知道了要写什么数据结构了… 啥？所以说你还是义无反馈的写了线段树？来试试在这里交吧,可以检验你的程序的正确性（以及究竟要跑个多久）。 就酱，我们就把这题给切掉啦(～￣▽￣)～ 你很有可能被卡常及卡空间，当然，这就是后话了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//Luogu P3527 [POI2011]MET-Meteors//Mar,27th,2019//整体二分+树状数组#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;using namespace std;int read()&#123; int x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=300000+100;const int inf=0x3f3f3f3f;int n,m,K,ans[N],w[N];//w[i]第i个国家需要多少个陨石struct BIT&#123; long long t[N&lt;&lt;2]; inline int lowbit(int &amp;x)&#123;return x&amp;(-x);&#125; void Init() &#123; memset(t,0,sizeof t); &#125; long long Query(int x) &#123; long long sum=0; while(x&gt;0) &#123; sum+=t[x]; x-=lowbit(x); &#125; return sum; &#125; void update(int x,int dlt) &#123; while(x&lt;=m) &#123; t[x]+=dlt; x+=lowbit(x); &#125; &#125; void Change(int l,int r,int w) &#123; update(r+1,-w); update(l,w); &#125;&#125;bit;struct OP&#123; int l,r,w;&#125;op[N];vector &lt;int&gt; a[N];struct DL&#123; int l,r; vector &lt;int&gt; c;&#125;mqueue[N+5000];int main()&#123; //int t=clock(); //freopen(&quot;3527.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;3527.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[read()].push_back(i); for(int i=1;i&lt;=n;i++) w[i]=read(); K=read(); for(int i=1;i&lt;=K;i++) op[i].l=read(),op[i].r=read(),op[i].w=read(); int front=0,tail=0,T=1;//T:当前执行到了T时刻 mqueue[tail].l=1,mqueue[tail].r=K+1; for(int i=1;i&lt;=n;i++) mqueue[tail].c.push_back(i); tail++; while(tail!=front) &#123; if(mqueue[front].l==mqueue[front].r) &#123; for(int i=0;i&lt;int(mqueue[front].c.size());i++) ans[mqueue[front].c[i]]=mqueue[front].l; front=(front+1)%(K+5000); continue; &#125; int mid=(mqueue[front].l+mqueue[front].r)/2; if(T&gt;mid) T=1,bit.Init(); for(;T&lt;=mid;T++) if(op[T].l&lt;=op[T].r) bit.Change(op[T].l,op[T].r,op[T].w); else bit.Change(op[T].l,m,op[T].w), bit.Change(1,op[T].r,op[T].w); vector &lt;int&gt; l,r; for(int i=0;i&lt;int(mqueue[front].c.size());i++) &#123; long long t_ans=0,now=mqueue[front].c[i]; for(int j=0;j&lt;int(a[now].size());j++) &#123; t_ans+=bit.Query(a[now][j]); if(t_ans&gt;inf) break; &#125; if(t_ans&gt;=w[now]) l.push_back(now); else r.push_back(now); &#125; mqueue[tail].l=mqueue[front].l,mqueue[tail].r=mid,mqueue[tail++].c=l; tail%=(K+5000); mqueue[tail].l=mid+1,mqueue[tail].r=mqueue[front].r,mqueue[tail++].c=r; tail%=(K+5000); front=(front+1)%(K+5000); &#125; for(int i=1;i&lt;=n;i++) if(ans[i]==K+1) printf(&quot;NIE\\n&quot;); else printf(&quot;%d\\n&quot;,ans[i]); //cerr&lt;&lt;clock()-t&lt;&lt;endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"整体二分","slug":"整体二分","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P3810] 【模板】三维偏序（陌上花开）","slug":"luogu-p3810-【模板】三维偏序（陌上花开）","date":"2019-03-27T07:11:54.000Z","updated":"2019-03-27T07:11:54.000Z","comments":true,"path":"2019/03/27/luogu-p3810-【模板】三维偏序（陌上花开）/","permalink":"http://www.goldenpotato.cn/2019/03/27/luogu-p3810-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%EF%BC%88%E9%99%8C%E4%B8%8A%E8%8A%B1%E5%BC%80%EF%BC%89/","excerpt":"","text":"题面 P3810 【模板】三维偏序（陌上花开） Solution 这是一道CDQ分治的模板题。 题目要我们求的是$(a,b,c)$这样的三维“顺序对”的数量。 考虑我们把所有的数按照以$a$为第一关键字，以$b$为第二关键字，以$c$为第三关键字来排序。 这样子，我们就可以保证有可能与某个数形成“顺序对”的数一定在它的左边。 我们都知道，归并排序能用来求逆序对的数量，在这里，也能用类似的方法来求“顺序对”的数量。 接下来我们考虑对这个排好序的序列做以$b$为关键字的类似于归并排序的操作。 这里我们要排序的是$[1,n]$这一整个序列，我们要递归下去做，假设我们现在已经求出了$[1,mid]$与$[mid+1,n]$这两个区间内部的“顺序对”的数量，现在我们考虑求出跨越两个区间的顺序对。因为我们归并排序前已经按照$a$排序过了，所以这里有且只有可能右边块的数会与左边块的数会形成“顺序对”。 接下来，我们考虑维护左右两个块两个指针，**保证右边块当前看的数的$b$比左边指针扫到的所有的数的$b$都大。**这时候，**我们只需要找到左边扫到的数的$c$有多少个比当前扫到的数的$c$小。**这个东西我们用一个树状数组/线段树直接维护即可。 最后我们以$b$为关键字排序这两个区间，递归回去继续做即可。 注意一点细节：有可能会有几个元素的$(a,b,c)$全部相等，我们在刚刚的计算中是不会算到它们的相互影响的。对于这种情况，我们要提前为他们算上内部的影响，然后去重做即可。 在这里，我们在第二维上做的类似于归并排序的操作即为CDQ分治。 时间复杂度$O(nlog^2n)$ 就酱，我们又切掉一道题啦(๑¯∀¯๑) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//Luogu P3810 【模板】三维偏序（陌上花开） //Mar,26th,2019//CDQ分治+线段树+排序维护三维偏序#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int M=200000+100;struct node&#123; int x,y,z,no,ans; friend bool operator == (node a,node b) &#123; return (a.x==b.x and a.y==b.y and a.z==b.z); &#125;&#125;nd[N];bool cmp(node a,node b)&#123; if(a.x==b.x) &#123; if(a.y==b.y) return a.z&lt;b.z; return a.y&lt;b.y; &#125; return a.x&lt;b.x;&#125;bool cmp2(node a,node b)&#123; if(a.y==b.y) return a.z&lt;b.z; return a.y&lt;b.y;&#125;struct SegmentTree&#123; #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) #define mid ((now_l+now_r)&gt;&gt;1) int sum[M&lt;&lt;2]; inline void update(int now) &#123; sum[now]=sum[lson]+sum[rson]; &#125; void Add(int x,int v,int now,int now_l,int now_r) &#123; if(now_l==now_r) &#123; sum[now]+=v; return ; &#125; if(x&lt;=mid) Add(x,v,lson,now_l,mid); else Add(x,v,rson,mid+1,now_r); update(now); &#125; int Query(int l,int r,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) return sum[now]; int t_ans=0; if(l&lt;=mid) t_ans+=Query(l,r,lson,now_l,mid); if(r&gt;mid) t_ans+=Query(l,r,rson,mid+1,now_r); return t_ans; &#125; #undef lson #undef rson #undef mid&#125;sgt;int n,m,K,belong[N],cnt[N],ans[N],cnt_belong,ans2[N];void CDQ(int l,int r)&#123; if(l==r) return; int mid=(l+r)/2; CDQ(l,mid); CDQ(mid+1,r); int ptl=l; for(int i=mid+1;i&lt;=r;i++) &#123; for(;nd[ptl].y&lt;=nd[i].y and ptl&lt;=mid;ptl++) sgt.Add(nd[ptl].z,cnt[nd[ptl].no],1,0,K); ans[nd[i].no]+=sgt.Query(0,nd[i].z,1,0,K); &#125; ptl=l; for(int i=mid+1;i&lt;=r;i++) for(;nd[ptl].y&lt;=nd[i].y and ptl&lt;=mid;ptl++) sgt.Add(nd[ptl].z,-cnt[nd[ptl].no],1,0,K); sort(nd+l,nd+r+1,cmp2);&#125;int main()&#123; n=read(),K=read(); for(int i=1;i&lt;=n;i++) nd[i].x=read(),nd[i].y=read(),nd[i].z=read(),nd[i].no=i; sort(nd+1,nd+1+n,cmp); for(int i=1;i&lt;=n;i++) if(nd[i]==nd[i-1]) cnt[cnt_belong]++,belong[nd[i].no]=cnt_belong; else cnt[++cnt_belong]++,belong[nd[i].no]=cnt_belong; for(int i=1;i&lt;=cnt_belong;i++) ans[i]+=cnt[i]-1; m=unique(nd+1,nd+1+n)-nd-1; for(int i=1;i&lt;=m;i++) nd[i].no=i; CDQ(1,m); for(int i=1;i&lt;=n;i++) ans2[ans[belong[i]]]++; for(int i=0;i&lt;n;i++) printf(&quot;%d\\n&quot;,ans2[i]); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://www.goldenpotato.cn/categories/CDQ%E5%88%86%E6%B2%BB/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[BZOJ 4025] 二分图","slug":"bzoj-4025-二分图","date":"2019-03-25T07:43:44.000Z","updated":"2019-03-25T07:43:44.000Z","comments":true,"path":"2019/03/25/bzoj-4025-二分图/","permalink":"http://www.goldenpotato.cn/2019/03/25/bzoj-4025-%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"","text":"题面 4025: 二分图 Solution 这种每条边出现在一段区间的题，我们可以先考虑使用线段树分治来搞。 这题我们考虑离线下来搞。离线之后，我们会发现，某条边会在某些询问区间中出现。 考虑以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。 接下来，我们考虑如何维护一个图是否为二分图的问题。我们知道，一个图是二分图当且仅当这个图上所有的环的长度(点的个数)均为偶数。 知道这一点之后，我们考虑用并查集处理这个问题。对于没有环的时候，我们直接连上就好。对于有环的时候，我们就需要知道这两个点的距离是奇数还是偶数。如果是奇数的，说明之后无论在怎么连，这个图一定gg了，直到这条边取消位置；如果是偶数的，说明这个环是合法的，之后无论有什么边接到这个环上，我们当前这条新插入的边都不会有任何影响。因此，如果一条边会连城环，无论如何，这条边都不会被加上。 所以说，我们这里维护的东西是一个生成树。我们考虑用并查集维护这个生成树。因为我们这里是按秩合并的并查集，失去了原来的树的结构。因此，我们考虑在每个点上维护它到它的父亲的真实距离。我们在连接两个点的时候，我们在并查集上肯定是连接这两个点所在并查集的父亲。这时候，这两个父亲的真实距离一定为这两个点到父亲的真实距离和+1，(这里我们的真实距离和直接暴力算即可，因为并查集按秩合并时，高度不会太大)。 我们查询的时候我们算的是它们两个点到并查集的LCA的真实距离，因为并查集的LCA不一定是它们在原树中的LCA，因此我们这里按真实距离算出来的距离并非它们两的真实距离。但是，我们会发现这里多算的距离一定是2的倍数(两个点同时经过一条边)，因此，我们的奇偶性质还是正确的。 时间复杂度$O(nlog^2n)$ 就酱，我们就可以切掉这道题啦ヾ(◍°∇°◍)ﾉﾞ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//BZOJ 4025 二分图//线段树二分+并查集妙题//Mar,25th,2019#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;struct edge&#123; int s,t; edge (int x,int y) &#123; s=x,t=y; &#125;&#125;;struct UnF&#123; int fa[N],size[N],dis[N],depth[N],top,mstack[N*20]; void Init(int n) &#123; for(int i=1;i&lt;=n;i++) depth[i]=size[i]=1; &#125; int GetFa(int x,int &amp;w) &#123; if(fa[x]==0) &#123; w++; return x; &#125; int t=GetFa(fa[x],w+=dis[x]+1); depth[x]=depth[fa[x]]+1; return t; &#125; int LCA(int x,int y,int &amp;w) &#123; w=1; if(depth[x]&lt;depth[y]) swap(x,y); while(depth[x]&gt;depth[y]) w+=dis[x]+1,x=fa[x]; if(x==y) return x; w++; while(fa[x]!=fa[y]) &#123; w+=dis[x]+1,w+=dis[y]+1; x=fa[x],y=fa[y]; &#125; w+=dis[x]+dis[y]+1; return fa[x]; &#125; int Link(int x,int y) &#123; int d1=0,d2=0,fa1=GetFa(x,d1),fa2=GetFa(y,d2); if(size[fa1]&gt;size[fa2]) swap(x,y),swap(fa1,fa2),swap(d1,d2); mstack[++top]=0; //cerr&lt;&lt;fa1&lt;&lt;&quot; &quot;&lt;&lt;fa2&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;d1&lt;&lt;&quot; &quot;&lt;&lt;d2&lt;&lt;endl; if(fa1==fa2) &#123; int t_d=0; LCA(x,y,t_d); if(t_d%2==1) return 1; return 0; &#125; mstack[top]=fa1; dis[fa1]=d1+d2-2,fa[fa1]=fa2,size[fa2]+=size[fa1]; return 0; &#125; void Undo() &#123; if(mstack[top]!=0) size[fa[mstack[top]]]-=size[mstack[top]],fa[mstack[top]]=0, dis[mstack[top]]=0,depth[mstack[top]]=1; top--; &#125;&#125;unf;int ans[N],top,OK;struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) vector &lt;edge&gt; w[N&lt;&lt;2]; void Add(int l,int r,edge x,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; w[now].push_back(x); return; &#125; if(l&lt;=mid) Add(l,r,x,lson,now_l,mid); if(r&gt;mid) Add(l,r,x,rson,mid+1,now_r); &#125; void dfs(int now,int now_l,int now_r) &#123; int cnt=0; for(int i=0;i&lt;int(w[now].size());i++) cnt+=unf.Link(w[now][i].s,w[now][i].t); OK+=cnt; //cerr&lt;&lt;endl; //cerr&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;now_l&lt;&lt;&quot; &quot;&lt;&lt;now_r&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;endl; if(now_l==now_r) ans[now_l]=OK; else &#123; dfs(lson,now_l,mid); dfs(rson,mid+1,now_r); &#125; OK-=cnt; for(int i=0;i&lt;int(w[now].size());i++) unf.Undo(); &#125; #undef mid #undef lson #undef rson&#125;sgt;int n,m,q;int main()&#123; n=read(),m=read(),q=read(); unf.Init(n); for(int i=1;i&lt;=m;i++) &#123; int u=read(),v=read(),s=read(),t=read(); sgt.Add(s+1,t,edge(u,v),1,1,q); &#125; sgt.dfs(1,1,q); for(int i=1;i&lt;=q;i++) if(ans[i]==0) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;&#125;","categories":[{"name":"并查集","slug":"并查集","permalink":"http://www.goldenpotato.cn/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P4246] [SHOI2008]堵塞的交通","slug":"luogu-p4246-shoi2008堵塞的交通","date":"2019-03-22T04:04:18.000Z","updated":"2019-03-22T04:04:18.000Z","comments":true,"path":"2019/03/22/luogu-p4246-shoi2008堵塞的交通/","permalink":"http://www.goldenpotato.cn/2019/03/22/luogu-p4246-shoi2008%E5%A0%B5%E5%A1%9E%E7%9A%84%E4%BA%A4%E9%80%9A/","excerpt":"","text":"题面 P4246 [SHOI2008]堵塞的交通 Solution 这题的确是有线段树上大分类讨论的在线做法，但是本菜鸡还是想主要讲一下离线暴力做法。 这题我们考虑离线下来搞。离线之后，我们会发现，某条边会在某些询问区间中出现。 考虑以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。 接下来，直接在线段树上跑dfs,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。 这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询任意节点的父亲的$size$是否为$n$即可。 因为我们这里有撤销（回溯）操作，因此必需使用按秩合并的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。 对于边和点，我们大力编号一下即可qwq。 时间复杂度$O(nlog^2n)$ 吗？ 问题是这玩意能过啊… 因此，我们的时间复杂度是$O($能过$)$ 就酱，我们又切掉一道题啦。(ﾉﾟ∀ﾟ)ﾉ Code 数据生成器 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;using namespace std;const int N=5;const int M=25;int main()&#123; srand(time(NULL)); freopen(&quot;4246.in&quot;,&quot;w&quot;,stdout); int n=N; cout&lt;&lt;n&lt;&lt;endl; for(int i=1;i&lt;=M;i++) &#123; int op=rand()%5; if(op==0 or op==1) &#123; int x1=rand()%n+1,x2=rand()%n+1,y1=rand()%2+1,y2=rand()%2+1; cout&lt;&lt;&quot;Ask &quot;&lt;&lt;y1&lt;&lt;&quot; &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;endl; &#125; else &#123; int x1=rand()%n+1,x2=rand()%n+1,y1=rand()%2+1,y2=rand()%2+1; while(1) &#123; if(x1==x2 and abs(y2-y1)==1) break; if(y1==y2 and abs(x2-x1)==1) break; x2=rand()%n+1,y2=rand()%2+1; &#125; if(op==2) cout&lt;&lt;&quot;Close &quot;; else cout&lt;&lt;&quot;Open &quot;; cout&lt;&lt;y1&lt;&lt;&quot; &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;endl; &#125; &#125; cout&lt;&lt;&quot;Exit&quot;; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182//Luogu P4246 [SHOI2008]堵塞的交通//Mar,22ed,2019//线段树分治离线维护动态图连通性#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int M=N*4;int ans[N];struct UnF&#123; int size[N],fa[N],mstack[M],top; void Init(int n) &#123; for(int i=1;i&lt;=n;i++) size[i]=1; &#125; int FindFather(int x) &#123; if(fa[x]==0) return x; return FindFather(fa[x]); &#125; void Link(int x,int y) &#123; mstack[++top]=0; int fa_x=FindFather(x),fa_y=FindFather(y); if(size[fa_x]&gt;size[fa_y]) swap(x,y),swap(fa_x,fa_y); if(fa_x==fa_y) return; mstack[top]=fa_x; fa[fa_x]=fa_y,size[fa_y]+=size[fa_x]; &#125; int Query(int x,int y) &#123; if(FindFather(x)==FindFather(y)) return true; return false; &#125; void Undo() &#123; if(mstack[top]==0) &#123; top--; return; &#125; size[fa[mstack[top]]]-=size[mstack[top]]; fa[mstack[top]]=0; top--; &#125;&#125;unf;struct OP&#123; int s,t,id;&#125;op[N],op2[M*20],e[M];struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) vector &lt;int&gt; w[N&lt;&lt;2]; void Insert(int l,int r,int x,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; w[now].push_back(x); return; &#125; if(l&lt;=mid) Insert(l,r,x,lson,now_l,mid); if(r&gt;mid) Insert(l,r,x,rson,mid+1,now_r); &#125; void dfs(int now,int now_l,int now_r) &#123; if(now_l&gt;now_r) return; for(int i=0;i&lt;int(w[now].size());i++) unf.Link(e[w[now][i]].s,e[w[now][i]].t); if(now_l==now_r) ans[now_l]=unf.Query(op[now_l].s,op[now_l].t); else &#123; dfs(lson,now_l,mid); dfs(rson,mid+1,now_r); &#125; for(int i=0;i&lt;int(w[now].size());i++) unf.Undo(); &#125; #undef mid #undef lson #undef rson&#125;sgt;int last[M],n,q,p;//q次询问,p个区间bool w[3][N][3];inline int GetID(int x,int y,int type)&#123; return ((y-1)*n+x-1)*3+type;&#125;inline int GetID2(int x,int y)&#123; return (y-1)*n+x;&#125;int main()&#123; freopen(&quot;4246.in&quot;,&quot;r&quot;,stdin); freopen(&quot;4246.out&quot;,&quot;w&quot;,stdout); n=read(); char OP[10]; while(1) &#123; scanf(&quot;%s&quot;,OP+1); if(OP[1]==&#x27;E&#x27;) break; else if(OP[1]==&#x27;O&#x27; or OP[1]==&#x27;C&#x27;) &#123; int y1=read(),x1=read(),y2=read(),x2=read(),type=1; if(OP[1]==&#x27;C&#x27;) type=0; if(x1&gt;x2) swap(x1,x2),swap(y1,y2); if(y1&gt;y2) swap(x1,x2),swap(y1,y2); if(x2==x1+1) &#123; if(w[y1][x1][0]==type) continue; w[y1][x1][0]=type; type=0; &#125; else &#123; if(w[y1][x1][2]==type) continue; w[y1][x1][2]=w[y2][x2][1]=type; type=2; &#125; if(OP[1]==&#x27;O&#x27;) last[GetID(x1,y1,type)]=q+1; else &#123; op2[++p].s=last[GetID(x1,y1,type)],op2[p].t=q,op2[p].id=GetID(x1,y1,type); last[GetID(x1,y1,type)]=0; &#125; &#125; else &#123; int y1=read(),x1=read(),y2=read(),x2=read(); op[++q].s=GetID2(x1,y1),op[q].t=GetID2(x2,y2); &#125; &#125; for(int i=0;i&lt;=6*n+100;i++) if(last[i]!=0) op2[++p].s=last[i],op2[p].t=q,op2[p].id=i; for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=n;j++) for(int k=0;k&lt;=2;k++) &#123; e[GetID(j,i,k)].s=GetID2(j,i); if(k==0) e[GetID(j,i,k)].t=GetID2(j+1,i); if(k==2) e[GetID(j,i,k)].t=GetID2(j,i+1); &#125; unf.Init(n*2+1); for(int i=1;i&lt;=p;i++) if(op2[i].s&lt;=op2[i].t) &#123; sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,q); cerr&lt;&lt;op2[i].s&lt;&lt;&quot; &quot;&lt;&lt;op2[i].t&lt;&lt;&quot; &quot;&lt;&lt;op2[i].id&lt;&lt;endl; &#125; sgt.dfs(1,1,q); for(int i=1;i&lt;=q;i++) if(ans[i]==0) printf(&quot;N\\n&quot;); else printf(&quot;Y\\n&quot;); return 0;&#125;","categories":[{"name":"并查集","slug":"并查集","permalink":"http://www.goldenpotato.cn/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P5227] [AHOI2013] 连通图","slug":"luogu-p5227-ahoi2013-连通图","date":"2019-03-22T03:50:13.000Z","updated":"2019-03-22T03:50:13.000Z","comments":true,"path":"2019/03/22/luogu-p5227-ahoi2013-连通图/","permalink":"http://www.goldenpotato.cn/2019/03/22/luogu-p5227-ahoi2013-%E8%BF%9E%E9%80%9A%E5%9B%BE/","excerpt":"","text":"题面 P5227 [AHOI2013]连通图 Solution 这题可以离线，因此我们可以考虑用线段树分治维护动态图连通性来搞。 这题我们考虑离线下来搞。离线之后，我们会发现，某条边会在某些询问区间中出现。 考虑以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。 接下来，直接在线段树上跑dfs,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。 这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询任意节点的父亲的$size$是否为$n$即可。 因为我们这里有撤销（回溯）操作，因此必需使用**按秩合并的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。 时间复杂度$O(nlog^2n)$ 吗？ 问题是这玩意能过啊… 因此，我们的时间复杂度是$O($能过$)$ 就酱，我们又切掉一道题啦。(ﾉﾟ∀ﾟ)ﾉ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//Luogu P5227 [AHOI2013]连通图//Mar,22ed,2019//线段树分治离线维护动态图连通性#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;ctime&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int M=200000+100;int n,m,q,p,ans[M];struct UnF&#123; int size[N],fa[N],mstack[M],top; void Init() &#123; for(int i=1;i&lt;=n;i++) size[i]=1; &#125; int FindFather(int x) &#123; if(fa[x]==0) return x; return FindFather(fa[x]); &#125; void Link(int x,int y) &#123; mstack[++top]=0; int fa_x=FindFather(x),fa_y=FindFather(y); if(size[fa_x]&gt;size[fa_y]) swap(x,y),swap(fa_x,fa_y); if(fa_x==fa_y) return; mstack[top]=fa_x; fa[fa_x]=fa_y,size[fa_y]+=size[fa_x]; &#125; int Query() &#123; if(size[FindFather(1)]==n) return true; return false; &#125; void Undo() &#123; if(mstack[top]==0) &#123; top--; return; &#125; size[fa[mstack[top]]]-=size[mstack[top]]; fa[mstack[top]]=0; top--; &#125;&#125;unf;struct OP&#123; int s,t,id;&#125;op2[M*20],e[M];struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) vector &lt;int&gt; w[M&lt;&lt;2]; void Insert(int l,int r,int x,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; w[now].push_back(x); return; &#125; if(l&lt;=mid) Insert(l,r,x,lson,now_l,mid); if(r&gt;mid) Insert(l,r,x,rson,mid+1,now_r); &#125; void dfs(int now,int now_l,int now_r) &#123; if(now_l&gt;now_r) return; for(int i=0;i&lt;int(w[now].size());i++) unf.Link(e[w[now][i]].s,e[w[now][i]].t); if(now_l==now_r) ans[now_l]=unf.Query(); else &#123; dfs(lson,now_l,mid); dfs(rson,mid+1,now_r); &#125; for(int i=0;i&lt;int(w[now].size());i++) unf.Undo(); &#125; #undef mid #undef lson #undef rson&#125;sgt;int last[M],K;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) e[i].s=read(),e[i].t=read(),last[i]=1; K=read(); for(int i=1;i&lt;=K;i++) &#123; int c=read(); for(int j=1;j&lt;=c;j++) &#123; int x=read(); op2[++p].s=last[x],op2[p].t=i-1,op2[p].id=x; last[x]=i+1; &#125; &#125; for(int i=1;i&lt;=m;i++) if(last[i]!=K+1) op2[++p].s=last[i],op2[p].t=K,op2[p].id=i; for(int i=1;i&lt;=p;i++) if(op2[i].s&lt;=op2[i].t) &#123; sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,K); //cerr&lt;&lt;op2[i].s&lt;&lt;&quot; &quot;&lt;&lt;op2[i].t&lt;&lt;&quot; &quot;&lt;&lt;op2[i].id&lt;&lt;endl; &#125; unf.Init(); sgt.dfs(1,1,K); for(int i=1;i&lt;=K;i++) if(ans[i]==0) printf(&quot;Disconnected\\n&quot;); else printf(&quot;Connected\\n&quot;); return 0;&#125;","categories":[{"name":"并查集","slug":"并查集","permalink":"http://www.goldenpotato.cn/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[LOJ 121] 「离线可过」动态图连通性","slug":"loj-121-「离线可过」动态图连通性","date":"2019-03-22T03:38:39.000Z","updated":"2019-03-22T03:38:39.000Z","comments":true,"path":"2019/03/22/loj-121-「离线可过」动态图连通性/","permalink":"http://www.goldenpotato.cn/2019/03/22/loj-121-%E3%80%8C%E7%A6%BB%E7%BA%BF%E5%8F%AF%E8%BF%87%E3%80%8D%E5%8A%A8%E6%80%81%E5%9B%BE%E8%BF%9E%E9%80%9A%E6%80%A7/","excerpt":"","text":"题面 #121. 「离线可过」动态图连通性 Solution 这题我们考虑离线下来搞。离线之后，我们会发现，某条边会在某些询问区间中出现。 考虑以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。 接下来，直接在线段树上跑dfs,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。 这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询即可。 因为我们这里有撤销（回溯）操作，因此必需使用按秩合并的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。 时间复杂度$O(nlog^2n)$？ 反正是$O(能过)$ 就酱，我们又切掉一道题啦φ(&gt;ω&lt;*) Code 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//LOJ #121. 「离线可过」动态图连通性//Mar,21st,2019//线段树分治离线维护动态图连通性#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;ctime&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=5000+100;const int M=500000+100;int n,m,q,p,ans[M];inline int GetID(int s,int t)&#123; if(s&gt;t) swap(s,t); return (s-1)*(n+1)+t;&#125;struct UnF&#123; int size[N],fa[N],mstack[M],top; void Init() &#123; for(int i=1;i&lt;=n;i++) size[i]=1; &#125; int FindFather(int x) &#123; if(fa[x]==0) return x; return FindFather(fa[x]); &#125; void Link(int x,int y) &#123; mstack[++top]=0; int fa_x=FindFather(x),fa_y=FindFather(y); if(size[fa_x]&gt;size[fa_y]) swap(x,y),swap(fa_x,fa_y); if(fa_x==fa_y) return; mstack[top]=fa_x; fa[fa_x]=fa_y,size[fa_y]+=size[fa_x]; &#125; int Query(int x,int y) &#123; if(FindFather(x)==FindFather(y)) return true; return false; &#125; void Undo() &#123; if(mstack[top]==0) &#123; top--; return; &#125; size[fa[mstack[top]]]-=size[mstack[top]]; fa[mstack[top]]=0; top--; &#125;&#125;unf;struct OP&#123; int s,t,id;&#125;op[M],op2[M];struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) vector &lt;int&gt; e[M&lt;&lt;2]; void Insert(int l,int r,int x,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; //cerr&lt;&lt;now_l&lt;&lt;&quot; &quot;&lt;&lt;now_r&lt;&lt;endl; e[now].push_back(x); return; &#125; if(l&lt;=mid) Insert(l,r,x,lson,now_l,mid); if(r&gt;mid) Insert(l,r,x,rson,mid+1,now_r); &#125; void dfs(int now,int now_l,int now_r) &#123; if(now_l&gt;now_r) return; for(int i=0;i&lt;int(e[now].size());i++) &#123; //cerr&lt;&lt;now_l&lt;&lt;&quot; &quot;&lt;&lt;now_r&lt;&lt;&quot; &quot;&lt;&lt; e[now][i]%(n+1)&lt;&lt;&quot; &quot;&lt;&lt;e[now][i]/(n+1)+1&lt;&lt;endl; unf.Link(e[now][i]%(n+1),e[now][i]/(n+1)+1); &#125; if(now_l==now_r) ans[now_l]=unf.Query(op[now_l].s,op[now_l].t); else &#123; dfs(lson,now_l,mid); dfs(rson,mid+1,now_r); &#125; for(int i=0;i&lt;int(e[now].size());i++) unf.Undo(); &#125; #undef mid #undef lson #undef rson&#125;sgt;int last[N*N];int main()&#123; freopen(&quot;121.in&quot;,&quot;r&quot;,stdin); freopen(&quot;121.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; int top=read(),s=read(),t=read(); if(top==0) last[GetID(s,t)]=q+1; else if(top==1) &#123; op2[++p].s=last[GetID(s,t)],op2[p].t=q,op2[p].id=GetID(s,t); last[GetID(s,t)]=0; &#125; else op[++q].s=s,op[q].t=t; &#125; for(int i=1;i&lt;=(n+1)*(n+1);i++) if(last[i]!=0) op2[++p].s=last[i],op2[p].t=q,op2[p].id=i; for(int i=1;i&lt;=p;i++) if(op2[i].s&lt;=op2[i].t) sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,q); unf.Init(); sgt.dfs(1,1,q); for(int i=1;i&lt;=q;i++) if(ans[i]==0) printf(&quot;N\\n&quot;); else printf(&quot;Y\\n&quot;); return 0;&#125;","categories":[{"name":"并查集","slug":"并查集","permalink":"http://www.goldenpotato.cn/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[BZOJ 3744] Gty的妹子序列","slug":"bzoj-3744-gty的妹子序列","date":"2019-03-20T14:41:38.000Z","updated":"2019-03-20T14:41:38.000Z","comments":true,"path":"2019/03/20/bzoj-3744-gty的妹子序列/","permalink":"http://www.goldenpotato.cn/2019/03/20/bzoj-3744-gty%E7%9A%84%E5%A6%B9%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"题面 3744: Gty的妹子序列 Solution 这是一道分块妙题。 区间逆序对…log数据结构应该是没法搞的。 因此，我们考虑用分块解决这个问题。 设$f[i][j]$表示第$i$块与第$j$块的所有元素的逆序对个数 这个东西我们可以考虑用线段树/树状数组直接搞，我们把所有数字从大到小插入，(数字相同的时候一起插入),每插入一种数字，我们可以直接计算它到其他所有块会新产生的逆序对数：即那个块的大小-已经填好的数字的个数。 上面的东西可以$O(n\\cdot \\sqrt n \\cdot logn)$预处理出来。 接下来，我们用**$g[i][j]$表示从第$i$块开始，第$i$块与$i-j$块中所有元素的逆序对个数**，这个可以利用$f$直接前缀和计算。 那么$l,r$中所有元素的逆序对个数即为里面整块的$\\sum g[i][br]+$零散的值的逆序对个数。对于零散的值的个数，我们可以直接用主席树求即可。 时间复杂度$O(n\\cdot \\sqrt n \\cdot logn)$,卡常。 如果您BZOJ卡不过的话，可以来luogu这道题试试 就酱，我们又切掉一道题啦ヾ(o´∀｀o)ﾉ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//[BZOJ 3744] Gty的妹子序列//Mar,20th,2019//分块求区间逆序对数#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=50000+100;const int Q=225+20;struct SegmentTree&#123; #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) #define mid ((now_l+now_r)&gt;&gt;1) int sum[N&lt;&lt;2]; inline void update(int now) &#123; sum[now]=sum[lson]+sum[rson]; &#125; void Add(int x,int num,int now,int now_l,int now_r) &#123; if(now_l==now_r) &#123; sum[now]+=num; return; &#125; if(x&lt;=mid) Add(x,num,lson,now_l,mid); else Add(x,num,rson,mid+1,now_r); update(now); &#125; int Query(int l,int r,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) return sum[now]; int t_ans=0; if(l&lt;=mid) t_ans+=Query(l,r,lson,now_l,mid); if(r&gt;mid) t_ans+=Query(l,r,rson,mid+1,now_r); return t_ans; &#125; #undef lson #undef rson #undef mid&#125;sgt;struct PresidentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) static const int M=(50000&lt;&lt;2)*30; int sum[M],son[M][2],to; inline void update(int now) &#123; sum[now]=sum[son[now][0]]+sum[son[now][1]]; &#125; void Add(int x,int now,int pre,int now_l,int now_r) &#123; if(now_l==now_r) &#123; sum[now]=sum[pre]+1; return; &#125; if(x&lt;=mid) &#123; Add(x,son[now][0]=++to,son[pre][0],now_l,mid); son[now][1]=son[pre][1]; &#125; else &#123; Add(x,son[now][1]=++to,son[pre][1],mid+1,now_r); son[now][0]=son[pre][0]; &#125; update(now); &#125; int Query(int l,int r,int now,int pre,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) return sum[now]-sum[pre]; int t_ans=0; if(l&lt;=mid) t_ans+=Query(l,r,son[now][0],son[pre][0],now_l,mid); if(r&gt;mid) t_ans+=Query(l,r,son[now][1],son[pre][1],mid+1,now_r); return t_ans; &#125; #undef mid&#125;prt;struct NUM&#123; int w,no;&#125;num[N];bool cmp(NUM x, NUM y)&#123; return x.w&gt;y.w;&#125;bool cmp2(NUM x,NUM y)&#123; return x.no&lt;y.no;&#125;int t_a[N],n,m,block,cnt[Q],msize[Q];int f[Q][Q],g[Q][Q],root[N];int main()&#123; int t=clock(); freopen(&quot;3744.in&quot;,&quot;r&quot;,stdin); freopen(&quot;3744.out&quot;,&quot;w&quot;,stdout); n=read(); for(int i=1;i&lt;=n;i++) num[i].w=t_a[i]=read(),num[i].no=i; sort(t_a+1,t_a+1+n); m=unique(t_a+1,t_a+1+n)-t_a-1; for(int i=1;i&lt;=n;i++) num[i].w=lower_bound(t_a+1,t_a+1+m,num[i].w)-t_a; sort(num+1,num+1+n,cmp); int size=int(sqrt(n)); msize[0]=size-1,msize[n/size]=n%size+1; for(int i=1;i&lt;n/size;i++) msize[i]=size; block=n/size; for(int i=1;i&lt;=n;i++) sgt.Add(i,1,1,1,n); static int mqueue[N],tail; int to=0; while(to&lt;n) &#123; tail=0; for(to++;to&lt;=n;to++) &#123; sgt.Add(num[to].no,-1,1,1,n); cnt[num[to].no/size]++; mqueue[tail++]=to; if(num[to+1].w != num[to].w) break; &#125; for(int t=0;t&lt;tail;t++) &#123; int i=mqueue[t]; for(int j=num[i].no/size+1;j&lt;=block;j++) f[j][num[i].no/size]+=msize[j]-cnt[j], f[num[i].no/size][j]+=msize[j]-cnt[j]; f[num[i].no/size][num[i].no/size]+=sgt.Query(num[i].no,(num[i].no/size+1)*size-1,1,1,n); &#125; &#125; for(int i=0;i&lt;=block;i++) &#123; g[i][i]=f[i][i]; for(int j=i+1;j&lt;=block;j++) g[i][j]+=g[i][j-1]+f[i][j]; &#125; /*for(int i=0;i&lt;=block;i++) &#123; for(int j=i;j&lt;=block;j++) cerr&lt;&lt;g[i][j]&lt;&lt;&quot; &quot;; cerr&lt;&lt;endl; &#125;*/ sort(num+1,num+1+n,cmp2); for(int i=1;i&lt;=n;i++) &#123; root[i]=++prt.to; prt.Add(num[i].w,root[i],root[i-1],0,m); &#125; int q=read(),ans=0; for(int i=1;i&lt;=q;i++) &#123; int l=read()^ans,r=read()^ans; ans=0; for(int j=l;j&lt;min((l/size+1)*size,r+1);j++)//左散块 ans+=prt.Query(0,num[j].w-1,root[r],root[j],0,m); if(l/size+1 &lt;= r/size-1)//中间块 for(int j=l/size+1;j&lt;=r/size-1;j++) ans+=g[j][r/size-1]; if(l/size!=r/size)//右散块 for(int j=r/size*size;j&lt;=r;j++) &#123; ans+=prt.Query(0,num[j].w-1,root[r],root[j],0,m); if(l/size+1 &lt;= r/size-1) ans+=prt.Query(num[j].w+1,m,root[r/size*size-1],root[(l/size+1)*size-1],0,m); &#125; printf(&quot;%d\\n&quot;,ans); &#125; cerr&lt;&lt;clock()-t; return 0;&#125;","categories":[{"name":"主席树","slug":"主席树","permalink":"http://www.goldenpotato.cn/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"分块","slug":"分块","permalink":"http://www.goldenpotato.cn/categories/%E5%88%86%E5%9D%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[BZOJ 4320] ShangHai2006 Homework","slug":"bzoj-4320-shanghai2006-homework","date":"2019-03-19T13:39:54.000Z","updated":"2019-03-19T13:39:54.000Z","comments":true,"path":"2019/03/19/bzoj-4320-shanghai2006-homework/","permalink":"http://www.goldenpotato.cn/2019/03/19/bzoj-4320-shanghai2006-homework/","excerpt":"","text":"题面 4320: ShangHai2006 Homework Solution 这是一道分块妙题。 首先，我们发现这题是对一个比较大的任意模数取模，那我们传统的log数据结构可能还真没法下手。 既然如此，我们考虑分块。 我们把原题中的询问分为两类： 1. $p&gt;=\\sqrt{300000}$ 2. $p&lt;\\sqrt{300000}$ 对于第二种情况，我们可以开一个桶$f[x]$表示目前为止所有数字%$x$后取得的最小值。这个东西我们在插入数字的时候暴力更新一下即可。 对于第一种情况，事情有点复杂，我们这样做： 把所有数字平铺在数轴上，然后我们假设要求%$p$的ans，我们会发现，这个ans一定是$p$的整数倍的(右边的最靠近它的数字-它的位置)的最小值(正确性用草稿纸玩一玩就可以发现了) 那怎么维护某个位置的最右边的最靠近它的数呢？log数据结构显然可以做。问题是log数据结构在这里要T掉。 怎么办呢？我们发现这题可以离线做。 考虑这样做，我们先把所有数字插入到数轴里面，然后我们维护一个并查集：每一个点的fa指向他的后一个点，如果这个点是有数字的，则他作为一个根。 我们可以显然发现，一个点的在它右边的最靠近它的数字一定是它所在的连通块的根，对于删除数字，我们直接把这个点的fa指向后一个即可。 时间复杂度$O(n\\cdot \\sqrt{300000})$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//BZOJ 4320: ShangHai2006 Homework//Mar,19th,2019//分块处理膜号妙题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int MAX=300000+100;int fa[MAX];int GetFa(int x)&#123; if(x&gt;=300001) return 0x3f3f3f3f; if(fa[x]==0) return x; return fa[x]=GetFa(fa[x]);&#125;int num[N],ans[N],op[N],type[N],f[MAX];//type:0插入；1:询问int n,size=550;bool vis[MAX];int main()&#123; freopen(&quot;4320.in&quot;,&quot;r&quot;,stdin); freopen(&quot;4320.out&quot;,&quot;w&quot;,stdout); int msize = 256 &lt;&lt; 20; // 256MB char *p = (char*)malloc(msize) + msize; __asm__(&quot;movl %0, %%esp\\n&quot; :: &quot;r&quot;(p)); n=read(); memset(f,0x3f,sizeof f); for(int i=1;i&lt;=n;i++) &#123; char OP[4]; scanf(&quot;%s&quot;,OP+1); op[i]=read(); if(OP[1]==&#x27;A&#x27;) &#123; vis[op[i]]=true; for(int j=1;j&lt;size;j++) f[j]=min(f[j],op[i]%j); &#125; else &#123; type[i]=1; if(op[i]&lt;size) ans[i]=f[op[i]]; &#125; &#125; for(int i=0;i&lt;=300000;i++) if(vis[i]==false) fa[i]=i+1; for(int i=n;i&gt;=1;i--) if(type[i]==0) fa[op[i]]=op[i]+1; else if(op[i]&gt;=size) &#123; ans[i]=0x3f3f3f3f; for(int j=0;j*op[i]&lt;=300000;j++) ans[i]=min(ans[i],GetFa(j*op[i])-j*op[i]); &#125; for(int i=1;i&lt;=n;i++) if(type[i]==1) printf(&quot;%d\\n&quot;,ans[i]); return 0;&#125;","categories":[{"name":"分块","slug":"分块","permalink":"http://www.goldenpotato.cn/categories/%E5%88%86%E5%9D%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P3645] [APIO2015]雅加达的摩天楼","slug":"luogu-p3645-apio2015雅加达的摩天楼","date":"2019-03-19T13:15:47.000Z","updated":"2019-03-19T13:15:47.000Z","comments":true,"path":"2019/03/19/luogu-p3645-apio2015雅加达的摩天楼/","permalink":"http://www.goldenpotato.cn/2019/03/19/luogu-p3645-apio2015%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC/","excerpt":"","text":"题面 P3645 [APIO2015]雅加达的摩天楼 Solution 与其说这题是分块妙题，我更倾向于把这题称为分层图妙题。 这题有一个一眼贪心做法：对于每只doge，我们都暴力地去建它连向它能跳到的点的边，边权为跳的次数。然后直接求一遍单元最短路即可。 很显然，这玩意的边的数量是$O(n^2)$的，求一遍最短路的复杂度达到了惊人的$n^2logn^2$ 这显然是要T飞的，但是我们会从中发现一个问题：既然一个doge的跳跃是多步的，那我们能否直接把几步拆开来，然后省略重复的边？ 例如： 优化为： 这样做看起来很星，很不幸的是，这样是不行的。因为我们在计算最短路的时候，我们有可能直接从中间某个点出发，但是很不幸的是，这样是不可行的。 怎么办呢？这时我们可以考虑把网络流的分层图那一套搬出来。 我们可以考虑使用“拆点”的做法来限制从某个点出发去更新别的点的最短路。 考虑把一个点拆分为size个点，每个拆分点的含义为所有一次跳x步的都从它出发，并到达它那里。 从每个点的拆分点出发，向它的原点连一条边权为0的有向边 如果能从某个点出发，则对应的从原点连向那个跳x格远的分点连一条边权为0的边 接下来我们从每个点的对应的跳x格远的的点连向其他的点的跳x格的点，边权为1 一图胜千言： 变为 最后一行的所有点即为原来的点 从下往上第x行的点即为某个原点的第x个分点 通过这样一轮拆分，我们就已经可以解决问题啦。 啥？你说这样会有$n^2$个点？这是就得用到分块思想啦。你想，如果一个doge一次能跳的距离超过$\\sqrt n$格远，那总共连出来的边不会超过$\\sqrt n$条，我们直接在原点连就好啦qwq。 根据玄学证明，这里的块大小取100是最好的（我并不会证） 时间复杂度O(能过) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// luogu-judger-enable-o2#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=30000+100;const int M=100+20;struct edge&#123; int to,w; edge (int x,int y) &#123; to=x,w=y; &#125;&#125;;vector &lt;edge&gt; e[N*M];int n,m,size,dis[N*M],S,T;void spfa()&#123; static int InQueue[N*M],mqueue[N*M*10],front,tail; memset(dis,0x3f,sizeof dis); front=tail=0; mqueue[tail++]=S*size,dis[S*size]=0; while(tail&gt;front) &#123; int now=mqueue[front++]; InQueue[now]=false; for(int i=0;i&lt;int(e[now].size());i++) if(dis[e[now][i].to]&gt;dis[now]+e[now][i].w) &#123; dis[e[now][i].to]=dis[now]+e[now][i].w; if(InQueue[e[now][i].to]==false) &#123; InQueue[e[now][i].to]=true; mqueue[tail++]=e[now][i].to; &#125; &#125; &#125;&#125;int main()&#123; //freopen(&quot;3645.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;3645.out&quot;,&quot;w&quot;,stdout); int t=clock(); n=read(),m=read(); size=min(int(sqrt(n)),50); int to=n*size; for(int i=1;i&lt;=to;i++) e[i].reserve(4); for(int i=0;i&lt;n;i++) for(int j=1;j&lt;size;j++) e[i*size+j].push_back(edge(i*size,0)); for(int i=1;i&lt;=m;i++) &#123; int b=read(),p=read(); if(i==1) S=b; if(i==2) T=b; if(p&gt;=size) &#123; for(int j=b+p,k=1;j&lt;n;j+=p,k++) e[b*size].push_back(edge(j*size,k)); for(int j=b-p,k=1;j&gt;=0;j-=p,k++) e[b*size].push_back(edge(j*size,k)); &#125; else &#123; e[b*size].push_back(edge(b*size+p,0)); for(int j=b;j&lt;n-p;j+=p) &#123; bool OK=false; for(int k=0;k&lt;int(e[j*size+p].size());k++) if(e[j*size+p][k].to==(j+p)*size+p) &#123; OK=true; break; &#125; if(OK==true) break; e[j*size+p].push_back(edge((j+p)*size+p,1)); &#125; for(int j=b;j&gt;=p;j-=p) &#123; bool OK=false; for(int k=0;k&lt;int(e[j*size+p].size());k++) if(e[j*size+p][k].to==(j-p)*size+p) &#123; OK=true; break; &#125; if(OK==true) break; e[j*size+p].push_back(edge((j-p)*size+p,1)); &#125; &#125; &#125; spfa(); if(dis[T*size]&lt;0x3f3f3f3f) printf(&quot;%d&quot;,dis[T*size]); else printf(&quot;-1&quot;); cerr&lt;&lt;clock()-t; return 0;&#125;","categories":[{"name":"分块","slug":"分块","permalink":"http://www.goldenpotato.cn/categories/%E5%88%86%E5%9D%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路径","slug":"最短路径","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P3247] [HNOI2016]最小公倍数","slug":"luogu-p3247-hnoi2016最小公倍数","date":"2019-03-19T11:24:56.000Z","updated":"2019-03-19T11:24:56.000Z","comments":true,"path":"2019/03/19/luogu-p3247-hnoi2016最小公倍数/","permalink":"http://www.goldenpotato.cn/2019/03/19/luogu-p3247-hnoi2016%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/","excerpt":"","text":"题面 P3247 [HNOI2016]最小公倍数 Solution 这是一道妙题。 首先，根据常识，题面要我们求的是找一条从s,t的路径，使得路径上$max\\ a=a,max\\ b=b$。 这咋求呢？我们会发现，我们要求的路径本质上是一个连通块，连通块可以考虑用并查集处理。 接下来考虑对a分块，先把所有的边按照$a$来排序，再分块，每个块里连的所有边保证$&lt;=a_{[size*x]}$，如下图所示： 接下来，我们考虑把所有询问按照b从小到大排序去一个个计算，每计算一个询问之前，把$b&lt;=q[i].b$的边全部都对应地塞到联通快里面去(根据我们之前分块的定义，每条边说要塞入的并查集一定为从某个连通块开始一直往后到最后一个块为止)。 接下来，我们对应的去找最大的$a&lt;=q[i].a$的连通块，然后把一些还零散在外面的边全部塞到那个连通块里面，这个连通块里面所有的边一定能保证$a&lt;=q[i].a,b&lt;=q[i].b$，我们只需要对应的看看$u,v$是否联通，它们所在的连通块的$max_a,max_b$是否满足要求即可。 我们每做完一个操作后，必须把之前连的零散的边给撤销掉。因此，我们这里必须用按秩合并的并查集。我们可以通过用一个栈/队列记录所有的修改操作(改fa/改max)一个一个改回去即可。 因为我们这里有$\\sqrt m$个块，每次操作的零散边不超过$\\sqrt m$条，因此总复杂度应该是$O(n \\cdot \\sqrt m)$ Code 数据生成器 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;const int N=30;const int M=80;const int MAX=16;bool vis[MAX+50];long long mrand()&#123; long long temp=(1ll*rand()*rand())%MAX,op=rand()%4; /*while(op==0 and vis[temp]==false) temp=(1ll*rand()*rand())%MAX;*/ vis[temp]=true; return temp;&#125;int main()&#123; srand(time(NULL)); freopen(&quot;3247.in&quot;,&quot;w&quot;,stdout); int n=N,m=M; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=m;i++) cout&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;mrand()&lt;&lt;&quot; &quot;&lt;&lt;mrand()&lt;&lt;endl; int q=N; cout&lt;&lt;q&lt;&lt;endl; for(int i=1;i&lt;=q;i++) cout&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;mrand()&lt;&lt;&quot; &quot;&lt;&lt;mrand()&lt;&lt;endl; return 0; &#125; 请注意特判(0,0)边构成自环的情况，我因为这个破事WA了半天 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=50000+100;const int M=100000+100;const int Q=1000;struct line&#123; int s,t,a,b,ans,no; friend bool operator &lt; (line x,line y) &#123; return x.a&lt;y.a; &#125;&#125;l[M],l2[M],q[N];bool cmp1(line x,line y)&#123; return x.a&lt;y.a;&#125;bool cmp2(line x,line y)&#123; return x.b&lt;y.b;&#125;bool cmp3(line x,line y)&#123; return x.no&lt;y.no;&#125;int n,m,K,block[Q];//block[i]:记录第i块的a值struct SIT&#123; int type,x,num1,num2;//type=0:改fa;type=1:改max&#125;mstack[N];int top;struct UnF&#123; int fa[N],size[N],MAX_a[N],MAX_b[N]; int FindFather(int x) &#123; if(fa[x]==0) return x; return FindFather(fa[x]); &#125; void Merge(int x,int y,int a,int b,bool type)//type=0：不撤回;=1:要撤回 &#123; int fa1=FindFather(x),fa2=FindFather(y); if(size[fa1]&gt;size[fa2]) swap(x,y),swap(fa1,fa2); if(type==1) mstack[++top].type=1,mstack[top].x=fa2, mstack[top].num1=MAX_a[fa2],mstack[top].num2=MAX_b[fa2]; MAX_a[fa2]=max(max(MAX_a[fa2],MAX_a[fa1]),a); MAX_b[fa2]=max(max(MAX_b[fa2],MAX_b[fa1]),b); if(fa1==fa2) return; if(type==1) mstack[++top].type=0,mstack[top].x=fa1,mstack[top].num1=fa2,mstack[top].num2=size[fa1]; fa[fa1]=fa2,size[fa2]+=size[fa1]; &#125; void Undo() &#123; for(;top&gt;0;top--) &#123; if(mstack[top].type==0) fa[mstack[top].x]=0,size[mstack[top].num1]-=mstack[top].num2; else MAX_a[mstack[top].x]=mstack[top].num1, MAX_b[mstack[top].x]=mstack[top].num2; &#125; &#125; int Query(int x,int y,int a,int b) &#123; if(x==y and a==0 and b==0) return size[FindFather(x)]!=1; int fa=FindFather(x); if(FindFather(x)!=FindFather(y)) return false; if(MAX_a[fa]!=a or MAX_b[fa]!=b) return false; return true; &#125;&#125;unf[Q];int main()&#123; int t=clock(); n=read(),m=read(); for(int i=1;i&lt;=m;i++) &#123; l[i].s=read(),l[i].t=read(),l[i].a=read(),l[i].b=read(); l2[i]=l[i]; &#125; K=read(); for(int i=1;i&lt;=K;i++) q[i].s=read(),q[i].t=read(),q[i].a=read(),q[i].b=read(),q[i].no=i; int size=int(sqrt(m*20)),cnt=m/size; for(int i=0;i&lt;=cnt;i++) for(int j=1;j&lt;=n;j++) unf[i].size[j]=1; sort(l+1,l+1+m,cmp1); sort(l2+1,l2+1+m,cmp1); for(int i=0;i&lt;=m/size;i++) block[i]=l[i*size].a; sort(q+1,q+1+K,cmp2); sort(l+1,l+1+m,cmp2); int to=1;//记录当前执行到第to条边 for(int i=1;i&lt;=K;i++) &#123; //cerr&lt;&lt;i&lt;&lt;endl; for(;l[to].b&lt;=q[i].b and to&lt;=m;to++) &#123; int begin=lower_bound(block,block+1+cnt,l[to].a)-block; for(int j=begin;j&lt;=cnt;j++) unf[j].Merge(l[to].s,l[to].t,l[to].a,l[to].b,0); &#125; int t=upper_bound(block,block+1+cnt,q[i].a)-block-1; line tmp;tmp.a=block[t]; for(int j=upper_bound(l2+1,l2+1+m,tmp)-l2;j&lt;=m and l2[j].a&lt;=q[i].a;j++) if(l2[j].b&lt;=q[i].b) unf[t].Merge(l2[j].s,l2[j].t,l2[j].a,l2[j].b,1); q[i].ans=unf[t].Query(q[i].s,q[i].t,q[i].a,q[i].b); unf[t].Undo(); &#125; sort(q+1,q+1+K,cmp3); for(int i=1;i&lt;=K;i++) if(q[i].ans==1) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); cerr&lt;&lt;clock()-t&lt;&lt;endl; return 0;&#125;","categories":[{"name":"并查集","slug":"并查集","permalink":"http://www.goldenpotato.cn/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"分块","slug":"分块","permalink":"http://www.goldenpotato.cn/categories/%E5%88%86%E5%9D%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[NNEZ Monthly Round 5 T2] 文件系统 题解","slug":"nnez-monthly-round-5-t2-文件系统-题解","date":"2019-03-19T04:02:37.000Z","updated":"2019-03-19T04:02:37.000Z","comments":true,"path":"2019/03/19/nnez-monthly-round-5-t2-文件系统-题解/","permalink":"http://www.goldenpotato.cn/2019/03/19/nnez-monthly-round-5-t2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"题面 洛谷团队题（尚未入团的请尽快加入团队） 梗 $\\huge μ’sic\\ Forever!$ 114514.avi.zip 1919810 （(懂的人自然懂(确信)) 真寻酱实在是太可爱了 ⑨个样例(我够良心吧) 真*Solution 稍有常识的人都可以看出,一个文件目录在任意时刻都是一个树的形式（如果没有快捷方式的话）。 像这样：（样例） 解法一 我们来看看type=1啥意思… op!=3 and op!=5 and 名字为数字? emmmm？ 因为OP！=5，树上已经插入的边是不会变的，因此，我们考虑用vector/链式前向星/领接表把这棵树存下来。 首先，我们要记录每个点的信息：它的size，是文件还是文件夹,它的父亲是什么 每次我们查询size的时候直接dfs遍历一遍子树来计算即可。 啥？你说怎么处理Error？大力分类讨论，请。 其实很是很好讨论的qwq。 啥？你不会输入？一时数字一时字符串怎么办？那请全部使用字符串的形式读入，再检测是否为数字，如果为数字的话，手动计算成数字即可。 啥？你说不会读入字符串？爆零,请。NOIp2018 普及组T1 标题统计，请 时间复杂度$O(n^2)$ 恭喜你，获得了10分的好成绩 . 解法二 emmm，少了个op!=3，用人话来说，就是允许改名了。 emmm？这分简直就是送出去的啊喂。 我们思考一下，改名会造成什么问题： 1. 因为我们用名字来作为记录孩子的关键字，因此会导致孩子发生改变-&gt;直接修改vector/领接表/链式前向星的对应的边即可 2. 要对应地创造出一个新的点并且复制原有的信息，把原有的点删除掉（删除掉标记即可）。-&gt;4遍赋值：赋值fa，size，type，vis 3. 没了 时间复杂度$O(n^2)$ 恭喜你，获得了20分的好成绩 . 解法三 emmm，这次不改名了…但是TM的要改父亲。 这就肥肠尴尬了…改父亲涉及到某个点删除某个孩子，很不幸的是，这种操作在vector/链式前向星中是很难做到的，即使强行做了，时间复杂度也很高。 怎么办呢？我们不妨换个思路：我们在每次插入一个新的文件的时候，计算它的“贡献”。 什么叫贡献呢？下面这个图可以很清晰的说明： 也就是说，我们插入一个大小为$x$的文件，会导致它的父亲及祖先在查询$size$的时候，查询出来的答案增加$x$（因为多了这一个文件嘛） 因此，我们可以直接记录查询某个节点时的答案（$size,cnt$），每次查询的时候直接输出它的答案。每次插入新的文件的时候，我们直接暴力向上更新他的父亲及祖先的答案。修改的时候，我们也是先暴力修改他的父亲及祖先的答案，然后改变$fa$，再暴力修改新的父亲及祖先的答案 这样，我们就只用记录每个点的父亲，而无需记录它的孩子是什么，解决了无法处理链式前向星/vector不方便删除的问题。 时间复杂度$O(n^2)$ 恭喜你，获得了40分的好成绩。 . 解法四 改名和改父亲一起上… emmmmmm？这分也是送的啊喂。 我们这里有两种做法，一是把上面两个做法拼接到一起$O(n^2)$，二是我们把原来的每个点做一层“映射”。在这里，我主要讲第二个做法，因为后面可能要用到。 什么叫再做一次映射呢？考虑这么做：我们给每一次加文件/文件夹操作产生的新文件再赋予一个编号，对于这个点的所有记录全部在这个编号下标下的数组操作。这样子，即使我们改变了一个点的名字，也仅仅只是改变点的名字-&gt;编号的映射关系而已，我们只要把旧的名字-&gt;编号的映射关系先删掉，然后再新增一个新的名字-&gt;编号的映射关系即可。 比如说，原来有一个文件夹叫&quot;192608&quot;，它所对应的点的编号为17，我们称这种关系为&quot;192608&quot;-&gt;17的映射。那如果我们把这个文件夹名字修改为&quot;114514&quot;，我们只需要把原有的映射关系删除，然后再新添加一条&quot;114514&quot;-&gt;17的映射即可。 文件名长度不超过6，因此这个映射关系可以直接使用一个数组来存。 时间复杂度$O(n \\cdot 100)$（树是随机的，最多只有100层） 恭喜你，获得了75分的好成绩。 . 解法五 这次文件名不全是数字了… 这… 这不是直接换成字符串就好了吗？ 之前我们提到的映射关系是数字到数字的映射，这里我们只用改为字符串到数字的映射即可。 因为文件名长度不超过25，因此**这个映射关系可以用char[N][25]**的方式来存。 每次输入一个文件名我们暴力匹配即可。 期望时间复杂度$O(n \\cdot 100)$ 干得不错，你又成功A掉了一道水题！ End？ . . . . 解法五 你是不是觉得这是一道辣鸡题，数据点分布毫无意义？ . 没错，这个菜鸡故意卡了暴力匹配。那四个点全部都是字符集只有“a,b”的串，导致失配长度都特别长，直接TLE。 所以说，时间复杂度为$O(n\\cdot 100 \\cdot 25)$ 恭喜你，拿到了80分的好成绩！ 解法六 所以说这毒瘤出题人出的毒瘤数据怎么处理啊啊啊啊 OK，我们来回忆一下字符串匹配算法有什么？暴力匹配，Trie树，KMP，哈希，AC自动机，后缀自动机 考虑到我们这里是多模式串，多匹配串，KMP，AC自动机失去了用处。 因此，这题我们可以考虑用Trie树来处理匹配问题。 当然，这个菜鸡出题者作为暴力党，肯定是不会写一个Trie树来干这种破事的。因此，我们考虑用hash来解决这个问题。 我们直接对每个串大力hash，算出来的hash结果再用刚刚的映射方法映射到编号。酱紫，我们可以用两层映射来解决这个破问题。 怎么存哈希值-&gt;原编号这个映射呢？这就是个技术活了。因为我们这里的hash值很大，很难用一个数组存下来。 这时候，我们有两种解决办法： 1. 哈希表 2. map 菜鸡出题人作为暴力主义的一份子，是懒得写hash表的。因此我们直接用map存每个字符串到编号的映射即可。 啥？map怎么用？看这个 时间复杂度$O(n*100)$ 干的不错，你又成功地A掉了一道水题。 代码在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;cstdio&gt;using namespace std;const int N=100000+1000;map &lt;string,int&gt; emap;int n,m;string str[N];int to,fa[N],type[N],cnt[N];//type:0:文件夹；1：文件long long size[N];void update(int now,int x,int x2)&#123; do &#123; now=fa[now]; size[now]+=x; cnt[now]+=x2; &#125;while(now!=0);&#125;bool Check(int x1,int x2)//检验x2是否为x1的子文件夹&#123; do &#123; x2=fa[x2]; if(x1==x2) return true; &#125;while(x2!=0); return false;&#125;int main()&#123;// freopen(&quot;file7.in&quot;,&quot;r&quot;,stdin);// freopen(&quot;file7a.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); emap[&quot;root&quot;]=0; str[0]=&quot;root&quot;; for(int i=1;i&lt;=n;i++) &#123; //cerr&lt;&lt;i&lt;&lt;endl; int op; scanf(&quot;%d&quot;,&amp;op); if(op==1) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; if(emap.count(s1)==0 or type[emap[s1]]==1 or emap.count(s2)!=0) &#123; printf(&quot;Error\\n&quot;); continue; &#125; emap[s2]=++to,type[to]=0,fa[to]=emap[s1]; str[to]=s2; printf(&quot;Success\\n&quot;); &#125; if(op==2) &#123; string s1,s2; int x; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;x; if(emap.count(s1)==0 or type[emap[s1]]==1 or emap.count(s2)!=0) &#123; printf(&quot;Error\\n&quot;); continue; &#125; emap[s2]=++to,type[to]=1,fa[to]=emap[s1],size[to]=x,cnt[to]=1; str[to]=s2; update(to,size[to],1); printf(&quot;Success\\n&quot;); &#125; if(op==3) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; if(emap.count(s1)==0 or emap.count(s2)!=0) &#123; printf(&quot;Error\\n&quot;); continue; &#125; emap[s2]=emap[s1]; emap.erase(s1); str[emap[s2]]=s2; printf(&quot;Success\\n&quot;); &#125; if(op==4) &#123; string s1; cin&gt;&gt;s1; if(emap.count(s1)==0 or type[emap[s1]]==1) &#123; printf(&quot;Error\\n&quot;); continue; &#125; printf(&quot;%d\\n&quot;,cnt[emap[s1]]); &#125; if(op==5) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; if(emap.count(s1)==0 or emap.count(s2)==0 or type[emap[s2]]==1 or s1==s2 or Check(emap[s1],emap[s2])==true) &#123; printf(&quot;Error\\n&quot;); continue; &#125; update(emap[s1],-size[emap[s1]],-cnt[emap[s1]]); fa[emap[s1]]=emap[s2]; update(emap[s1],size[emap[s1]],cnt[emap[s1]]); printf(&quot;Success\\n&quot;); &#125; if(op==6) &#123; string s1; cin&gt;&gt;s1; if(emap.count(s1)==0 or type[emap[s1]]==1) &#123; printf(&quot;Error\\n&quot;); continue; &#125; printf(&quot;%lld\\n&quot;,size[emap[s1]]); &#125; if(op==7) &#123; string s1; cin&gt;&gt;s1; if(emap.count(s1)==0 or type[emap[s1]]==0) &#123; printf(&quot;Error\\n&quot;); continue; &#125; cout&lt;&lt;str[fa[emap[s1]]]&lt;&lt;endl; &#125; &#125; return 0;&#125; True End？ 事实上，上面的那个做法已经可以成功的A掉这道题了。 但是，这题的数据是随机的，总让人有水题的感觉，那我们加强一下？我们数据不随机。 … 解法七 这里需要用到高级数据结构的知识，NOIp选手们请绕道行车/小心驾驶。翻车了也不要紧，我敢打包票NOIp绝对不会考这种数据结构（5年内） 我们发现，这里动态连边是不是让人有一种LCT的感觉？ 对了！这题的确可以用LCT来解决…吗？ 这题维护子树？LCT能维护子树？ LCT当然不能维护子树啊。问题是，这题看上去需要维护子树，实际上真的需要吗？ 考虑我们维护贡献的时候，是维护它到根的一条链的。 诶？因此，LCT是可以通过维护链来间接解决这道题的。我们直接在每个点上对应的维护它的$size,cnt$,连边的时候暴力打标记，暴力pushdown标记即可。 啥？你说你不会LCT？如果你会splay并且把NOIp的芝士都差不多过了一遍，可以戳这里 时间复杂度：真·$O(nlogn)$（但是因为splay常数巨大，这里的复杂度我们基本上可以再乘上一个$logn$） True End 事实上呢，这题的确比NOIp中的模拟题稍微难那么一点点，但是把我们学过的知识综合起来，还是勉强可以做的。如果你仔细观察数据点的分布，你会发现送了很多很多的部分分，而且数据点的数据范围是对你的解题有引导作用的，它会逐步带领你走向正解。 以及，真寻酱很感谢你帮她写的文件系统，并奖励了你一瓶神秘小♂药♂水","categories":[{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"},{"name":"模拟","slug":"模拟","permalink":"http://www.goldenpotato.cn/categories/%E6%A8%A1%E6%8B%9F/"},{"name":"NNEZ","slug":"NNEZ","permalink":"http://www.goldenpotato.cn/categories/NNEZ/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P1552] [APIO2012]派遣","slug":"luogu-p1552-apio2012派遣","date":"2019-03-15T01:47:38.000Z","updated":"2019-03-15T01:47:38.000Z","comments":true,"path":"2019/03/15/luogu-p1552-apio2012派遣/","permalink":"http://www.goldenpotato.cn/2019/03/15/luogu-p1552-apio2012%E6%B4%BE%E9%81%A3/","excerpt":"","text":"题面 APIO2012 派遣 Solution 这是一道左偏树的模板题，不会左偏树的可以戳这里 显然，我们可以发现对于同一颗子树，我们想让取的人尽可能便宜，如果说目前为止取的价格超过$C$,就优先把贵的人先丢掉。 因此，我们考虑用左偏树来维护这个东西。对于每一个人，我们都建一颗以价格为关键字的大根堆。考虑从下往上合并，一旦堆的元素总和超过$C$就不断弹栈，弹到合法为止。然后我们算一下$l_i*sum$，取个最大值就好。 时间复杂度$O(nlogn)$ 就酱，我们就可以把这道题切掉啦(ﾉﾟ∀ﾟ)ﾉ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Luogu P1552 [APIO2012]派遣//Mar,15th,2019//左偏树水题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;struct LST&#123; int fa[N],son[N][2],dis[N],w[N]; long long sum[N],size[N]; inline void update(int x) &#123; sum[x]=sum[son[x][0]]+sum[son[x][1]]+w[x]; size[x]=size[son[x][0]]+size[son[x][1]]+1; &#125; int Merge(int x,int y) &#123; if(x==0 or y==0) return x+y; if(w[x]&gt;w[y]) swap(x,y); son[y][1]=Merge(x,son[y][1]); fa[son[y][1]]=y; update(y); if(dis[son[y][1]]&gt;dis[son[y][0]]) swap(son[y][0],son[y][1]); dis[y]=dis[son[y][1]]+1; return y; &#125; int Pop(int x) &#123; fa[x]=Merge(son[x][0],son[x][1]); return fa[x]; &#125;&#125;lst;vector &lt;int&gt; e[N];long long c[N],l[N],size[N],n,m;int root[N];long long ans;void dfs(int now)&#123; for(int i=0;i&lt;int(e[now].size());i++) &#123; dfs(e[now][i]); root[now]=lst.Merge(root[now],root[e[now][i]]); &#125; while(root[now]!=0 and lst.sum[root[now]]&gt;m) root[now]=lst.Pop(root[now]); if(root[now]!=0) ans=max(ans,l[now]*lst.size[root[now]]);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=n;i++) &#123; int fa=read();c[i]=read(),l[i]=read(); e[fa].push_back(i); size[i]=1; root[i]=i,lst.w[i]=lst.sum[i]=c[i],lst.size[i]=1; &#125; dfs(1); printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"左偏树","slug":"左偏树","permalink":"http://www.goldenpotato.cn/categories/%E5%B7%A6%E5%81%8F%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P2157][SDOI2009]学校食堂","slug":"luogu-p2157sdoi2009学校食堂","date":"2019-03-12T02:09:07.000Z","updated":"2019-03-12T02:09:07.000Z","comments":true,"path":"2019/03/12/luogu-p2157sdoi2009学校食堂/","permalink":"http://www.goldenpotato.cn/2019/03/12/luogu-p2157sdoi2009%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82/","excerpt":"","text":"题面 SDOI2009 学校食堂 Solution 这是一道状压妙题。 首先，因为后面的东西能提到前面来做，导致了严重的后效性。为了消除这个后效性，考虑用状压来处理这个问题。 我们可以发现最多的提前量很小，只有7，考虑这样设： 设$f[i][j][k]$表示$[1,i-1]$已经完成了，从$i$开始往后7个的完成状态为$j$，上一个完成的相对$i-1$的位置为k。 转移比较正常：我们枚举一下下一个选哪一个，如果$[i,x]$会被新完成，就进到下$x$位。 我们这里的枚举要非常小心：这里枚举下一个能不能选有一个重要的限制：一路过来，一定要检查当前要选的这个能否提到没有选过的前面。 就酱，我们及就可以在理论上 AC这道题啦(*´ﾟ∀ﾟ｀)ﾉ 当然，我们很有可能因为众多的细节调个半天 Code 本题细节较多，具体细节请看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=1000+10;const int M=(1&lt;&lt;8)+50;const int K=20;int f[N][M][K],a[N],b[N];int n,m;inline int real(int x,int k)&#123; return x+k-8;&#125;inline int w(int x,int y)&#123; if(x==0) return 0;//要专门特判第一个转移 return a[x]^a[y];&#125;int main()&#123; //freopen(&quot;2157.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;2157.out&quot;,&quot;w&quot;,stdout); //freopen(&quot;err.out&quot;,&quot;w&quot;,stderr); int T=read(); for(;T&gt;0;T--) &#123; memset(f,0x3f,sizeof f); n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),b[i]=read(); m=1&lt;&lt;8; b[0]=0x3f3f3f3f; f[1][0][8]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;m;j++) for(int k=0;k&lt;=16;k++) if(real(i-1,k)&gt;=0) &#123; //cerr&lt;&lt;i-1&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k-8&lt;&lt;&quot; :&quot;&lt;&lt;f[i][j][k]&lt;&lt;endl; int t=b[i]; for(int o=1;o&lt;=1+t and i-1+o&lt;=n;o++) &#123; if((j&gt;&gt;(o-1))%2==1) continue;//这个已经选过了 t=min(t,o-1+b[i-1+o]);//限制能取到的最大范围 int tmp=j+(1&lt;&lt;(o-1)),py=0; while(tmp%2==1) tmp/=2,py++;//计算进位 /*if(f[i+py][tmp][8+o-py]&gt;f[i][j][k]+w(real(i-1,k),i-1+o)) cerr&lt;&lt;i+py-1&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;&quot; &quot;&lt;&lt;o-py&lt;&lt;&quot; &quot;&lt;&lt;f[i][j][k]+w(real(i-1,k),i-1+o)&lt;&lt;endl;*/ f[i+py][tmp][8+o-py]=min(f[i+py][tmp][8+o-py],f[i][j][k]+w(real(i-1,k),i-1+o)); &#125; //cerr&lt;&lt;endl; &#125; int ans=0x3f3f3f3f; for(int i=0;i&lt;=16;i++) ans=min(ans,f[n+1][0][i]); printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://www.goldenpotato.cn/categories/%E7%8A%B6%E5%8E%8BDP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P2173] [ZJOI2012]网络","slug":"luogu-p2173-zjoi2012网络","date":"2019-03-11T10:58:09.000Z","updated":"2019-03-11T10:58:09.000Z","comments":true,"path":"2019/03/11/luogu-p2173-zjoi2012网络/","permalink":"http://www.goldenpotato.cn/2019/03/11/luogu-p2173-zjoi2012%E7%BD%91%E7%BB%9C/","excerpt":"","text":"题面 洛谷P2173 Solution 首先，我们可以发现颜色总数特别的少，再考虑到有改变边的颜色的操作，可以考虑用LCT来解决。 我们建$c$颗LCT，每颗LCT存每个颜色对应的边，splay记录每颗splay的MAX_w。 对于修改权值，考虑直接暴力修改每个颜色的LCT里对应的点的权值 对于修改颜色，我们可以暴力在每一颗LCT里面枚举来找一下有没有这条边，有的话就断掉，然后在对应的LCT里面连上。 对于查询，我们只需要把对应的LCT中对应的链split出来，然后直接输出MAX即可。 对于每个点同色连边不超过2，我们可以直接记录每个点每种颜色连了多少条边，在link和cut中维护一下即可。 时间复杂度$O(c\\cdot n \\cdot logm)$ 就酱，这题我们就切掉啦٩(๑&gt;◡&lt;๑)۶ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185//Luogu P2173 [ZJOI2012]网络//Mar,11th,2019//LCT暴力题#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1;char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=10000+100;const int M=10+2;int cnt[N][M];//记录每个点连出去的边的颜色数struct LCT&#123; int son[N][2],fa[N],lazy[N],MAX[N],w[N]; inline void update(int x) &#123; MAX[x]=max(MAX[son[x][0]],MAX[son[x][1]]); MAX[x]=max(MAX[x],w[x]); &#125; inline void mirror(int x) &#123; lazy[x]=!lazy[x]; swap(son[x][0],son[x][1]); &#125; inline void pushdown(int x) &#123; if(lazy[x]==true) &#123; mirror(son[x][0]); mirror(son[x][1]); lazy[x]=false; &#125; &#125; inline bool isRoot(int x) &#123; return (x!=son[fa[x]][0] and x!=son[fa[x]][1]); &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; fa[x]=z; if(isRoot(y)==false) son[z][y==son[z][1]]=x; fa[son[x][type]]=y,son[y][!type]=son[x][type]; fa[y]=x,son[x][type]=y; update(y),update(x); &#125; int mstack[N],top; void splay(int x) &#123; mstack[top=1]=x; for(int i=x;isRoot(i)==false;i=fa[i]) mstack[++top]=fa[i]; for(int i=top;i&gt;=1;i--) pushdown(mstack[i]); while(isRoot(x)==false) &#123; if(isRoot(fa[x])==false and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]]) rotate(fa[x],x==son[fa[x]][0]); rotate(x,x==son[fa[x]][0]); &#125; &#125; void Access(int x) &#123; for(int t=0;x!=0;t=x,x=fa[x]) splay(x),son[x][1]=t,fa[t]=x,update(x); &#125; int GetRoot(int x) &#123; Access(x),splay(x); while(son[x][0]!=0) x=son[x][0]; return x; &#125; void MakeRoot(int x) &#123; Access(x),splay(x); mirror(x); &#125; int Link(int x,int y,int c) &#123; if(cnt[x][c]==2 or cnt[y][c]==2) return 2; if(GetRoot(x)==GetRoot(y)) return 1; cnt[x][c]++,cnt[y][c]++; MakeRoot(x); fa[x]=y; return 0; &#125; void split(int x,int y)//y做原根，x作为LCT根 &#123; MakeRoot(y); Access(x); splay(x); &#125; int Cut(int x,int y,int w) &#123; split(x,y); if(y!=son[x][0] or fa[y]!=x or son[y][1]!=0) return 1; son[x][0]=fa[y]=0; update(x); cnt[x][w]--,cnt[y][w]--; return 0; &#125; void Change(int x,int num) &#123; split(x,x); w[x]=MAX[x]=num; &#125; int Query(int x,int y) &#123; split(x,y); if(GetRoot(x)!=y) return -1; return MAX[x]; &#125;&#125;lct[M]; int n,m,c,K;void Change1(int x,int num)&#123; for(int i=0;i&lt;c;i++) lct[i].Change(x,num);&#125;int Change2(int x,int y,int w)&#123; int statu=3; for(int i=0;i&lt;c;i++) if(lct[i].Cut(x,y,i)==0) &#123; statu=lct[w].Link(x,y,w); if(statu!=0) lct[i].Link(x,y,i); break; &#125; return statu;&#125;int Query(int x,int y,int w)&#123; return lct[w].Query(x,y);&#125;int main()&#123; //freopen(&quot;2173.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;2173.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(),c=read(),K=read(); for(int i=1;i&lt;=n;i++) Change1(i,read()); for(int i=1;i&lt;=m;i++) &#123; int x=read(),y=read(),w=read(); lct[w].Link(x,y,w); &#125; for(int i=1;i&lt;=K;i++) &#123; int op=read(); if(op==0) &#123; int x=read(),num=read(); Change1(x,num); &#125; else if(op==1) &#123; int x=read(),y=read(),w=read(),t=Change2(x,y,w); if(t==0) printf(&quot;Success.\\n&quot;); else if(t==1) printf(&quot;Error 2.\\n&quot;); else if(t==2) printf(&quot;Error 1.\\n&quot;); else printf(&quot;No such edge.\\n&quot;); &#125; else &#123; int w=read(),x=read(),y=read(); printf(&quot;%d\\n&quot;,Query(x,y,w)); &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu  P3285][SCOI2014]方伯伯的OJ","slug":"luogu-p3285scoi2014方伯伯的oj","date":"2019-03-11T06:59:29.000Z","updated":"2019-03-11T06:59:29.000Z","comments":true,"path":"2019/03/11/luogu-p3285scoi2014方伯伯的oj/","permalink":"http://www.goldenpotato.cn/2019/03/11/luogu-p3285scoi2014%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84oj/","excerpt":"","text":"题面 洛谷P3285 Solution 这是一道数据结构大暴力题。 我们可以很显然的发现对于询问排名，维护排名的操作，我们可以直接上一个维护下标的splay。 因为点的数量奇多，这让我们回想起NOIP2017 列队，我们可以用“splay 动态开点”这样的操作来解决，即一开始我们把所有信息全部压到一个点里面去（即一个点代表一段区间），需要的时候再用“拆点”把点拆开。 问题是这破题很让人讨厌地出了两个基于编号的操作。因为我们的splay是以下标做为权值来的，失去了维护编号的能力。 怎么办呢？我们可以考虑直接记录每个编号的点在splay中的下标。很不幸的是，这里的点的编号十分巨大，没法直接开桶来存。 但是，因为我们splay维护的是一个一个区间，我们可以考虑开一颗动态开点的线段树，然后在拆点/改编号的时候暴力区间维护一下即可。 时间复杂度$O(mlogn)$ 就酱，这题我们就切掉啦٩(๑&gt;◡&lt;๑)۶ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209//Luogu P3285 [SCOI2014]方伯伯的OJ//Mar,11th,2019//动态开点splay+动态开点线段树鬼畜题#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000*2+100;const int M=200000000;struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) int son[N*20][2],w[N*20],to; void Change(int l,int r,int num,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; w[now]=num; return; &#125; if(l&lt;=mid) &#123; if(son[now][0]==0) son[now][0]=++to,w[to]=w[now]; Change(l,r,num,son[now][0],now_l,mid); &#125; if(r&gt;mid) &#123; if(son[now][1]==0) son[now][1]=++to,w[to]=w[now]; Change(l,r,num,son[now][1],mid+1,now_r); &#125; &#125; int Query(int x,int now,int now_l,int now_r) &#123; if(now_l==now_r) return w[now]; if(x&lt;=mid) &#123; if(son[now][0]==0) return w[now]; else return Query(x,son[now][0],now_l,mid); &#125; else &#123; if(son[now][1]==0) return w[now]; else return Query(x,son[now][1],mid+1,now_r); &#125; &#125; #undef mid&#125;sgt;//编号-&gt;下标struct SPLAY&#123; #define root son[0][1] int son[N][2],fa[N],cnt[N],no[N],size[N],to; inline void update(int x) &#123; size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x]; &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; fa[x]=z,son[z][y==son[z][1]]=x; fa[son[x][type]]=y,son[y][!type]=son[x][type]; fa[y]=x,son[x][type]=y; update(y),update(x); &#125; void splay(int x,int to) &#123; while(fa[x]!=to) &#123; if(fa[fa[x]]!=to and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]]) rotate(fa[x],x==son[fa[x]][0]); rotate(x,x==son[fa[x]][0]); &#125; &#125; void split(int x,int K)//传入下标 &#123; splay(x,0); int t1=son[x][0],t2=son[x][1]; while(son[t1][1]!=0) t1=son[t1][1]; while(son[t2][0]!=0) t2=son[t2][0]; splay(t1,0); splay(t2,root); if(K!=1) &#123; son[x][0]=++to,fa[to]=x; no[to]=no[x],size[to]=cnt[to]=K-1; sgt.Change(no[to],no[to]+cnt[to]-1,to,1,1,M); &#125; if(K!=cnt[x]) &#123; son[x][1]=++to,fa[to]=x; no[to]=no[x]+K,size[to]=cnt[to]=cnt[x]-K; sgt.Change(no[to],no[to]+cnt[to]-1,to,1,1,M); &#125; no[x]=no[x]+K-1,cnt[x]=1; &#125; int GetKth(int x,int K)//返回下标 &#123; if(size[son[x][0]]&gt;=K) return GetKth(son[x][0],K); K-=size[son[x][0]]; if(K&lt;=cnt[x]) &#123; if(cnt[x]==1) &#123; splay(x,0); return x; &#125; split(x,K); splay(x,0); return x; &#125; K-=cnt[x]; return GetKth(son[x][1],K); &#125; int Change(int x,bool type)//传入编号 &#123; int t=sgt.Query(x,1,1,M),ans; splay(t,0); ans=size[son[t][0]]+x-no[t]+1; split(t,x-no[t]+1); if(son[t][0]!=0 or son[t][1]!=0) split(t,1); if(type==0) &#123; son[fa[t]][t==son[fa[t]][1]]=0; update(fa[t]); splay(1,0); int now=son[root][1]; while(son[now][0]!=0) now=son[now][0]; son[now][0]=t,fa[t]=now; update(now),splay(now,0); &#125; else &#123; son[fa[t]][t==son[fa[t]][1]]=0; update(fa[t]); splay(3,0); int now=son[root][0]; while(son[now][1]!=0) now=son[now][1]; son[now][1]=t,fa[t]=now; update(now),splay(now,0); &#125; return ans; &#125; int Change2(int x,int y)//传入编号 &#123; int t=sgt.Query(x,1,1,M); split(t,x-no[t]+1); sgt.Change(y,y,t,1,1,M); no[t]=y; splay(t,0); return size[son[t][0]]+1; &#125; int Query(int K) &#123; return no[GetKth(root,K)]; &#125; void Init(int n) &#123; root=++to,fa[root]=0; son[root][1]=++to,fa[to]=root,cnt[to]=size[to]=n,no[to]=1; sgt.to=1; sgt.Change(1,n,to,1,1,M); son[to][1]=to+1,fa[to+1]=to,to++; update(to),update(to-1),update(root); &#125; void Print(int now) &#123; if(now==0) return; Print(son[now][0]); cout&lt;&lt;&quot;no:&quot;&lt;&lt;now&lt;&lt;&quot; [&quot;&lt;&lt;no[now]&lt;&lt;&quot;,&quot;&lt;&lt;no[now]+cnt[now]-1&lt;&lt;&quot;] &quot;&lt;&lt;&quot;size:&quot;&lt;&lt;size[now]&lt;&lt;&quot; cnt:&quot;&lt;&lt;cnt[now]&lt;&lt;&quot; sonl&amp;r:&quot;&lt;&lt;son[now][0]&lt;&lt;&quot; &quot;&lt;&lt;son[now][1]&lt;&lt;endl; Print(son[now][1]); &#125; #undef root&#125;splay;int n,m;int main()&#123; n=read(),m=read(); splay.Init(n); int ans=0; for(int i=1;i&lt;=m;i++) &#123; int op=read(),x=read()-ans; if(op==1) &#123; int y=read()-ans; printf(&quot;%d\\n&quot;,ans=splay.Change2(x,y)); &#125; else if(op==2) printf(&quot;%d\\n&quot;,ans=splay.Change(x,0)); else if(op==3) printf(&quot;%d\\n&quot;,ans=splay.Change(x,1)); else printf(&quot;%d\\n&quot;,ans=splay.Query(x)); //ans=0;//RTC //splay.Print(splay.son[0][1]); //cerr&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"splay","slug":"splay","permalink":"http://www.goldenpotato.cn/categories/splay/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P3174] [HAOI2009]毛毛虫","slug":"luogu-p3174-haoi2009毛毛虫","date":"2019-03-11T06:47:01.000Z","updated":"2019-03-11T06:47:01.000Z","comments":true,"path":"2019/03/11/luogu-p3174-haoi2009毛毛虫/","permalink":"http://www.goldenpotato.cn/2019/03/11/luogu-p3174-haoi2009%E6%AF%9B%E6%AF%9B%E8%99%AB/","excerpt":"","text":"题面 洛谷P3174 Solution 我们不难发现，一条“毛毛虫”一定是由一条主链外加主链的点所连到的点构成的。 那既然是一条链，它的形态无外乎以下两种： 因此，我们可以直接枚举最上面的那个点，他做为根会产生的最大的答案即为其孩子的最大答案与次大答案之和再减去多算的一小部分即可。(具体转移可以看看代码，要做点简单的分类讨论) 时间复杂度$O(n)$ 就酱，这题我们就切掉啦(*´ﾟ∀ﾟ｀)ﾉ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Luogu P3174 [HAOI2009]毛毛虫//Mar,10th,2019//树形DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=300000+100;vector &lt;int&gt; e[N];int n,m;bool vis[N];int f1[N],f2[N],ans;void dfs(int now)&#123; vis[now]=true; f1[now]=e[now].size()+1; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; dfs(e[now][i]); if(f1[e[now][i]]+int(e[now].size())-1 &gt;= f1[now]) &#123; f2[now]=f1[now]; f1[now]=f1[e[now][i]]+e[now].size()-1; &#125; else if(f1[e[now][i]]+int(e[now].size())-1 &gt; f2[now]) f2[now]=f1[e[now][i]]+e[now].size()-1; &#125; if(f2[now]==0) ans=max(ans,f1[now]); else ans=max(ans,f1[now]+f2[now]-int(e[now].size())-1);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; dfs(1); printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E4%BD%8DDP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P1501] [国家集训队]Tree II","slug":"luogu-p1501-国家集训队tree-ii","date":"2019-03-11T04:18:23.000Z","updated":"2019-03-11T04:18:23.000Z","comments":true,"path":"2019/03/11/luogu-p1501-国家集训队tree-ii/","permalink":"http://www.goldenpotato.cn/2019/03/11/luogu-p1501-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9Ftree-ii/","excerpt":"","text":"题面 洛谷 P1501 Solution 这是一道肥肠考验LCT基本功的一道题。 口胡起来是很容易的：对于每一个加/乘操作，我们把对应的链split出来，然后打标记即可；Link/Cut是基本操作；查询的话我们也是把对应的链split出来，然后直接输出根的sum即可。 这里的打标记和线段树II那道题非常像，不会的同学可以先去做线段树II。 都在写LCT了，怎么可能没打过线段树II。我们只需要像线段树II那样pushdown并处理sum即可。 口胡是口胡，打起来就是另外一码事了 这里列出我写出的锅，大家写的时候可以考虑注意以下几点： 1. $(5w*5w)$会爆int的，请开longlong 。 2. 我们在$pushdown$算各种标记、sum的时候一定要注意膜$p$，小心爆longlong。 3. LCT的rotate和正常的splay的rotate不一样，我们要特判一下z是否是另外一颗splay的，不能直接无脑rotate。当然，这种锅也只有我这种蒟蒻才会错 4. 先cut再link，避免连出环来。 5. 没了 Code 数据生成器 不包含link,cut操作 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;const int N=10;const int MAX=50000;int main()&#123; srand(time(NULL)); freopen(&quot;1501.in&quot;,&quot;w&quot;,stdout); int n=N,m=10*N; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; for(int i=2;i&lt;=n;i++) &#123; int to=rand()%i; if(to==0) to=1; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;endl; &#125; for(int i=1;i&lt;=m;i++) &#123; int op=rand()%3; if(op==0) cout&lt;&lt;&quot;+ &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%MAX+1&lt;&lt;endl; else if(op==1) cout&lt;&lt;&quot;* &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%MAX+1&lt;&lt;endl; else cout&lt;&lt;&quot;/ &quot;&lt;&lt;rand()%n+1&lt;&lt;&quot; &quot;&lt;&lt;rand()%n+1&lt;&lt;endl; &#125; return 0;&#125; 正解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Luogu P1501 [国家集训队]Tree II //Mar,10th,2019//LCT+线段树II#include&lt;iostream&gt;#include&lt;cstdio&gt;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;using namespace std;const int N=100000+1000;const long long poi=51061;struct LCT&#123; long long son[N][2],fa[N],w[N],sum[N],plus[N],take[N],lazy[N],size[N]; inline void Mirror(int x) &#123; lazy[x]=!lazy[x]; swap(son[x][0],son[x][1]); &#125; inline void pushdown(int x) &#123; if(lazy[x]==true) &#123; Mirror(son[x][0]); Mirror(son[x][1]); lazy[x]=false; &#125; if(son[x][0]!=0) &#123; w[son[x][0]]=(w[son[x][0]]*take[x]+plus[x])%poi; take[son[x][0]]=take[son[x][0]]*take[x]%poi; plus[son[x][0]]=(plus[son[x][0]]*take[x]+plus[x])%poi; sum[son[x][0]]=(sum[son[x][0]]*take[x]+size[son[x][0]]*plus[x])%poi; &#125; if(son[x][1]!=0) &#123; w[son[x][1]]=(w[son[x][1]]*take[x]+plus[x])%poi; take[son[x][1]]=(take[son[x][1]]*take[x])%poi; plus[son[x][1]]=(plus[son[x][1]]*take[x]+plus[x])%poi; sum[son[x][1]]=(sum[son[x][1]]*take[x]+size[son[x][1]]*plus[x])%poi; &#125; plus[x]=0,take[x]=1; &#125; inline void update(int x) &#123; size[0]=sum[0]=0; sum[x]=(sum[son[x][0]]+sum[son[x][1]]+w[x])%poi; size[x]=(size[son[x][0]]+size[son[x][1]]+1); &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; fa[x]=z; if(IsRoot(y)==false) son[z][y==son[z][1]]=x; fa[son[x][type]]=y,son[y][!type]=son[x][type]; fa[y]=x,son[x][type]=y; update(y),update(x); &#125; bool IsRoot(int x) &#123; return (x!=son[fa[x]][0] and x!=son[fa[x]][1]); &#125; int mstack[N],top; void splay(int x) &#123; mstack[top=1]=x; for(int now=x;IsRoot(now)==false;now=fa[now]) mstack[++top]=fa[now]; for(;top&gt;0;top--) pushdown(mstack[top]); while(IsRoot(x)==false) &#123; if(IsRoot(fa[x])==false and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]]) rotate(fa[x],x==son[fa[x]][0]), rotate(x,x==son[fa[x]][0]); else rotate(x,x==son[fa[x]][0]); &#125; &#125; void Access(int x) &#123; for(int t=0;x!=0;t=x,x=fa[x]) splay(x),son[x][1]=t,fa[t]=x,update(x); &#125; int GetRoot(int x) &#123; Access(x),splay(x); while(son[x][0]!=0) pushdown(x),x=son[x][0]; splay(x); return x; &#125; void MakeRoot(int x) &#123; Access(x); splay(x); Mirror(x); &#125; void Link(int x,int y) &#123; if(GetRoot(x)==GetRoot(y)) return; MakeRoot(x); fa[x]=y; &#125; void Split(int x,int y) &#123; MakeRoot(y); Access(x),splay(x); &#125; void Cut(int x,int y) &#123; Split(x,y); if(y!=son[x][0] or fa[y]!=x) return; son[x][0]=0,fa[y]=0; update(x); &#125; void Add(int x,int y,long long num) &#123; Split(x,y); plus[x]=num%poi,w[x]=(w[x]+num)%poi,sum[x]=(sum[x]+size[x]*num)%poi; &#125; void Take(int x,int y,long long num) &#123; Split(x,y); take[x]=num%poi,w[x]=(w[x]*num)%poi,sum[x]=sum[x]*num%poi; &#125; long long Query(int x,int y) &#123; Split(x,y); return sum[x]%poi; &#125;&#125;lct;int n,q;int main()&#123; n=read(),q=read(); for(int i=1;i&lt;=n;i++) lct.take[i]=lct.w[i]=lct.sum[i]=lct.size[i]=1; for(int i=1;i&lt;n;i++) &#123; int s=read(),t=read(); lct.Link(s,t); &#125; char OP[5]; for(int i=1;i&lt;=q;i++) &#123; scanf(&quot;%s&quot;,OP+1); if(OP[1]==&#x27;+&#x27;) &#123; long long u=read(),v=read(),x=read()%poi; lct.Add(u,v,x); &#125; else if(OP[1]==&#x27;-&#x27;) &#123; long long u1=read(),v1=read(),u2=read(),v2=read(); lct.Cut(u1,v1); lct.Link(u2,v2); &#125; else if(OP[1]==&#x27;*&#x27;) &#123; long long u=read(),v=read(),x=read()%poi; lct.Take(u,v,x); &#125; else &#123; long long u=read(),v=read(); printf(&quot;%lld\\n&quot;,lct.Query(u,v)); &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P1110] [ZJOI2007]报表统计","slug":"luogu-p1110-zjoi2007报表统计","date":"2019-03-08T04:08:55.000Z","updated":"2019-03-08T04:08:55.000Z","comments":true,"path":"2019/03/08/luogu-p1110-zjoi2007报表统计/","permalink":"http://www.goldenpotato.cn/2019/03/08/luogu-p1110-zjoi2007%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"题面 洛谷P1110 Solution 我们看到这道题，我们不妨想把处于同一个点的骑士全部丢到一个小根堆左偏树里面。这样子，我们从下往上合并，合并完就去检查一下根是否满足当前城市的要求，一直弹根弹到满足要求为止。 至于能力的变化，这里的操作要求无外乎乘法和加法。因此，我们可以像线段树II那道题那样做两个标记，处理一下即可。每次合并、弹根之前都pushdown标记。 就酱，这题就被我们切掉啦~(*´ﾟ∀ﾟ｀)ﾉ 时间复杂度$O(nlogm)$ Code 数据生成器 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;const int N=10;const int MAX=10;using namespace std;int mrand()&#123; int x=rand()%MAX,f=rand()%2; if(f==0) f=-1; return x*f;&#125;int main()&#123; srand(time(NULL)); freopen(&quot;3261.in&quot;,&quot;w&quot;,stdout); int n=N,m=N; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;mrand()&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(int i=2;i&lt;=n;i++) &#123; int to=rand()%i; if(to==0) to=1; cout&lt;&lt;to&lt;&lt;&quot; &quot;&lt;&lt;rand()%2&lt;&lt;&quot; &quot;&lt;&lt;mrand()&lt;&lt;endl; &#125; for(int i=1;i&lt;=m;i++) cout&lt;&lt;mrand()&lt;&lt;&quot; &quot;&lt;&lt;rand()%n+1&lt;&lt;endl; return 0;&#125; 正解 我因为用了vector存边常数爆大，不吸氧会T一个点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//Luogu P3261 [JLOI2015]城池攻占//Mar,8th,2019//左偏树+线段树II#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=300000+1000;struct LST&#123; long long plus[N],take[N],w[N],son[N][2],dis[N],fa[N]; inline void pushdown(int x)//传入位置 &#123; if(son[x][0]!=0) &#123; w[son[x][0]]=w[son[x][0]]*take[x]+plus[x]; take[son[x][0]]*=take[x]; plus[son[x][0]]=plus[son[x][0]]*take[x]+plus[x]; &#125; if(son[x][1]!=0) &#123; w[son[x][1]]=w[son[x][1]]*take[x]+plus[x]; take[son[x][1]]*=take[x]; plus[son[x][1]]=plus[son[x][1]]*take[x]+plus[x]; &#125; plus[x]=0,take[x]=1; &#125; int findFather(int x)//传入位置 &#123; if(fa[x]==0) return x; return fa[x]=findFather(fa[x]); &#125; int Merge(int x,int y)//传入根的位置 &#123; if(x==0 or y==0) return x+y; if(w[x]&lt;w[y]) swap(x,y); pushdown(x),pushdown(y); son[y][1]=Merge(x,son[y][1]),fa[son[y][1]]=y; if(dis[son[y][0]]&lt;dis[son[y][1]]) swap(son[y][0],son[y][1]); dis[y]=dis[son[y][1]]+1; return y; &#125; int Pop(int x)//返回新的根的位置 &#123; pushdown(x); fa[x]=Merge(son[x][0],son[x][1]); return fa[x]; &#125; void Mark(int x,long long ntake,long long nplus) &#123; pushdown(x); w[x]=w[x]*ntake+nplus; take[x]=ntake,plus[x]=nplus; &#125;&#125;lst;int n,m,root[N],ans1[N],ans2[N];long long a[N],v[N],h[N];vector &lt;int&gt; e[N];int depth[N],from[N];void dfs(int now)&#123; for(int i=0;i&lt;int(e[now].size());i++) &#123; depth[e[now][i]]=depth[now]+1; dfs(e[now][i]); if(root[e[now][i]]!=0) root[now]=lst.Merge(root[now],root[e[now][i]]); &#125; while(root[now]!=0 and lst.w[root[now]]&lt;h[now]) &#123; ans1[now]++,ans2[root[now]]=depth[from[root[now]]]-depth[now]; root[now]=lst.Pop(root[now]); &#125; if(v[now]==0) lst.Mark(root[now],1,a[now]); else lst.Mark(root[now],a[now],0);&#125;int main()&#123; int t=clock(); freopen(&quot;3261.in&quot;,&quot;r&quot;,stdin); freopen(&quot;3261.out&quot;,&quot;w&quot;,stdout); int size = 256 &lt;&lt; 20; char *p = (char*)malloc(size) + size; __asm__(&quot;movl %0, %%esp\\n&quot; :: &quot;r&quot;(p)); n=read(),m=read(); for(int i=1;i&lt;=n;i++) h[i]=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=2;i&lt;=n;i++) &#123; e[read()].push_back(i); v[i]=read(),a[i]=read(); &#125; for(int i=1;i&lt;=m;i++) &#123; long long w=read(); from[i]=read(); lst.w[i]=w; if(root[from[i]]==0) root[from[i]]=i; else root[from[i]]=lst.Merge(root[from[i]],i); &#125; depth[1]=1; dfs(1); while(root[1]!=0) &#123; ans2[root[1]]=depth[from[root[1]]]; root[1]=lst.Pop(root[1]); &#125; for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,ans1[i]); for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans2[i]); cerr&lt;&lt;clock()-t; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"左偏树","slug":"左偏树","permalink":"http://www.goldenpotato.cn/categories/%E5%B7%A6%E5%81%8F%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P4768] [NOI2018]归程","slug":"luogu-p4768-noi2018归程","date":"2019-03-07T09:55:50.000Z","updated":"2019-03-07T09:55:50.000Z","comments":true,"path":"2019/03/07/luogu-p4768-noi2018归程/","permalink":"http://www.goldenpotato.cn/2019/03/07/luogu-p4768-noi2018%E5%BD%92%E7%A8%8B/","excerpt":"","text":"题面 [Luogu P4768] [NOI2018]归程 Solution 这题可能要用到Kruskal重构树的相关知识，如果有需求的同学可以看这里 首先，根据我们之前在运输计划那道题的经验，我们会发现我们开车能经过的边一定在以海拔为关键字的最大生成树上。 根据Kruskal重构树的性质：Kruskal重构树是一个堆，我们可以考虑这样做： 我们先把Kruskal重构树按每条路的海拔从大到小建出来，那么从某个点出发能开车到达的点一定是这个点的某个祖先的子树内的所有的点，这个很好理解，因为Kruskal重构树是一个堆，那么堆之内的点的路一定&gt;堆顶，堆外的点一定&lt;=堆顶 所以说，我们只需要先把每个点到1号节点的最短路先求出来，每次我们从出发点向上倍增，找到刚好&gt;积水线的点，然后找到这个点的子树内距离1最短的点即可，这个用简单的树形DP即可完成。 时间复杂度$O(mlogn)$ 就酱，这题就被我们切掉啦~(*´ﾟ∀ﾟ｀)ﾉ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=2*200000+2000;const int M=400000+1000;struct EDGE&#123; int s,to,l,h;&#125;e1[M];vector &lt;EDGE&gt; e2[N];//e2需要初始化int n,m;long long dis[N];struct SIT&#123; int to; long long w; SIT (int x,long long y) &#123; to=x,w=y; &#125; friend bool operator &lt; (SIT x,SIT y) &#123; return x.w&gt;y.w; &#125;&#125;;priority_queue &lt;SIT&gt; mqueue;void dj()&#123; static bool vis[N]; memset(vis,0,sizeof vis); memset(dis,0x3f,sizeof dis); dis[1]=0,mqueue.push(SIT(1,0)); while(mqueue.empty()==false) &#123; int now=mqueue.top().to; mqueue.pop(); if(vis[now]==true) continue; vis[now]=true; for(int i=0;i&lt;int(e2[now].size());i++) if(dis[e2[now][i].to] &gt; dis[now]+e2[now][i].l) &#123; dis[e2[now][i].to]=dis[now]+e2[now][i].l; mqueue.push(SIT(e2[now][i].to,dis[e2[now][i].to])); &#125; &#125;&#125;int fa[N][21],depth[N],cnt;//fa需要初始化vector &lt;int&gt; e3[N];//e3需要初始化int MIN[N],sl[N];//存放距离最小值位置bool cmp(EDGE x,EDGE y)&#123; return x.h&gt;y.h;&#125;int FindFather(int x)&#123; if(fa[x][0]==0) return x; return fa[x][0]=FindFather(fa[x][0]);&#125;void Kruskal()&#123; for(int i=1;i&lt;=n;i++) MIN[i]=i; sort(e1+1,e1+1+m,cmp); cnt=n; for(int i=1;i&lt;=m;i++) &#123; int fa1=FindFather(e1[i].s),fa2=FindFather(e1[i].to); if(fa1==fa2) continue; fa[fa1][0]=fa[fa2][0]=++cnt; sl[cnt]=e1[i].h,MIN[cnt]=cnt; e3[cnt].push_back(fa1),e3[cnt].push_back(fa2); &#125; fa[cnt][0]=cnt;&#125;void dfs(int now)&#123; for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;int(e3[now].size());i++) &#123; depth[e3[now][i]]=depth[now]+1; fa[e3[now][i]][0]=now; dfs(e3[now][i]); if(dis[MIN[e3[now][i]]]&lt;dis[MIN[now]]) MIN[now]=MIN[e3[now][i]]; &#125;&#125;int Query(int x,int h)&#123; for(int i=20;i&gt;=0;i--) if(sl[fa[x][i]]&gt;h) x=fa[x][i]; return dis[MIN[x]];&#125;int main()&#123; int T=read(); for(;T&gt;0;T--) &#123; n=read(),m=read(); for(int i=0;i&lt;=2*n+10;i++) e2[i].clear(),e2[i].reserve(4); memset(fa,0,sizeof fa); for(int i=0;i&lt;=2*n+10;i++) e3[i].clear(),e3[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; e1[i].s=read(),e1[i].to=read(),e1[i].l=read(),e1[i].h=read(); e2[e1[i].s].push_back(e1[i]); swap(e1[i].s,e1[i].to); e2[e1[i].s].push_back(e1[i]); &#125; dj(); Kruskal(); dfs(cnt); long long ans=0,q=read(),K=read(),S=read(); for(int i=1;i&lt;=q;i++) &#123; long long v=read(),p=read(); v=(v+K*ans-1)%n+1,p=(p+K*ans)%(S+1); printf(&quot;%lld\\n&quot;,ans=Query(v,p)); &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"http://www.goldenpotato.cn/categories/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"倍增","slug":"倍增","permalink":"http://www.goldenpotato.cn/categories/%E5%80%8D%E5%A2%9E/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Kruskal重构树学习笔记","slug":"kruskal重构树学习笔记","date":"2019-03-07T09:43:16.000Z","updated":"2019-03-07T09:43:16.000Z","comments":true,"path":"2019/03/07/kruskal重构树学习笔记/","permalink":"http://www.goldenpotato.cn/2019/03/07/kruskal%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"为什么要学Kruskal重构树 有时候，题目让我们多次求一个图的两点路径上最小值最大/最大值最小是多少。这种时候，根据一个比较显然的结论，我们可以把问题搬到一颗最小/最大生成树里面去做。 这个时候，我们当然可以倍增来搞这个问题。但在这里，我想向大家引入一种新的数据结构，它是基于kruskal求生成树的算法改来的，因此被称为Kruskal重构树。 什么是Kruskal重构树 这张图可以一目了然的介绍Kruskal重构树： 图出自https://blog.csdn.net/wu_tongtong/article/details/77601523 怎么建Kruskal重构树 肥肠简单，我们在做Krusckal算法的时候，当我们要连边的时候，我们把这两个点连向一个新构建的点(在图中以方点表示)，然后把这两个点的fa设为那个方点，方点的权值为这条边的权值，继续做Kruskal即可。 代码可能更优表现力： 12345678910111213141516171819202122232425bool cmp(edge x,edge y)&#123; return x.w&lt;y.w;&#125;int fa[N],w[N],to;int FindFather(int x)&#123; if(fa[x]==0) return x; return fa[x]=FindFather(fa[x]);&#125;vector &lt;int&gt; e2[N];void Kruskal()&#123; sort(e+1,e+1+m,cmp); to=n; for(int i=n+1;i&lt;=2*n;i++) e2[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int fa1=FindFather(e[i].s),fa2=FindFather(e[i].t); if(fa1==fa2) continue; w[++to]=e[i].w,fa[fa1]=to,fa[fa2]=to; e2[to].push_back(fa1),e2[to].push_back(fa2); &#125;&#125; Kruskal重构树有什么性质 两个点在原图中的所有路径上某条路径中的最小值最大/最大值最小即为他们在Kruskal重构树上这两个点的LCA的权值 这是一个二叉树 树上权值满足堆的性质 (从我们构建过程中可以很简单的证明) Kruskal重构树相关题目 1.BZOJ 3732 真*模板题 2.NOI2018 归程 相关性质的简单应用 注：肥肠感谢julao lbc的教学","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"http://www.goldenpotato.cn/categories/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"[Luogu P3567] [POI2014]KUR-Couriers","slug":"luogu-p3567-poi2014kur-couriers","date":"2019-03-07T03:50:57.000Z","updated":"2019-03-07T03:50:57.000Z","comments":true,"path":"2019/03/07/luogu-p3567-poi2014kur-couriers/","permalink":"http://www.goldenpotato.cn/2019/03/07/luogu-p3567-poi2014kur-couriers/","excerpt":"","text":"题面 洛谷P3567 Solution 大水题啊，真没什么好讲的 我们考虑建一颗权值主席树，从左往右逐个插入。因为个数满足可减性，因此我们可以很方便的“扣”出$[L,R]$区间构成的主席树。接下来只需要在树上二分看一下有没有出现次数超过$K$的即可。 时间复杂度$O(nlogn)$ 就酱，这题就被我们切掉啦︿(￣︶￣)︿ Solution 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N=500000+100;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) static const int M=25*N; int size[M],son[M][2],to; inline void update(int now) &#123; size[now]=size[son[now][0]]+size[son[now][1]]; &#125; void Add(int now,int pre,int x,int now_l,int now_r) &#123; if(now_l==now_r) &#123; size[now]=size[pre]+1; return; &#125; if(x&lt;=mid) &#123; son[now][1]=son[pre][1]; Add(son[now][0]=++to,son[pre][0],x,now_l,mid); &#125; else &#123; son[now][0]=son[pre][0]; Add(son[now][1]=++to,son[pre][1],x,mid+1,now_r); &#125; update(now); &#125; int Query(int now,int pre,int x,int now_l,int now_r) &#123; if(now_l==now_r) return now_l; if(size[son[now][0]]-size[son[pre][0]]&gt;=x) return Query(son[now][0],son[pre][0],x,now_l,mid); else if(size[son[now][1]]-size[son[pre][1]]&gt;=x) return Query(son[now][1],son[pre][1],x,mid+1,now_r); return 0; &#125; #undef mid&#125;sgt;int root[N],n,m;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) &#123; int tmp=read(); sgt.Add(root[i]=++sgt.to,root[i-1],tmp,1,n); &#125; for(int i=1;i&lt;=m;i++) &#123; int l=read(),r=read(),mid=(r-l+1)/2+1; printf(&quot;%d\\n&quot;,sgt.Query(root[r],root[l-1],mid,1,n)); &#125; return 0;&#125;","categories":[{"name":"主席树","slug":"主席树","permalink":"http://www.goldenpotato.cn/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P4197] Peaks","slug":"luogu-p4197-peaks","date":"2019-03-07T03:43:01.000Z","updated":"2019-03-07T03:43:01.000Z","comments":true,"path":"2019/03/07/luogu-p4197-peaks/","permalink":"http://www.goldenpotato.cn/2019/03/07/luogu-p4197-peaks/","excerpt":"","text":"题面 洛谷P4197 Solution 这题的确是可以用库鲁斯卡尔重构树+主席树来搞，但是本蒟蒻太菜了并不会，因此只能给大家讲讲离线+splay启发式合并的搞法。 首先，我们考虑把询问离线下来并按限制从小到大排序。然后我们可以考虑把边一条一条插入到图里面去，直到某个询问的限制。这样子，问题就变为了询问某一个连通块的K小值，连通块可以合并。 这个问题就肥肠简单了，我们可以用各种各样的数据结构来处理，线段树合并，splay启发式合并都可以。 考虑到每个点期望加入$logn$次，时间复杂度为$O(nlogn)$ Code 我这题因为TLE调了很久，原因是我在查询的时候没有splay，导致势能分析失效，请各位读者引以为戒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180//Luogu P4197 Peaks//Mar,7th,2019//splay启发式合并#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int M=50*N;struct SPLAY&#123; #define root son[r][1] int son[M][2],size[M],cnt[M],fa[M],w[M],to,toUse[M],top; inline void update(int x) &#123; size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x]; &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; fa[x]=z,son[z][y==son[z][1]]=x; fa[son[x][type]]=y,son[y][!type]=son[x][type]; fa[y]=x,son[x][type]=y; update(y),update(x); &#125; void splay(int x,int to) &#123; while(fa[x]!=to) &#123; if(fa[fa[x]]!=to and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]]) rotate(fa[x],x==son[fa[x]][0]), rotate(x,x==son[fa[x]][0]); else rotate(x,x==son[fa[x]][0]); &#125; &#125; int newNode() &#123; if(top!=0) &#123; son[toUse[top]][0]=son[toUse[top]][1]=0; size[toUse[top]]=fa[toUse[top]]=cnt[toUse[top]]=w[toUse[top]]=0; return toUse[top--]; &#125; return ++to; &#125; void Insert(int num,int r) &#123; if(root==0) &#123; root=newNode(),fa[root]=r; w[root]=num,cnt[root]=1; update(root); return; &#125; int now=root,last=r; while(now!=0) &#123; if(w[now]==num) &#123; cnt[now]++,update(now); splay(now,r); return; &#125; last=now,now=son[now][num&gt;w[now]]; &#125; now=newNode(); fa[now]=last,son[last][num&gt;w[last]]=now; w[now]=num,cnt[now]=1,update(now); splay(now,r); &#125; int Query(int now,int r,int K) &#123; if(size[son[now][1]]&gt;=K) return Query(son[now][1],r,K); K-=(cnt[now]+size[son[now][1]]); if(K&lt;=0) &#123; splay(now,r); return w[now]; &#125; return Query(son[now][0],r,K); &#125; void dfs(int now,int r) &#123; if(now==0) return; for(int i=1;i&lt;=cnt[now];i++)//有可能一个点上有多个数字 Insert(w[now],r); dfs(son[now][0],r); dfs(son[now][1],r); toUse[++top]=now; &#125; #undef root&#125;splay;int fa[N],size[N],root[N];int FindFather(int x)&#123; if(fa[x]==0) return x; return fa[x]=FindFather(fa[x]);&#125;void Merge(int x,int y)&#123; if(FindFather(x)==FindFather(y)) return; if(size[FindFather(x)]&gt;size[FindFather(y)]) swap(x,y); splay.dfs(splay.son[root[FindFather(x)]][1],root[FindFather(y)]); //cerr&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;size[FindFather(x)]&lt;&lt;&quot; &quot;&lt;&lt;size[FindFather(y)]&lt;&lt;&quot; &quot;&lt;&lt;splay.size[splay.son[root[FindFather(y)]][1]]&lt;&lt;endl; size[FindFather(y)]+=size[FindFather(x)]; fa[FindFather(x)]=FindFather(y);&#125;struct edge&#123; int s,t,w; friend bool operator &lt; (edge x,edge y) &#123; return x.w&lt;y.w; &#125;&#125;e[M];struct Query&#123; int x,K,w,ans,no; friend bool operator &lt; (Query a,Query b) &#123; return a.w&lt;b.w; &#125;&#125;query[M];bool cmp(Query a,Query b)&#123; return a.no&lt;b.no;&#125;int Ask(int x,int K)&#123; if(size[FindFather(x)]&lt;K) return -1; return splay.Query(splay.son[root[FindFather(x)]][1],root[FindFather(x)],K);&#125;int n,m,q,h[N];int main()&#123; int t=clock(); freopen(&quot;4197.in&quot;,&quot;r&quot;,stdin); freopen(&quot;4197.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(),q=read(); for(int i=1;i&lt;=n;i++) h[i]=read(); for(int i=1;i&lt;=n;i++) root[i]=splay.newNode(),size[i]=1; for(int i=1;i&lt;=n;i++) splay.Insert(h[i],root[i]); for(int i=1;i&lt;=m;i++) e[i].s=read(),e[i].t=read(),e[i].w=read(); for(int i=1;i&lt;=q;i++) query[i].x=read(),query[i].w=read(),query[i].K=read(),query[i].no=i; sort(e+1,e+1+m); sort(query+1,query+1+q); int w_to=1; for(int i=1;i&lt;=q;i++) &#123; //cerr&lt;&lt;i&lt;&lt;endl; for(;e[w_to].w&lt;=query[i].w and w_to&lt;=m;w_to++) Merge(e[w_to].s,e[w_to].t); query[i].ans=Ask(query[i].x,query[i].K); &#125; sort(query+1,query+1+q,cmp); for(int i=1;i&lt;=q;i++) printf(&quot;%d\\n&quot;,query[i].ans); cerr&lt;&lt;clock()-t&lt;&lt;endl; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"splay","slug":"splay","permalink":"http://www.goldenpotato.cn/categories/splay/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P3302] [SDOI2013]森林","slug":"luogu-p3302-sdoi2013森林","date":"2019-03-07T03:34:51.000Z","updated":"2019-03-07T03:34:51.000Z","comments":true,"path":"2019/03/07/luogu-p3302-sdoi2013森林/","permalink":"http://www.goldenpotato.cn/2019/03/07/luogu-p3302-sdoi2013%E6%A3%AE%E6%9E%97/","excerpt":"","text":"题面 洛谷P3302 Solution 拿到这道题，我们不妨先想一下静态的树上K大怎么搞。 静态树上K大有两种办法，一是树链剖分+平衡树，二是主席树做链前缀和。前者的复杂度是$O(log^2n)$的，而后者只有$O(logn)$。 我们考虑把数字全部离散化，然后开权值主席树，每颗主席树记录从它出发到根的路上每个数字出现了多少个。接下来，我们只需要找到LCA。因为数字出现个数满足可减性，因此，我们是可以“扣”出从这个点到LCA的路径的，我们把两条路径合并到一颗主席树上，做树上二分即可。 接下来考虑如何处理边合并的问题。考虑启发式暴力合并。我们把小的那棵树合并到大的那棵树上，暴力重构小的那棵树的每个点的主席树，也暴力重构每个点的depth，fa来计算LCA即可。 启发式合并中，每个点的重构次数期望为$logn$次，因此，我们的总复杂度为$O(nlog^2n)$ 就酱，这题我们就切掉啦(～￣▽￣)～ Code 细节繁多，请各位dalao小心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//Luogu P3302 [SDOI2013]森林//Mar,6th,2019//主席树启发式合并维护动态树树链K大#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=80000+2000;struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) static const int M=400*N; int son[M][2],size[M],to; inline void update(int now) &#123; size[now]+=size[son[now][0]]+size[son[now][1]]; &#125; inline void Add(int now,int pre,int x,int now_l,int now_r) &#123; if(now_l==now_r) &#123; size[now]=size[pre]+1; return; &#125; if(x&lt;=mid) &#123; Add(son[now][0]=++to,son[pre][0],x,now_l,mid); son[now][1]=son[pre][1]; &#125; else &#123; Add(son[now][1]=++to,son[pre][1],x,mid+1,now_r); son[now][0]=son[pre][0]; &#125; update(now); &#125; int Query(int now1,int now2,int pre1,int pre2,int x,int now_l,int now_r) &#123; if(now_l==now_r) return now_l; if(x&lt;=size[son[now1][0]]-size[son[pre1][0]]+size[son[now2][0]]-size[son[pre2][0]]) return Query(son[now1][0],son[now2][0],son[pre1][0],son[pre2][0],x,now_l,mid); else return Query(son[now1][1],son[now2][1],son[pre1][1],son[pre2][1],x-(size[son[now1][0]]-size[son[pre1][0]]+size[son[now2][0]]-size[son[pre2][0]]),mid+1,now_r); &#125; void Print(int now,int now_l,int now_r) &#123; cerr&lt;&lt;&quot;no.&quot;&lt;&lt;now&lt;&lt;&quot; l&amp;r:&quot;&lt;&lt;now_l&lt;&lt;&quot; &quot;&lt;&lt;now_r&lt;&lt;&quot; sonl&amp;r:&quot;&lt;&lt;son[now][0]&lt;&lt;&quot; &quot;&lt;&lt;son[now][1]&lt;&lt;&quot; size:&quot;&lt;&lt;size[now]&lt;&lt;endl; if(now_l!=now_r) Print(son[now][0],now_l,mid), Print(son[now][1],mid+1,now_r); &#125; #undef mid&#125;sgt;vector &lt;int&gt; e[N];int n,m,q,w[N],mmap[N];//mmap:离散值-&gt;真实值int fa[N][21],size[N],depth[N],root[N];bool vis[N];void dfs(int now)&#123; for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; vis[now]=true; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; depth[e[now][i]]=depth[now]+1; fa[e[now][i]][0]=now; root[e[now][i]]=++sgt.to; sgt.Add(root[e[now][i]],root[now],w[e[now][i]],1,m); //sgt.Print(root[e[now][i]],1,m); //cerr&lt;&lt;endl; dfs(e[now][i]); &#125; vis[now]=false;&#125;void Merge(int x,int y)&#123; if(size[fa[x][20]]&gt;size[fa[y][20]]) swap(x,y); size[fa[y][20]]+=size[fa[x][20]]; depth[x]=depth[y]+1; fa[x][0]=y; root[x]=++sgt.to; sgt.Add(root[x],root[y],w[x],1,m); //sgt.Print(root[x],1,m); //cerr&lt;&lt;endl; dfs(x); e[x].push_back(y); e[y].push_back(x);&#125;int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(depth[fa[x][i]]&gt;=depth[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int Query(int x,int y,int K)&#123; if(depth[x]&lt;depth[y]) swap(x,y); int lca=LCA(x,y); if(lca==y) return mmap[sgt.Query(root[x],0,(fa[lca][0]==lca?0:root[fa[lca][0]]),0,K,1,m)]; else return mmap[sgt.Query(root[x],root[y],root[lca],(fa[lca][0]==lca?0:root[fa[lca][0]]),K,1,m)];&#125;void Init()&#123; for(int i=0;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=n;i++) &#123; root[i]=++sgt.to; sgt.Add(root[i],0,w[i],1,m); &#125; for(int i=1;i&lt;=n;i++) size[i]=1,depth[i]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=21;j++) fa[i][j]=i;&#125;int m2;int main()&#123; static int tmp[N]; n=read(),n=read(),m2=read(),q=read(); for(int i=1;i&lt;=n;i++) tmp[i]=w[i]=read(); sort(tmp+1,tmp+1+n); m=unique(tmp+1,tmp+1+n)-tmp-1; for(int i=1;i&lt;=n;i++) &#123; int temp=lower_bound(tmp+1,tmp+1+m,w[i])-tmp; mmap[temp]=w[i]; w[i]=temp; &#125; Init(); for(int i=1;i&lt;=m2;i++) &#123; int x=read(),y=read(); Merge(x,y); &#125; int ans=0; char OP[5]; for(int i=1;i&lt;=q;i++) &#123; scanf(&quot;%s&quot;,OP+1); if(OP[1]==&#x27;Q&#x27;) &#123; int x=read()^ans,y=read()^ans,K=read()^ans; printf(&quot;%d\\n&quot;,ans=Query(x,y,K)); &#125; else &#123; int x=read()^ans,y=read()^ans; Merge(x,y); &#125; //ans=0; &#125; return 0;&#125;","categories":[{"name":"主席树","slug":"主席树","permalink":"http://www.goldenpotato.cn/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[SPOJ694] DISUBSTR - Distinct Substrings","slug":"spoj694-disubstr-distinct-substrings","date":"2019-03-06T15:32:09.000Z","updated":"2019-03-06T15:32:09.000Z","comments":true,"path":"2019/03/06/spoj694-disubstr-distinct-substrings/","permalink":"http://www.goldenpotato.cn/2019/03/06/spoj694-disubstr-distinct-substrings/","excerpt":"","text":"题面 传送门：SPOJ 694 Solution 这题可以用SAM来搞，也可以用SA来搞。但无论是哪种搞法，都是基本操作。下面我们来分别讲解一下怎么搞。 SAM 这题用SAM来求就十分粗暴简单。不会SAM的小伙伴可以戳这里 首先，我们先把SAM建出来。根据SAM的性质，我们从出发点随着SAM任意走，走到哪里都是一个完全不同的子串。因此，我们只需要对SAM做一个拓扑序DP/记忆化搜索即可求出SAM上的路径总数，既不同子串的数量。 SA 这题我们显然还是要把后缀数组和height建出来的，不会SA的小伙伴可以戳这里 我们可以发现，对于原串的一个后缀，它的每一个前缀都是原串中的子串。因此，如果我们把所有后缀长度加起来，得到的就是子串的总数量。 如何去重呢？我们可以发现任意两个后缀，它们会造成重复的子串一定是它们的公共前缀。因此，重复的子串的数量即为$\\sum_{i=0}^nheight[i]$，答案既是后缀总长度减去重复子串的数量 Code 本题我用SA来实现，用SAM的小伙伴还请自行yy一下w。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000+10;int id[N],sa[N],height[N];long long rank[N];void CountSort(long long a[],int n,int exp,int m)&#123; static long long cnt[N],b[N]; memset(cnt,0,sizeof cnt); for(int i=1;i&lt;=n;i++) cnt[(a[i]/exp)%m]++; for(int i=1;i&lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;=1;i--) &#123; b[cnt[(a[i]/exp)%m]]=a[i]; if(exp==1) id[cnt[(a[i]/exp)%m]--]=i; else sa[cnt[(a[i]/exp)%m]--]=id[i]; &#125; for(int i=1;i&lt;=n;i++) a[i]=b[i];&#125;void RadixSort(long long a[],int n,int m)&#123; CountSort(a,n,1,m); CountSort(a,n,m,m);&#125;char s[N];int n;void GetSA()&#123; static long long t[N]; for(int i=1;i&lt;=n;i++) rank[i]=t[i]=s[i]; int m=1000+1; for(int k=1;;k=(k&lt;&lt;1)) &#123; for(int i=1;i&lt;=n;i++) rank[i]=t[i]=rank[i]*m+(i+k&lt;=n?rank[i+k]:0); RadixSort(t,n,m); m=0; for(int i=1;i&lt;=n;i++) &#123; if(t[i]!=t[i-1]) m++; rank[sa[i]]=m; &#125; if(m==n) break; m++; &#125; for(int i=1;i&lt;=n;i++) &#123; if(rank[i]==1) continue; int to=max(0,height[rank[i-1]]-1); for(;sa[rank[i]]+to&lt;=n and sa[rank[i]-1]+to&lt;=n;to++) if(s[sa[rank[i]]+to]!=s[sa[rank[i]-1]+to]) break; height[rank[i]]=to; &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); for(;T&gt;0;T--) &#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); memset(rank,0,sizeof rank); GetSA(); long long ans=0; for(int i=1;i&lt;=n;i++) ans+=n-sa[i]+1-height[i]; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DAG DP","slug":"DAG-DP","permalink":"http://www.goldenpotato.cn/categories/DAG-DP/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"[Luogu P2743] [USACO5.1]乐曲主题Musical Themes","slug":"luogu-p2743-usaco5-1乐曲主题musical-themes","date":"2019-03-06T04:28:22.000Z","updated":"2019-03-06T04:28:22.000Z","comments":true,"path":"2019/03/06/luogu-p2743-usaco5-1乐曲主题musical-themes/","permalink":"http://www.goldenpotato.cn/2019/03/06/luogu-p2743-usaco5-1%E4%B9%90%E6%9B%B2%E4%B8%BB%E9%A2%98musical-themes/","excerpt":"","text":"题面 洛谷 P2743 Solution 这题可以用哈希做，也可以用SA做。下面我们分别讲一下两种做法。 哈希 首先，我们把转掉的问题处理掉。我们考虑把原串做差分数组，即用后面那一个减去前面那一个。这样子，我们直接在新的串上找完全相同的两个不可重叠子串即可。 这个，我们考虑先在外面二分一个答案的长度，然后暴力做，从后往前扫，把所有子串都丢到哈希表里面，插入一个新的串之前，就检查一下之前是否有这个串，如果有的话，就检查一下是否满足相隔长度是否大于mid即可。 时间复杂度$O(nlogn)$ 后缀数组 这题的后缀数组做法就比较妙了。 首先，我们还是要做差分数组的。 然后，我们还是要求出SA及height的(不会SA的小伙伴可以看这里) 然后，我们仍然是在外面二分答案，然后考虑怎么检查。 因为每个串不可重复，我们可以考虑把height数组分组，我们希望一个组尽可能长，并且组内所有元素的$height&gt;=mid$，这样子，如果这个组里面有两个原数的sa相隔超过mid，则说明这个结果是正确的。 时间复杂度$O(nlogn)$ Code 我写的双模hash，而且没有使用哈希表，用的是set，总复杂度$O(nlog^2n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;set&gt;using namespace std;const int N=20000+100;const int E=233;const int P2=2333333333;int n;unsigned long long POW[N];long long POW2[N],c[N];void Init()&#123; POW2[0]=POW[0]=1; for(int i=1;i&lt;=n;i++) POW[i]=POW[i-1]*E, POW2[i]=(POW2[i-1]*E)%P2;&#125;struct rec&#123; unsigned long long hash; long long hash2; int t; friend bool operator &lt; (rec a,rec b) &#123; if(a.hash==b.hash) return a.hash2&lt;b.hash2; return a.hash&lt;b.hash; &#125;&#125;;set &lt;rec&gt; record;bool Check(int ans)&#123; record.clear(); unsigned long long hash=0; long long hash2=0; for(int i=1;i&lt;=ans;i++) &#123; hash=hash+c[i]*POW[ans-i+1]; hash2=(hash2+c[i]*POW2[ans-i+1])%P2; &#125; record.insert((rec)&#123;hash,hash2,ans&#125;); for(register int i=ans+1;i&lt;n;i++) &#123; hash=(hash-c[i-ans]*POW[ans])*E+c[i]*E; hash2=((((hash2-c[i-ans]*POW2[ans])*E+c[i]*E)%P2)+P2)%P2; set &lt;rec&gt; :: iterator p=record.lower_bound((rec)&#123;hash,hash2,0&#125;); if((*p).hash==hash and (*p).hash2==hash2) &#123; if(i-(*p).t&gt;=ans) return true; &#125; else record.insert((rec)&#123;hash,hash2,i&#125;); &#125; return false;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(register int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;c[i]); for(register int i=1;i&lt;n;i++) c[i]=c[i+1]-c[i]; Init(); int L=4,R=n,mid,ans=0; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; if(Check(mid)==true) ans=mid+1,L=mid+1; else R=mid-1; &#125; if(ans==6) ans++; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"哈希","slug":"哈希","permalink":"http://www.goldenpotato.cn/categories/%E5%93%88%E5%B8%8C/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"[Luogu P2852] [USACO06DEC]牛奶模式Milk Patterns","slug":"luogu-p2852-usaco06dec牛奶模式milk-patterns","date":"2019-03-06T03:44:45.000Z","updated":"2019-03-06T03:44:45.000Z","comments":true,"path":"2019/03/06/luogu-p2852-usaco06dec牛奶模式milk-patterns/","permalink":"http://www.goldenpotato.cn/2019/03/06/luogu-p2852-usaco06dec%E7%89%9B%E5%A5%B6%E6%A8%A1%E5%BC%8Fmilk-patterns/","excerpt":"","text":"题面 传送门：洛谷P2852 Solution 首先，我们阅读题面可以发现题目让我们求出一个出现次数&gt;k的可重复的子串。 这玩意我们可以用SA求，也可以用SAM求。 SA 这题用SA做就比较妙，首先我们显然要求把SA及height求出来。 因为两个后缀的LCP是它们之间的height的min，我们可以利用这个性质。 考虑一个子串，它所能“控制”的区间的所有的height都必须比它大。 因此，我们可以找出一个height所影响的左右范围，这个我们使用单调栈可以很轻松地求出。 12345678910111213for(int i=1;i&lt;=n;i++)&#123; while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--; L[i]=mstack[top]+1; mstack[++top]=i;&#125;mstack[top=0]=n+1;for(int i=n;i&gt;=1;i--)&#123; while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--; R[i]=mstack[top]-1; mstack[++top]=i;&#125; 然后我们可以发现一个height所“控制”的区间中，这个串被“引用”的次数一定是$R[i]-(L[i]-1)+1$，下面这个图可以简单的说明这一点： 这样，我们只需要二分一个答案，然后一路扫过去检查就完事啦(～￣▽￣)～ 时间复杂度$O(nlogn)$,空间复杂度$O(n)$ SAM 这题用SAM做就非常显然了。根据fail树的性质：fail树中的每个节点所代表的串都必然是它的孩子节点的后缀。我们可以得到一个比较显然的性质：每个叶子节点所代表的子串在原串中只出现了1次，而每个节点所代表的子串在原串中出现的次数必然为它的孩子的出现次数的总和，如果这个点不是被复制出来的，次数还要+1（它自己所代表的串）； 然后，我们只需要便利一遍SAM，把所有出现次数&gt;K的节点的len取个max即可。 时间复杂度$O(n)$，空间复杂度$O(n\\ *10)$ Code 我只写了SA的做法，SAM的做法还请自行yy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int M=1000000+100;const int N=20000+100;int s[N],sa[N],id[N],height[N];long long rank[N];void CountSort(long long a[],int n,int Exp,int m)&#123; static long long cnt[M],b[N]; memset(cnt,0,sizeof cnt); for(int i=1;i&lt;=n;i++) cnt[(a[i]/Exp)%m]++; for(int i=1;i&lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;=1;i--) &#123; b[cnt[(a[i]/Exp)%m]]=a[i]; if(Exp==1) id[cnt[(a[i]/Exp)%m]--]=i; else sa[cnt[(a[i]/Exp)%m]--]=id[i]; &#125; for(int i=1;i&lt;=n;i++) a[i]=b[i];&#125;void RadixSort(long long a[],int n,int m)&#123; CountSort(a,n,1,m); CountSort(a,n,m,m);&#125;int n,K,L[N],R[N];void GetSA()&#123; static long long t[N]; for(int i=1;i&lt;=n;i++) rank[i]=t[i]=s[i]; int m=1000000+1; for(int k=1;;k=k&lt;&lt;1) &#123; for(int i=1;i&lt;=n;i++) rank[i]=t[i]=rank[i]*m+(i+k&lt;=n?rank[i+k]:0); RadixSort(t,n,m); m=0; for(int i=1;i&lt;=n;i++) &#123; if(t[i]!=t[i-1]) m++; rank[sa[i]]=m; &#125; if(m==n) break; m++; &#125; for(int i=1;i&lt;=n;i++) &#123; if(rank[i]==1) continue; int to=max(0,height[rank[i-1]]-1); for(;sa[rank[i]]+to&lt;=n and sa[rank[i]-1]+to&lt;=n;to++) if(s[sa[rank[i]]+to]!=s[sa[rank[i]-1]+to]) break; height[rank[i]]=to; &#125;&#125;int mstack[N],top;//记录从哪来，单调严格上升栈bool Check(int x)&#123; for(int i=1;i&lt;=n;i++) if(height[i]&gt;=x and (R[i]-(L[i]-1)+1)&gt;=K) return true; return false;&#125;int main()&#123; n=read(),K=read(); for(int i=1;i&lt;=n;i++) s[i]=read(); GetSA(); for(int i=1;i&lt;=n;i++) &#123; while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--; L[i]=mstack[top]+1; mstack[++top]=i; &#125; mstack[top=0]=n+1; for(int i=n;i&gt;=1;i--) &#123; while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--; R[i]=mstack[top]-1; mstack[++top]=i; &#125; int ans=0,l=0,r=n,mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(Check(mid)==true) l=mid+1,ans=max(ans,mid); else r=mid-1; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"后缀数组(SA)学习笔记","slug":"后缀数组sa学习笔记","date":"2019-03-06T03:06:37.000Z","updated":"2019-03-06T03:06:37.000Z","comments":true,"path":"2019/03/06/后缀数组sa学习笔记/","permalink":"http://www.goldenpotato.cn/2019/03/06/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84sa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"为什么要学后缀数组 为了解决一类字符串神题妙题。 什么是后缀数组 什么是后缀 要理解什么是后缀数组，首先要明白什么是后缀。 一个字符串$[S_1:S_n]$的后缀为:$[S_i:S_n],i∈[1,n]$ 用人话来说，就是从每个字符开始到这个字符串的结尾所组成的串均为这个字符串的后缀。 例如： 假设我现在有一个字符串“abaaba”,那么。她的后缀有：a,ba,aba,aaba,baaba,abaaba。 什么是后缀数组 把所有后缀按字典序排序之后所构成的数组。 例如： 假设我现在有一个字符串“abaaba”,那么。她的后缀有：a,ba,aba,aaba,baaba,abaaba。她的后缀数组为：a,aaba,aba,abaaba,ba,baaba 后缀数组怎么求 FBI warning：本文并不会讲解为什么能这样求，但是她的证明并不难，感兴趣的读者可以自行拿出草稿纸感性理解一下，或百度一下以获得理性证明 这是一张极其著名的图片 (图出自百度百科) 这里的rank是我们要求的SA的“反数组”，rank指的是每个下标对应的后缀的排名，SA就是我们的后缀数组了：每个排名对应的后缀的下标 我想各位读者看这个图片已经能略懂一二，我们每次对求出来的东西离散化，然后按照类似于倍增的方法把前后两个数字拼起来，多次排序，直到rank的值互不相同为止。 如何排序 在这里，我们可以使用快速排序，那么求后缀数组的总复杂度为$O(nlog^2n)$，但是，如果我们在这里使用基数排序，单次排序的复杂度即可接近$O(n)$,总复杂度$O(nlogn)$ 当然，在这里我们要对基数排序做一点微小的工作，按照正常的基数排序，是不能找到排序后每个值对应的原下标的。魔改的办法也很简单，我们只需要在每次排序的时候传入当前情况下每个值对应的原下标即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int n,sa[N],id[N];void count_sort(long long a[],int n,int Exp,int m)&#123; static long long b[N],cnt[N]; memset(cnt,0,sizeof cnt); for(int i=1;i&lt;=n;i++) cnt[(a[i]/Exp)%m]++; for(int i=1;i&lt;=m;i++) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;=1;i--) &#123; b[cnt[(a[i]/Exp)%m]]=a[i]; //我们这里相当于只排两位数，排第一位的时候我们将映射关系零时储存一下 if(Exp==1) id[cnt[(a[i]/Exp)%m]--]=i; //事实上来说，我们第二次求出来的映射关系，本质上就是我们要求的SA数组 else sa[cnt[(a[i]/Exp)%m]--]=id[i]; &#125; for(int i=1;i&lt;=n;i++) a[i]=b[i];&#125;void radix_sort(long long a[],int n,int m)&#123; count_sort(a,n,1,m); count_sort(a,n,m,m);&#125;void GetSA()&#123; for(int i=1;i&lt;=n;i++) t[i]=s[i],rank[i]=s[i]; long long m=&#x27;z&#x27;+1; for(int i=0;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) rank[j]=t[j]=rank[j]*m+((j+(1&lt;&lt;i)&lt;=n)?rank[j+(1&lt;&lt;i)]:0);//把前后两个数拼起来 radix_sort(t,n,m);//排序 m=0; //离散化 for(int j=1;j&lt;=n;j++) &#123; if(t[j]!=t[j-1]) ++m; rank[sa[j]]=m; &#125; if(m==n) break; m++; &#125;&#125; 后缀数组的进一步应用 显然，我们单纯的求出后缀数组是没有什么Egg用的，我们要发掘一下我们求出来的这玩意的性质。其中，最有用的即是后缀数组的LCP了。 LCP lcp，即最长公共前缀，后缀数组的height[i]指的是SA[i]与SA[i-1]的LCP。 FBI warning：本文并不会讲解为什么能这样求，因为我太菜了并不会，请感兴趣的同学自行百度一下以获得理性证明 要求LCP，我们只需要一个性质height[rank[i]]&gt;=height[rank[i-1]]-1 然后，我们接下来暴力枚举即可，总复杂度$O(n)$ 123456789for(int i=1;i&lt;=n;i++)&#123; if(rank[i]==1) continue; int to=max(0,height[rank[i-1]]-1); for(;sa[rank[i]]+to&lt;=n and sa[rank[i]-1]+to&lt;=n;to++) if(s[sa[rank[i]]+to]!=s[sa[rank[i]-1]+to]) break; height[rank[i]]=to;&#125; 我们可以发现一个比较显然的性质： 两个后缀的$LCP[SA[i],SA[j]]=min(height[i+1,j])$ LCP的应用 我们思考一下：一个串的后缀的前缀是啥… emmmmmmmmmm？这不就是一个原串的子串吗？ OK，由这个性质我们就可以做很多事情了，我们在具体的题中再慢慢讲。 T1:[USACO06DEC]牛奶模式Milk Patterns T2:[USACO5.1]乐曲主题Musical Themes","categories":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"基数排序学习笔记","slug":"基数排序学习笔记","date":"2019-03-06T00:08:31.000Z","updated":"2019-03-06T00:08:31.000Z","comments":true,"path":"2019/03/06/基数排序学习笔记/","permalink":"http://www.goldenpotato.cn/2019/03/06/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是基数排序 基数排序是一个时间复杂度为：$O(n*MAXNUM/base)$，空间复杂度为$O(base+n)$的优秀排序算法。 基数排序有什么用 我们知道，桶排序可以在$O(MAXNUM)$的时间内，$O(MAXNUM)$的空间内排序一个数组，快速排序可以在$O(nlogn)$的时间内，$O(n)$的空间内排序一个数组。 如果有一个排序任务的最大数字比桶大，而数字数量又爆多怎么办？这时候，时空复杂度基于这两者之间的优秀排序：基数排序就闪亮登场啦~。 她一般会在以下场景使用： 神题：WC[2017]挑战 对于排序复杂度比较敏感而数字又不怎么大的算法，如：后缀数组 基数排序怎么做 基数排序的原理 首先，我们可以先来了解以下基数排序的原理：如果给你一堆二位数，他们已经按个位数的大小排好了序，就像这样： 想象一下：如果我们按十位数大小排序，如果十位数大小一样，则按原有的顺序(之前已按个位数大小拍好的序)来排序，这个序列会变成什么样？ 没错，这个数组最后会被我们排好序！ 在刚刚的推导过程中，我们显然可以发现：基数排序是一个不稳定的排序 基数排序的具体做法 按照刚刚的原理，我们可以发现基数排序相当于把原数拆为base进制数(base为我们选定的一个基数，在刚刚的例子中，base=10)，然后按位排序。 那我们具体怎么实现呢？ 我们可以考虑用桶排序来实现每位排序的功能。 我们先把每个数在当前位下的那个数全部丢到一个桶里面，然后对这个桶做前缀和。 12345int cnt[10]=&#123;0&#125;;for(int i=1;i&lt;=n;i++) cnt[(a[i]/exp)%10]++;for(int i=0;i&lt;=9;i++) cnt[i]+=cnt[i-1]; 然后，我们从后往前去把所有的数看一遍，这个数当前的排名即为他所在的桶的值，然后把这个桶的值-1。 （因为我们可以保证之前的排序中在前面的数一定比在后面的数小） 1234for(int i=n;i&gt;=1;i--) b[cnt[(a[i]/exp)%10]--]=a[i];for(int i=1;i&lt;=n;i++) a[i]=b[i]; 然后，我们在外面再套一层枚举位数的就搞定啦~ 1234567891011121314151617181920void count_sort(int a[],int n,int exp)&#123; int cnt[10]=&#123;0&#125;; for(int i=1;i&lt;=n;i++) cnt[(a[i]/exp)%10]++; for(int i=0;i&lt;=9;i++) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;=1;i--) b[cnt[(a[i]/exp)%10]--]=a[i]; for(int i=1;i&lt;=n;i++) a[i]=b[i];&#125;void radix_sort(int a[],int n)&#123; int MAX=0; for(int i=1;i&lt;=n;i++) MAX=max(a[i],MAX); for(int i=1;i&lt;=MAX;i*=10) count_sort(a,n,i);&#125; 有啥题目练啊 WC2017 挑战的第一个subtask 后缀数组","categories":[{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"可并堆(左偏树)学习笔记","slug":"可并堆左偏树学习笔记","date":"2019-03-05T23:26:21.000Z","updated":"2019-03-05T23:26:21.000Z","comments":true,"path":"2019/03/06/可并堆左偏树学习笔记/","permalink":"http://www.goldenpotato.cn/2019/03/06/%E5%8F%AF%E5%B9%B6%E5%A0%86%E5%B7%A6%E5%81%8F%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"为什么要学左偏树 有时候，某些题目要求我们合并两个堆。 合并两个堆，大家都知道可以用splay暴力启发式合并处理。很不幸的是，这玩意的复杂度是$O(nlog^2n)$的，在一些毒瘤题目专门考可并堆的题目中，是注定要被卡的。 可并堆系列算法可以很优雅的解决这系列的算法，她们可以在$O(nlogn)$的时间内处理两个堆合并的问题。而我现在要讲的左偏树就是可并堆中的一种。 什么是左偏树 正如她字面意思一样，是一颗向左“偏”的树。 什么叫“向左偏”呢？我们知道，平衡树的时间复杂度比普通的二叉查找树优秀，是因为平衡树的左右子树深度尽可能平衡以保证每次大小/2。 在这里呢，我们左偏树故意让左子树比右子树大一点来维护平衡性。 左偏树咋写啊 左偏树是通过维护一个深度变量$dis[x]$来保证左孩子比右孩子略大的。 $dis$的定义是：$dis[x]=min(dis[lson],dis[rson])$，考虑到我们的左偏树中每个节点都满足这个性质，易得：$dis[x]=dis[rson]+1$ 以下内容默认左偏树为大根堆，小根堆请读者自行类比 Merge 明白$dis$的定义之后，左偏树就很好写了。 假设我们现在要合并两颗左偏树，显然，新的树根一定是两棵树根权值较大的那个。然后我们把权值较大那棵树的树根作为新的树根，新的树的左孩子为权值较大的那棵树的左孩子，右孩子则递归合并另外那颗树与权值较大的树的右孩子。 代码大概长这样： 12345678910int Merge(int x,int y)//x,y为堆顶&#123; if(x==0 or y==0) return x+y;//若其中某颗子树为空则直接返回 if(a[x]&lt;a[y]) swap(x,y);//保证x的权值&gt;y,方便接下来的讨论 son[x][1]=Merge(son[x][1],y);//右孩子递归合并 fa[son[x][0]]=fa[son[x][1]]=x;//设置左右孩子的fa if(dis[son[x][0]]&lt;dis[son[x][1]]) swap(son[x][0],son[x][1]);//维护左偏性质 dis[x]=dis[son[x][1]]+1;//维护dis return x;&#125; Delete 左偏树作为一个堆，那自然要能删除堆顶元素。删除操作很好处理，我们把根去掉，然后Merge其孩子即可。 因为我们要对fa做路径压缩（如同并查集一样），我们这里必须把旧的根的fa设为新的根，以保证之后能正确的找到新的树的树根 12345void Delete(int x)//x为堆顶&#123; fa[son[x][0]]=fa[son[x][1]]=0;//重设孩子的fa fa[x]=Merge(son[x][0],son[x][1]);//Merge孩子并把旧根的fa设为新的根&#125; 有啥题目做啊 模板题：P3377 【模板】左偏树（可并堆 神题：P3273 SCOI2011棘手的操作","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"左偏树","slug":"左偏树","permalink":"http://www.goldenpotato.cn/categories/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"[Luogu P4168] [Violet]蒲公英","slug":"luogu-p4168-violet蒲公英","date":"2019-03-05T07:04:20.000Z","updated":"2019-03-05T07:04:20.000Z","comments":true,"path":"2019/03/05/luogu-p4168-violet蒲公英/","permalink":"http://www.goldenpotato.cn/2019/03/05/luogu-p4168-violet%E8%92%B2%E5%85%AC%E8%8B%B1/","excerpt":"","text":"题面 洛咕 Solution 题目要求求出区间众数，强制在线。 区间众数是一个比较尴尬的问题，我们无法用区间数据结构来处理这个问题，因为我们没法很好的合并区间众数的答案。 既然区间数据结构解决不了这个问题，我们可以考虑一下使用基于分块的算法，例如莫队。 这题用莫队非常好处理，不幸的是，这题要求强制在线。 因此我们考虑使用分块算法。 分块算法的核心在于把一整个块的信息压缩起来以便快速处理。 我们要查询一段区间的众数，我们可以考虑这样搞：对于这个区间内连续的块，我们先快速地查询这个连续的块中的众数，然后我们暴力处理这个区间剩余的左右两个零散的点，开一个桶暴力维护这些零散的点每个颜色出现的次数，每新加入一个点，就与整个区间的答案比较一下，如果更优就替换答案。 为了实现上面那个思路，我们必须要实现两点：快速求出一段连续块的每个颜色出现的次数，快速求出一段连续块的众数。 对于第一个问题，解决方法很简单，我们暴力做前缀和即可，复杂度$O(n*\\sqrt n)$ 1234567for(int i=1;i&lt;=cnt_block;i++) &#123; for(int j=1;j&lt;=to;j++) pre[i][j]=pre[i-1][j]; for(int j=(i-1)*size;j&lt;i*size;j++) pre[i][a[j]]++; &#125; 对于第二个问题，我们可以考虑把每段连续块的答案预处理出来。 具体做法是：我们枚举每个块，然后我们暴力往后扫描，每扫到一个块的结尾就记录答案。 123456789101112131415cnt[0]=-0x3f3f3f3f; for(int i=1;i&lt;=cnt_block;i++) &#123; int t_ans=0; for(int j=(i-1)*size;j&lt;=n;j++) &#123; cnt[a[j]]++; if(cnt[a[j]]&gt;cnt[t_ans] or (cnt[a[j]]==cnt[t_ans] and a[j]&lt;t_ans)) t_ans=a[j]; if((j+1)%size==0) f[i][j/size+1]=t_ans; &#125; memset(cnt,0,sizeof cnt); cnt[0]=-0x3f3f3f3f; &#125; 就酱，这题就被我们搞定啦~ 复杂度$O(n\\sqrt n)$ Code 本题实现上有较多细节要处理，请小心 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//Luogu P4168 [Violet]蒲公英//Feb,4th,2019//分块套路题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=40000+1000;const int M=200+10;int n,m,a[N],b[N],t_n,mmap[N];//离散值-&gt;原值int f[M][M],pre[M][N];//f[i][j]:块i到j的众数，pre[i][j]：到i块为止，颜色j的出现次数前缀和int cnt[N];//零时记录每个元素出现次数int main()&#123; //freopen(&quot;testdata.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;4168.out&quot;,&quot;w&quot;,stdout); t_n=n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),b[i]=a[i]; sort(b+1,b+1+n); int to=0,last=0; for(int i=1;i&lt;=n;i++) if(b[i]!=last) last=b[i],b[++to]=b[i]; for(int i=1;i&lt;=n;i++) &#123; int t=lower_bound(b+1,b+1+to,a[i])-b; mmap[t]=a[i],a[i]=t; &#125; int size=int(sqrt(n)),cnt_block=n/size+1; n=cnt_block*size-1; for(int i=1;i&lt;=cnt_block;i++) &#123; for(int j=1;j&lt;=to;j++) pre[i][j]=pre[i-1][j]; for(int j=(i-1)*size;j&lt;i*size;j++) pre[i][a[j]]++; &#125; cnt[0]=-0x3f3f3f3f; for(int i=1;i&lt;=cnt_block;i++) &#123; int t_ans=0; for(int j=(i-1)*size;j&lt;=n;j++) &#123; cnt[a[j]]++; if(cnt[a[j]]&gt;cnt[t_ans] or (cnt[a[j]]==cnt[t_ans] and a[j]&lt;t_ans)) t_ans=a[j]; if((j+1)%size==0) f[i][j/size+1]=t_ans; &#125; memset(cnt,0,sizeof cnt); cnt[0]=-0x3f3f3f3f; &#125; int ans=0; for(int i=1;i&lt;=m;i++) &#123; int l=read(),r=read(); l=(l+ans-1)%t_n+1,r=(r+ans-1)%t_n+1; if(l&gt;r) swap(l,r); int bl=l/size+1,br=r/size+1; ans=0; if(bl+1&lt;=br-1) ans=f[bl+1][br-1]; for(int j=l;j&lt;bl*size and j&lt;=r;j++) &#123; cnt[a[j]]++; int tmp1=cnt[a[j]],tmp2=cnt[ans]; if(bl+1&lt;=br-1) tmp1+=pre[br-1][a[j]]-pre[bl][a[j]], tmp2+=pre[br-1][ans]-pre[bl][ans]; if(tmp1&gt;tmp2 or (tmp1==tmp2 and a[j]&lt;ans)) ans=a[j]; &#125; if(bl!=br) for(int j=(br-1)*size;j&lt;=r;j++) &#123; cnt[a[j]]++; int tmp1=cnt[a[j]],tmp2=cnt[ans]; if(bl+1&lt;=br-1) tmp1+=pre[br-1][a[j]]-pre[bl][a[j]], tmp2+=pre[br-1][ans]-pre[bl][ans]; if(tmp1&gt;tmp2 or (tmp1==tmp2 and a[j]&lt;ans)) ans=a[j]; &#125; for(int j=l;j&lt;bl*size and j&lt;=r;j++) cnt[a[j]]--; if(bl!=br) for(int j=(br-1)*size;j&lt;=r;j++) cnt[a[j]]--; cnt[0]=-0x3f3f3f3f; ans=mmap[ans]; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"分块","slug":"分块","permalink":"http://www.goldenpotato.cn/categories/%E5%88%86%E5%9D%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P1829] [国家集训队]Crash的数字表格 / JZPTAB","slug":"luogu-p1829-国家集训队crash的数字表格-jzptab","date":"2019-03-05T07:02:01.000Z","updated":"2019-03-05T07:02:01.000Z","comments":true,"path":"2019/03/05/luogu-p1829-国家集训队crash的数字表格-jzptab/","permalink":"http://www.goldenpotato.cn/2019/03/05/luogu-p1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9Fcrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-jzptab/","excerpt":"","text":"题面 传送门：洛咕 Solution 调到自闭，我好菜啊 为了方便讨论，以下式子$m&gt;=n$ 为了方便书写，以下式子中的除号均为向下取整 我们来颓柿子吧qwq 显然，题目让我们求： $\\large \\sum_{i=1}^n\\sum_{j=1}^m lcm(i,j)$ $lcm$没法玩，我们转到$gcd$形式： $\\large \\sum_{i=1}^n\\sum_{j=1}^m \\frac{i*j}{gcd(i,j)}$ 根据套路，我们去枚举$gcd$ $\\large \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{d=1}^{n} \\frac{i*j}{d}[gcd(i,j)=d]$ 然后可以把$d$的和号移到前面去 $\\large \\sum_{d=1}^{n}\\sum_{i=1}^n\\sum_{j=1}^m \\frac{i*j}{d}[gcd(i,j)=d]$ 要让$gcd(i,j)=d$，$i,j$都必须要为$d$的倍数，我们可以将原来的$i*d,j*d$映射为$i,j$,有： $\\large \\sum_{d=1}^{n}\\sum_{i=1}^{n/d}\\sum_{j=1}^{m/d} {i*j}*d[gcd(i,j)=1]$ 把$d$移到前面去 $\\large \\sum_{d=1}^{n}d\\sum_{i=1}^{n/d}\\sum_{j=1}^{m/d} {i*j}[gcd(i,j)=1]$ 然后我们可以套路地根据$[x=1]=\\sum_{dx}\\mu(d)$这个柿子把$gcd(i,j)$处理掉： $\\large \\sum_{d=1}^{n}d\\sum_{i=1}^{n/d}\\sum_{j=1}^{m/d} {i*j}\\sum_{kgcd(i,j)}\\mu(k)$ 根据套路，我们把这种奇奇怪怪的和式变为枚举的形式 $\\large \\sum_{d=1}^{n}d\\sum_{i=1}^{n/d}\\sum_{j=1}^{m/d} {i*j}\\sum_{k=1}^{n/d}[kgcd(i,j)]\\mu(k)$ 然后就可以把$k$往前提了 $\\large \\sum_{d=1}^{n}d\\sum_{k=1}^{n/d}\\sum_{i=1}^{n/d}\\sum_{j=1}^{m/d} {i*j}*[kgcd(i,j)]\\mu(k)$ 要有$kgcd(i,j)$，$i,j$一定要为$k$的倍数 $\\large \\sum_{d=1}^{n}d\\sum_{k=1}^{n/d}\\sum_{i=1}^{\\frac{n}{d*k}}\\sum_{j=1}^{\\frac{m}{d*k}} {i*j*k^2}*\\mu(k)$ 然后我们简单的移一下项方便处理 $\\large \\sum_{d=1}^{n}d\\sum_{k=1}^{n/d}*\\mu(k)*k^2\\sum_{i=1}^{\\frac{n}{d*k}}i\\sum_{j=1}^{\\frac{m}{d*k}} j$ 后面的$j$与$i$没有半毛钱关系，我们可以把它分离开来 $\\large \\sum_{d=1}^{n}d\\sum_{k=1}^{n/d}*\\mu(k)*k^2(\\sum_{i=1}^{\\frac{n}{d*k}}i)(\\sum_{j=1}^{\\frac{m}{d*k}} j)$ 搞定，到这里为止，我们所有东西都可以求了。 对于前面的$d$的和式，我们可以发现当$n/d,m/d$不变的时候，后面的柿子计算出来的结果是一样的，因此我们可以$O(\\sqrt n)$来整除分块掉前面那个和式。 后面的那个柿子我们可以再来一次整数除法来计算：最后面的两个和式都是等差数列，前面的$\\mu(k)*k^2$可以前缀和直接计算。 总复杂度$O(\\sqrt n * \\sqrt n)=O(n)$ 但是这题还有一个$O(\\sqrt n)$的做法，蒟蒻太菜了不会，就不说了 Code 这题细节繁多，请注意多膜以防乘爆 预处理中的$i^2$会爆int，请注意 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Luogu P1829 [国家集训队]Crash的数字表格 / JZPTAB//Jan,23rd,2019//莫比乌斯反演#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x\\*10+c-&#x27;0&#x27;;c=getchar();&#125; return x\\*f;&#125;const int N=10000000+1000;const int M=10000000;const int poi=20101009;int prime[N],cnt_p,mu[N];bool noPrime[N];void GetPrime(int n)&#123; noPrime[1]=true,mu[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(noPrime[i]==false) prime[++cnt_p]=i,mu[i]=-1; for(int j=1;j&lt;=cnt_p and i\\*prime[j]&lt;=n;j++) &#123; noPrime[i\\*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i\\*prime[j]]=0; break; &#125; mu[i\\*prime[j]]=mu[i]\\*mu[prime[j]]; &#125; &#125;&#125;long long n,m,pre_mu[N];long long f(int d)&#123; long long t_ans=0; for(long long l=1,r;l&lt;=n/d;l=r+1) &#123; r=min((n/d)/((n/d)/l),(m/d)/((m/d)/l)); t_ans=(t_ans+(pre_mu[r]-pre_mu[l-1])\\*(((1+n/d/l)\\*(n/d/l)/2)%poi)%poi\\*(((1+m/d/l)\\*(m/d/l)/2)%poi))%poi; &#125; return (t_ans%poi+poi)%poi;&#125;int main()&#123; n=read(),m=read(); if(n&gt;m) swap(n,m); GetPrime(m); for(long long i=1;i&lt;=m;i++) pre_mu[i]=((pre_mu[i-1]+mu[i]\\*i\\*i)%poi+poi)%poi; long long ans=0; for(long long l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); ans=((ans+(l+r)\\*(r-l+1)/2%poi\\*f(l))%poi+poi)%poi; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"反演","slug":"反演","permalink":"http://www.goldenpotato.cn/categories/%E5%8F%8D%E6%BC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P2522] [HAOI2011]Problem b","slug":"luogu-p2522-haoi2011problem-b","date":"2019-03-05T06:58:14.000Z","updated":"2019-03-05T06:58:14.000Z","comments":true,"path":"2019/03/05/luogu-p2522-haoi2011problem-b/","permalink":"http://www.goldenpotato.cn/2019/03/05/luogu-p2522-haoi2011problem-b/","excerpt":"","text":"题面 传送门：洛咕 Solution 我怎么只会刷水题 这题的双倍经验题，不多说啥了。 啥？范围不一样？ 那根据我们写数位DP及二维前缀和的经验，我们容斥一下… 然后就没有然后了。 时间复杂度$O(m*\\sqrt n)$ Code 人傻自带大常数,不开O2 T一个点 事实上这题可以把一些不必要的$longlong$改成$int$，刚好能过。可惜我太颓，不想改了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Luogu P2522 [HAOI2011]Problem b//Jan,23rd,2019//莫比乌斯函数双倍经验题#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=50000+1000;const int M=50000;int prime[N],p_cnt,mu[N];bool noPrime[M];void GetPrime(int n)&#123; noPrime[1]=true,mu[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(noPrime[i]==false) prime[++p_cnt]=i,mu[i]=-1; for(int j=1;j&lt;=p_cnt and i*prime[j]&lt;=n;j++) &#123; noPrime[i*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=mu[i]*mu[prime[j]]; &#125; &#125;&#125;long long pre_mu[N];long long GetAns(long long n,long long m,int K)&#123; long long t_ans=0; if(n&gt;m) swap(n,m); n/=K,m/=K; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); t_ans+=(pre_mu[r]-pre_mu[l-1])*(n/l)*(m/l); &#125; return t_ans;&#125;int main()&#123; GetPrime(M); for(int i=1;i&lt;=M;i++) pre_mu[i]=pre_mu[i-1]+mu[i]; int T=read(); for(;T&gt;0;T--) &#123; long long a=read(),b=read(),c=read(),d=read(),K=read(); long long ans=GetAns(b,d,K)-GetAns(a-1,d,K)-GetAns(b,c-1,K)+GetAns(a-1,c-1,K); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"反演","slug":"反演","permalink":"http://www.goldenpotato.cn/categories/%E5%8F%8D%E6%BC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P3327] [SDOI2015]约数个数和","slug":"luogu-p3327-sdoi2015约数个数和","date":"2019-03-05T06:57:16.000Z","updated":"2019-03-05T06:57:16.000Z","comments":true,"path":"2019/03/05/luogu-p3327-sdoi2015约数个数和/","permalink":"http://www.goldenpotato.cn/2019/03/05/luogu-p3327-sdoi2015%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/","excerpt":"","text":"题面： 传送门：洛咕 Solution 首先，我们需要一个结论： $\\large d(i,j)=\\sum_{xi}\\sum_{yj}[gcd(x,y)=1]$ 证明 理性证明请看这篇博客的例五 本蒟蒻提供一个感性证明的方法：如果$x*y$是$i*j$的因数，我们必须有$xi,yj$，而后面那个$gcd(x,y)$是用来去重的 有了这个柿子之后，我们之后的推导就比较套路了： 为了方便讨论，之后的柿子均默认$m&gt;n$ 为了方便书写，之后的除法默认向下取整 原式： $\\large \\sum_{i=1}^n\\sum_{j=1}^md(i*j)$ 把我们上面的结论代进去 $\\large \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{xi}\\sum_{yj}[gcd(x,y)=1]$ 根据套路，这里的$xi$与$yj$应该写成枚举的形式： $\\large \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x=1}^{n}[xi]\\sum_{y=1}^{m}[yj][gcd(x,y)=1]$ 这里显然可以把$x,y$的和式写到最前面去： $\\large \\sum_{x=1}^{n}[xi]\\sum_{y=1}^{m}[yj]\\sum_{i=1}^n\\sum_{j=1}^m[gcd(x,y)=1]$ 然后就可以去掉$x,y$后面的那两个判断式啦 $\\large \\sum_{x=1}^{n}\\sum_{y=1}^{m}\\sum_{i=1}^{n/x}\\sum_{j=1}^{m/y}[gcd(x,y)=1]$ 然后我们再去套路后面那个$gcd$，根据莫比乌斯函数的性质$[x=1]=\\sum_{dx}\\mu(d)$，我们就把$gcd$带入得 $\\large \\sum_{x=1}^{n}\\sum_{y=1}^{m}\\sum_{i=1}^{n/x}\\sum_{j=1}^{m/y}\\sum_{dgcd(x,y)}\\mu(d)$ 然后去枚举$d$ $\\large \\sum_{x=1}^{n}\\sum_{y=1}^{m}\\sum_{i=1}^{n/x}\\sum_{j=1}^{m/y}\\sum_{d=1}^{n}\\mu(d)[dgcd(x,y)]$ 套路地把$\\mu$的和式丢到最前面，化简一下就有： $\\large \\sum_{d=1}^{n}\\mu(d)\\sum_{x=1}^{n/d}\\sum_{y=1}^{m/d}\\sum_{i=1}^{n/(x*d)}\\sum_{j=1}^{m/(y*d)}1$ 然后有 $\\large \\sum_{d=1}^{n}\\mu(d)\\sum_{x=1}^{n/d}\\sum_{y=1}^{m/d}\\frac{n}{x*d}\\frac{m}{y*d}$ 移项整理一下： $\\large \\sum_{d=1}^{n}\\mu(d)\\sum_{x=1}^{n/d}\\frac{n}{x*d}\\sum_{y=1}^{m/d}\\frac{m}{y*d}$ 好了，到这里我就不会推了 之后的内容感谢@Maxwei_wzj的教学 事实上，这个柿子我们已经可以算了。 $\\large \\sum_{d=1}^{n}\\mu(d)\\sum_{x=1}^{n/d}\\frac{n}{x*d}\\sum_{y=1}^{m/d}\\frac{m}{y*d}$ 首先，我们有一个结论(我不会证) $\\large x/(y*z)=(x/y)/z$ (这里的除法向下取整) 我们的柿子就可以变为 $\\large \\sum_{d=1}^{n}\\mu(d)\\sum_{x=1}^{n/d}\\frac{\\frac{n}{d}}{x}\\sum_{y=1}^{m/d}\\frac{\\frac{m}{d}}{y}$ 然后我们再设一个方程: $f(x)=\\sum_{i=1}^x\\frac{x}{i}$ 我们柿子就可以写为： $\\large \\sum_{d=1}^{n}\\mu(d)f(\\frac{n}{d})f(\\frac{m}{d})$ 诶？我们好像又能整除分块了。 没错，我们只需要先用$O(n*\\sqrt n)$的整除分块预处理出$f$ 然后再每次$O(\\sqrt n)$整除分块算出那个柿子就好。 时间复杂度$O(n*\\sqrt n)$ 完结撒花✿✿ヽ(°▽°)ノ✿ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Luogu P3327 [SDOI2015]约数个数和//Jan,22ed,2019//莫比乌斯反演#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x\\*10+c-&#x27;0&#x27;;c=getchar();&#125; return x\\*f;&#125;const int N=50000+1000;const int M=50000;int prime[N],p_cnt,mu[N];bool noPrime[N];void GetPrime(int n)&#123; noPrime[1]=true,mu[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(noPrime[i]==false) prime[++p_cnt]=i,mu[i]=-1; for(int j=1;j&lt;=p_cnt and i\\*prime[j]&lt;=n;j++) &#123; noPrime[i\\*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i\\*prime[j]]=0; break; &#125; mu[i\\*prime[j]]=mu[i]\\*mu[prime[j]]; &#125; &#125;&#125;long long f[N],pre_mu[N];int main()&#123; GetPrime(M); for(int i=1;i&lt;=M;i++) for(int l=1,r;l&lt;=i;l=r+1) &#123; r=i/(i/l); f[i]+=(r-l+1)\\*(i/l); &#125; for(int i=1;i&lt;=M;i++) pre_mu[i]=pre_mu[i-1]+mu[i]; int T=read(); for(;T&gt;0;T--) &#123; long long n=read(),m=read(); if(n&gt;m) swap(n,m); long long ans=0; for(int l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); ans+=(pre_mu[r]-pre_mu[l-1])\\*f[n/l]\\*f[m/l]; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"反演","slug":"反演","permalink":"http://www.goldenpotato.cn/categories/%E5%8F%8D%E6%BC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu  P3455] [POI2007]ZAP-Queries","slug":"luogu-p3455-poi2007zap-queries","date":"2019-03-04T05:31:43.000Z","updated":"2019-03-04T05:31:43.000Z","comments":true,"path":"2019/03/04/luogu-p3455-poi2007zap-queries/","permalink":"http://www.goldenpotato.cn/2019/03/04/luogu-p3455-poi2007zap-queries/","excerpt":"","text":"题面 传送门：洛咕 Solution 这题比这题不懂简单到哪里去了 好吧，我们来颓柿子。 为了防止重名，以下所有柿子中的$x$既是题目中的$d$ 为了方便讨论，以下柿子均假设$b&gt;=a$ 为了方便书写，以下除号均为向下取整 题目要求的显然是： $\\large \\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(i,j)=x]$ 根据套路，我们这里要先把这个$x$除掉 $\\large \\sum_{i=1}^{a/x}\\sum_{j=1}^{b/x}[gcd(i,j)=1]$ 再根据套路，根据莫比乌斯函数中$[x=1]=\\sum_{dx}\\mu(d)$的性质，我们把这个$gcd(i,j)$略作转换： $\\large \\sum_{i=1}^{a/x}\\sum_{j=1}^{b/x}\\sum_{dgcd(i,j)}\\mu(d)$ 再次根据套路，我们把$d$的和号改成枚举$d$的形式： $\\large \\sum_{i=1}^{a/x}\\sum_{j=1}^{b/x}\\sum_{d=1}^{a/x}\\mu(d)*[dgcd(i,j)]$ 显然，我们可以把$\\mu(d)$和它前面的和号提到前面去 $\\large \\sum_{d=1}^{a/x}\\mu(d)\\sum_{i=1}^{a/x}\\sum_{j=1}^{b/x}[dgcd(i,j)]$ 显然，若要$[dgcd(i,j)]=1$，则$i,j$都必须为$d$的倍数 $\\large \\sum_{d=1}^{a/x}\\mu(d)\\frac{a}{x*d}\\frac{b}{x*d}$ OK,到此为止，我们所有东西都可以算了。 前面那个$\\mu(d)$可以配上后面的两个和号用整除分块的方法前缀和计算即可。如果不是很清楚的话可以看一下代码。 时间复杂度$O(m*\\sqrt n)$ 完结撒花✿✿ヽ(°▽°)ノ✿0 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Luogu P3455 [POI2007]ZAP-Queries//Jan,22ed,2019//莫比乌斯反演#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x\\*10+c-&#x27;0&#x27;;c=getchar();&#125; return x\\*f;&#125;const int N=50000+100;const int M=50000;int cnt_p,prime[N],mu[N];bool noPrime[N];void GetPrime(int n)&#123; noPrime[1]=true,mu[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(noPrime[i]==false) prime[++cnt_p]=i,mu[i]=-1; for(int j=1;j&lt;=cnt_p and i\\*prime[j]&lt;=n;j++) &#123; noPrime[i\\*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i\\*prime[j]]=0; break; &#125; mu[i\\*prime[j]]=mu[i]\\*mu[prime[j]]; &#125; &#125;&#125;long long pre_mu[N];int main()&#123; GetPrime(M); for(int i=1;i&lt;=M;i++) pre_mu[i]=pre_mu[i-1]+mu[i]; int T=read(); for(;T&gt;0;T--) &#123; long long a=read(),b=read(),x=read(); long long ans=0; if(a&gt;b) swap(a,b); a/=x,b/=x; for(int l=1,r;l&lt;=a;l=r+1) &#123; r=min(a/(a/l),b/(b/l)); ans+=(pre_mu[r]-pre_mu[l-1])\\*(a/l)\\*(b/l); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"反演","slug":"反演","permalink":"http://www.goldenpotato.cn/categories/%E5%8F%8D%E6%BC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P2257] YY的GCD","slug":"luogu-p2257-yy的gcd","date":"2019-03-04T05:28:35.000Z","updated":"2019-03-04T05:28:35.000Z","comments":true,"path":"2019/03/04/luogu-p2257-yy的gcd/","permalink":"http://www.goldenpotato.cn/2019/03/04/luogu-p2257-yy%E7%9A%84gcd/","excerpt":"","text":"题面 传送门：洛咕 Solution 推到自闭，我好菜啊 显然，这题让我们求： $\\large \\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)\\in prime]$ 根据套路，我们可以把判断是否为质数改为枚举这个质数，有： 为了方便枚举，我们在这里假设有$m&gt;n$ $\\large \\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k\\in prime}^{n}[gcd(i,j)= k]$ 显然，要让$gcd(i,j)=k$，必须要有$i,j$均为$k$的倍数，因此有： $\\large \\sum_{k\\in prime}^{n}\\sum_{i=1}^{n/k}\\sum_{j=1}^{m/k}[gcd(i,j)= 1]$ (在这里除号指向下取整) 根据套路，我们要去掉这里的判断符号。因为我们的莫比乌斯函数有这个性质：$[x=1]=\\sum_{dx}\\mu(d)$，我们这里可以直接把$gcd(i,j)$作为$x$带入这个性质里面，有： $\\large \\sum_{k\\in prime}^{n}\\sum_{i=1}^{n/k}\\sum_{j=1}^{m/k}\\sum_{dgcd(i,j)}\\mu(d)$ 然后根据套路，我们直接枚举这里的$d$，有： $\\large \\sum_{k\\in prime}^{n}\\sum_{i=1}^{n/k}\\sum_{j=1}^{m/k}\\sum_{d=1}^{n/k}μ(d)[dgcd(i,j)]$ （因为前面$i,j$中最小的是$n/k$,所以说我们这里$d$的最大值也为$n/k$） 然后我们这里的$\\sum_{d=1}^{n/k}$显然可以直接往前提 $\\large \\sum_{k\\in prime}^{n}\\sum_{d=1}^{n/k}\\sum_{i=1}^{n/k}\\sum_{j=1}^{m/k}μ(d)[dgcd(i,j)]$ 这时候$\\mu(d)$显然也可以往前提 $\\large \\sum_{k\\in prime}^{n}\\sum_{d=1}^{n/k}μ(d)\\sum_{i=1}^{n/k}\\sum_{j=1}^{m/k}[dgcd(i,j)]$ 这时候，我们可以发现后面那个判断式为1当且仅当$i,j$均为$d$的倍数，所以我们可以直接把那两个$\\sum$简化掉 $\\large \\sum_{k\\in prime}^{n}\\sum_{d=1}^{n/k}μ(d)\\frac{n}{k*d}\\frac{m}{k*d}$ 这时候，我们已经可以在$O(logn*\\sqrt n)$的时间内算一次答案了（这里的$log$为质数个数），很可惜，这样的复杂度并不能通过这一题。 事实上，我们还有一个常见的套路来优化这里： 我们可以设$T=k*d$，于是我们有： $\\large \\sum_{k\\in prime}^{n}\\sum_{d=1}^{n/k}μ(\\frac{T}{k})\\frac{n}{T}\\frac{m}{T}$ 然后可以把后面那个和式提前，枚举T，有： $\\large \\sum_{T=1}^{n}\\frac{n}{T}\\frac{m}{T}\\sum_{(k\\in prime,kT)}μ(\\frac{T}{k})$ 搞定，到这里为止，我们一切东西都可以算了。 前面的$\\frac{n}{T}\\frac{m}{T}$可以整除分块来搞，后面那个$μ$可以在$O(n)$的时间预处理，然后算的时候前缀和一搞就ok啦。 如何预处理呢？我们可以考虑这样做：我们先枚举每一个质数$x$，再考虑这个$x$对它的整数倍$t$的贡献为$\\mu(t)$ 酱紫，我们就可以在$O(\\sqrt n)$的时间内处理每一个询问了。 完结撒花✿✿ヽ(°▽°)ノ✿ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//Luogu P2257 YY的GCD//Jan,22ed,2019//莫比乌斯反演#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x\\*10+c-&#x27;0&#x27;;c=getchar();&#125; return x\\*f;&#125;const int N=10000000+1000;const int M=10000000;int mu[N],prime[N],cnt_p;bool noPrime[N];void GetPrime(int n)&#123; mu[1]=1; noPrime[1]=true; for(int i=2;i&lt;=n;i++) &#123; if(noPrime[i]==false) prime[++cnt_p]=i,mu[i]=-1; for(int j=1;j&lt;=cnt_p and i\\*prime[j]&lt;=n;j++) &#123; noPrime[i\\*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i\\*prime[j]]=0; break; &#125; mu[i\\*prime[j]]=mu[i]\\*mu[prime[j]]; &#125; &#125;&#125;long long f[N],pre_f[N];int main()&#123; int t=clock(); GetPrime(M); for(int i=1;i&lt;=cnt_p;i++) for(int j=1;prime[i]\\*j&lt;=M;j++) f[prime[i]\\*j]+=mu[j]; for(int i=1;i&lt;=M;i++) pre_f[i]=pre_f[i-1]+f[i]; int T=read(); for(;T&gt;0;T--) &#123; long long n=read(),m=read(); if(n&gt;m) swap(n,m); int l=1,r=1; long long ans=0; for(;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); ans+=(pre_f[r]-pre_f[l-1])\\*(n/l)\\*(m/l); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; cerr&lt;&lt;clock()-t; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"反演","slug":"反演","permalink":"http://www.goldenpotato.cn/categories/%E5%8F%8D%E6%BC%94/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"狄利克雷卷积学习笔记","slug":"狄利克雷卷积学习笔记","date":"2019-03-04T05:26:29.000Z","updated":"2019-03-04T05:26:29.000Z","comments":true,"path":"2019/03/04/狄利克雷卷积学习笔记/","permalink":"http://www.goldenpotato.cn/2019/03/04/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"蒟蒻尚在学习，请各位dalao不要相信本文的任何一个字，包括标点符号。 什么是狄利克雷卷积 狄利克雷卷积定义式如下： $f\\cdot g(n)=\\sum_{dn}f(d)\\cdot g(\\frac{n}{d})$ 也可以写作： $f\\cdot g(n)=\\sum_{i\\cdot j=n}f(i)\\cdot g(j)$ 怎么算狄利克雷卷积 单独计算$f*g(n)$ 显然我们可以根据定义式暴力计算，枚举$i$即可，复杂度$O(\\sqrt{n})$ 这里就不上代码了，跟暴力枚举质数长得基本上一模一样。 计算$f*g$ 如果再像暴力计算那样，复杂度将达到恐怖的$O(n\\sqrt{n})$。 但是我们可以从质数筛（埃筛）的想法入手，我们可以直接枚举一个$i$，再为它的倍数上的值加上对应的贡献就好。时间复杂度$O(nlogn)$。 代码大概长这样w 1234567void Dirichlet(int f[],int g[],int ans[],int n)&#123; memset(ans,0,sizeof ans); for(int i=1;i&lt;=n;i++) for(int j=1;i*j&lt;=n;j++) ans[i*j]+=f[i]*g[j];&#125; 怎么样，是不是比FFT容易一千万倍？ 狄利克雷卷积有什么性质 满足： 1. 交换律 2. 结合律 3. 分配率","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"卷积","slug":"卷积","permalink":"http://www.goldenpotato.cn/categories/%E5%8D%B7%E7%A7%AF/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"欧拉函数学习笔记","slug":"欧拉函数学习笔记","date":"2019-03-01T06:59:15.000Z","updated":"2019-03-01T06:59:15.000Z","comments":true,"path":"2019/03/01/欧拉函数学习笔记/","permalink":"http://www.goldenpotato.cn/2019/03/01/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是欧拉函数 记欧拉函数为$\\varphi(x)$表示比$x$小且与$x$互质的数的个数。 怎么算欧拉函数 通项公式:$\\varphi(x)=x*\\prod(1-\\frac{1}{p_i})$ ($p_i$为$x$的质因数) 因为欧拉函数是一个积性函数，因此我们可以用欧拉筛(线性筛)在$O(n)$的时间内预处理出来：具体证明请见后文 12345678910111213141516171819202122void GetPrime()&#123; memset(IsPrime,1,sizeof IsPrime); IsPrime[1]=false; phi[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(IsPrime[i]==true) prime[++prime_tot]=i,phi[i]=i-1; for(int j=1;j&lt;=prime_tot and i\\*prime[j]&lt;=n;j++) &#123; IsPrime[i\\*prime[j]]=false; if(i%prime[j]==0) &#123; phi[i\\*prime[j]]=phi[i]\\*prime[j];//性质二 break; &#125; phi[i\\*prime[j]]=phi[i]\\*phi[prime[j]];//性质一 &#125; &#125;&#125; 欧拉函数的性质 欧拉函数是一个积性函数，因此我们有若$gcd(p,i/p)=1$，则$\\varphi(i)=\\varphi(i/p)*\\varphi(p)$ （我不会证） 若$gcd(p,i/p)!=1$，且$p$为质数，则$\\varphi(i)=\\varphi(i/p)*p$ 证明： 因为$gcd(p,i/p)!=1$而且$p$为质数，所以$i$一定由至少两个$p$组成。 所以说$\\varphi(i/p)=\\varphi(i)/p$(因为对累乘没有影响，只对最前面的$x$有影响($x$指的是通项式中的$x$)) 证毕","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P3723] [AH2017/HNOI2017]礼物","slug":"luogu-p3723-ah2017-hnoi2017礼物","date":"2019-03-01T06:56:45.000Z","updated":"2019-03-01T06:56:45.000Z","comments":true,"path":"2019/03/01/luogu-p3723-ah2017-hnoi2017礼物/","permalink":"http://www.goldenpotato.cn/2019/03/01/luogu-p3723-ah2017-hnoi2017%E7%A4%BC%E7%89%A9/","excerpt":"","text":"题面 传送门：洛咕 Solution 调得我头大，我好菜啊 好吧，我们来颓柿子吧： 我们可以只旋转其中一个手环。对于亮度的问题，因为可以在两个串上增加亮度，我们也可以看做是可以为负数的。 所以说，我们可以假设我们旋转$B$串，上下要加上的亮度差为$p$,可以直接拍出一个最暴力的柿子： 设$f(x)$表示$B$串以$x$为开头的差异值，有： $f(x)=\\sum_{i=0}^{x-1}(B[i]-A[i+n-x]+p)^2+\\sum_{i=x}^{n-1}(B[i]-A[i-x]+p)^2$ 大力展开化简后有： $f(x)=\\sum_{i=0}^{n-1}A[i]^2+\\sum_{i=0}^{n-1}B[i]^2+n*p^2-2p\\sum_{i=0}^{n-1}(A[i]-B[i])-2\\sum_{i=0}^{x-1}(B[i]*A[i+n-x])-2\\sum_{i=x}^{n-1}(B[i]*A[i-x])$ 前两项$\\sum_{i=0}^{n-1}A[i]^2+\\sum_{i=0}^{n-1}B[i]^2$显然$O(n)预处理出来$ 中间两项$n*p^2-2p\\sum_{i=0}^{n-1}(A[i]-B[i])$是一个关于$p$的二次函数，我们找最小值就好。（因为这题$m$非常小，我们也可以暴力枚举），复杂度$O(1)$或$O(m)$。 最后两项$-2\\sum_{i=0}^{x-1}(B[i]*A[i+n-x])-2\\sum_{i=x}^{n-1}(B[i]*A[i-x])$看起来非常像卷积，但是并不是，因此我们得做点处♂理。 蒟蒻本人是这样处理的： 首先，后面那个循环范围是肯定没法卷的，因此我们先把后面的循环处理一下得： $-2\\sum_{i=0}^{x-1}(B[i]*A[i+n-x])-2\\sum_{i=0}^{n-x-1}(A[i]*B[i+x])$ 然后我们可以考虑把前面那项的$A$反转(这样可以处理掉$n$来方便卷积)，把后面那项的$B$反转(这样可以制造$n$与$\\sum$对应) $-2\\sum_{i=0}^{x-1}(B[i]*A’[x-1-i])-2\\sum_{i=0}^{n-x-1}(A[i]*B’[n-1-i-x])$ 哦豁，卷积，搞定。 时间复杂度$O(n*logn)$ Code 我什么时候才能一次性写对FFT啊 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Luogu P3723 [AH2017/HNOI2017]礼物//Jan,20th,2019//颓柿子+FFT加速计算#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;complex&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x\\*10+c-&#x27;0&#x27;;c=getchar();&#125; return x\\*f;&#125;const int M=50000+100;const int N=M\\*4;const double PI=acos(-1);typedef complex &lt;double&gt; cp;inline cp omega(int K,int n)&#123; return cp(cos(2\\*PI\\*K/n),sin(2\\*PI\\*K/n));&#125;void FFT(cp a[],int n,bool type)&#123; static int tmp[N],num=n-1,len=0; while(num!=0) num/=2,len++; for(int i=0,j;i&lt;=n;i++) &#123; for(j=0,num=i;j&lt;len;j++) tmp[j]=num%2,num/=2; reverse(tmp,tmp+len); for(j=0,num=0;j&lt;len;j++) num+=tmp[j]\\*(1&lt;&lt;j); if(i&lt;num) swap(a[i],a[num]); &#125; for(int l=2;l&lt;=n;l\\*=2) &#123; cp x0=omega(1,l); if(type==true) x0=conj(x0); int m=l/2; for(int j=0;j&lt;n;j+=l) &#123; cp x(1,0); for(int k=0;k&lt;m;k++,x\\*=x0) &#123; cp temp=x\\*a[j+k+m]; a[j+k+m]=a[j+k]-temp; a[j+k]=a[j+k]+temp; &#125; &#125; &#125;&#125;int n,m,a[N],b[N];cp B1[N],A1[N],B2[N],A2[N];long long ans;int main()&#123; freopen(&quot;3723.in&quot;,&quot;r&quot;,stdin); n=read(),m=read(); for(int i=0;i&lt;n;i++) a[i]=read(); for(int i=0;i&lt;n;i++) b[i]=read(); long long dif=0; for(int i=0;i&lt;n;i++) ans+=a[i]\\*a[i]+b[i]\\*b[i],dif+=a[i]-b[i]; long long t_ans=0x3f3f3f3f\\*0x3f3f3f3f; for(int i=-m;i&lt;=m;i++) t_ans=min(t_ans,n\\*i\\*i-2\\*i\\*dif); ans+=t_ans; int t=1; while(t&lt;2\\*n) t\\*=2; reverse(a,a+n); for(int i=0;i&lt;n;i++) A1[i]=a[i],B1[i]=b[i]; FFT(A1,t,false); FFT(B1,t,false); for(int i=0;i&lt;t;i++) A1[i]\\*=B1[i]; FFT(A1,t,true); for(int i=0;i&lt;t;i++) A1[i].real()/=t; reverse(a,a+n); reverse(b,b+n); for(int i=0;i&lt;n;i++) A2[i]=a[i],B2[i]=b[i]; FFT(A2,t,false); FFT(B2,t,false); for(int i=0;i&lt;t;i++) A2[i]\\*=B2[i]; FFT(A2,t,true); for(int i=0;i&lt;t;i++) A2[i].real()/=t; t_ans=(long long)(2\\*floor(A2[n-1].real()+0.5)); for(int i=1;i&lt;n;i++) t_ans=max(t_ans,(long long)(2\\*floor(A1[i-1].real()+A2[n-i-1].real()+0.5))); ans-=t_ans; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://www.goldenpotato.cn/categories/FFT-NTT/"},{"name":"卷积","slug":"卷积","permalink":"http://www.goldenpotato.cn/categories/%E5%8D%B7%E7%A7%AF/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P4173]残缺的字符串","slug":"luogu-p4173残缺的字符串","date":"2019-03-01T06:55:43.000Z","updated":"2019-03-01T06:55:43.000Z","comments":true,"path":"2019/03/01/luogu-p4173残缺的字符串/","permalink":"http://www.goldenpotato.cn/2019/03/01/luogu-p4173%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题面 传送门：洛咕 Solution 这题我写得脑壳疼，我好菜啊 好吧，我们来说正题。 这题…emmmmmmm 显然KMP类的字符串神仙算法在这里没法用了。 那咋搞啊（或者说这题和数学有半毛钱关系啊） 我们考虑把两个字符相同强行变为一个数学关系，怎么搞呢？ 考虑这题是带通配符的，我们可以这样设: $C(x,y)=(A[x]-B[y])^2*A[x]*B[y]$ 因此，我们可以看出两个字符一样当且仅当$C(x,y)=0$ 因此，我们再设一个函数$P(x)$表示$B$串以第$x$项为结尾的长度为$m$的子串是否与$A$串匹配，显然有： $P(x)=\\sum_{i=0}^{m-1}C(i,x-m+i+1)$ $P(x)=\\sum_{i=0}^{m-1}(A[i]-B[x-m+i+1])^2*A[i]*B[x-m+i+1]$ 后面那个式子写的太蛋疼了，我们把$x-m+i+1$设为$j$吧。 $P(x)=\\sum_{i=0}^{m-1}(A[i]-B[j])^2*A[i]*B[j]$ 大力展开得： $P(x)=\\sum_{i=0}^{m-1}A[i]^3B[j]-2A[i]^2B[j]^2+A[i]B[j]^3$ 然后…我们试着把$\\sum$展开？ $P(x)=\\sum_{i=0}^{m-1}A[i]^3B[j]-\\sum_{i=0}^{m-1}2A[i]^2B[j]^2+\\sum_{i=0}^{m-1}A[i]B[j]^3$ 还是没法算啊… 诶，等下，如果我们把$A$串反转为$A’$,肯定有$A[i]=A’[m-i-1]$ 然后这个$(m-i-1)+(j)$…不就是等于$x$嘛。 所以说我们马上就有： $P(x)=\\sum_{i+j=x}A[i]^3B[j]-\\sum_{i+j=x}2A[i]^2B[j]^2+\\sum_{i+j=x}A[i]B[j]^3$ 哦豁，卷积，搞定~ 时间复杂度$O(nlogn)$ 搞定个鬼，这题要做7次FFT，常数爆大，我卡不进去 还请各位dalao赐教。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;complex&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int M=300000+100;const int N=M*4;const double PI=acos(-1);const double eps=1e-1;typedef complex &lt;double&gt; cp;cp omega(int K,int n)&#123; return cp(cos(2*PI*K/n),sin(2*PI*K/n));&#125;inline void FFT(cp a[],int n,bool type)&#123; static int tmp[N],num=n-1,len; while(num!=0) num/=2,len++; for(int i=0,j;i&lt;=n;i++) &#123; for(j=0,num=i;j&lt;len;j++) tmp[j]=num%2,num/=2; reverse(tmp,tmp+len); for(j=0,num=0;j&lt;len;j++) num+=tmp[j]*(1&lt;&lt;j); if(i&lt;num) swap(a[i],a[num]); &#125; for(int l=2;l&lt;=n;l*=2) &#123; int m=l/2; cp x0=omega(1,l); if(type==true) x0=conj(x0); for(int i=0;i&lt;n;i+=l) &#123; cp x(1,0); for(int j=0;j&lt;m;j++,x*=x0) &#123; cp temp=x*a[i+j+m]; a[i+j+m]=a[i+j]-temp; a[i+j]=a[i+j]+temp; &#125; &#125; &#125;&#125;char A[N],B[N];int m,n,t=1;cp S1[N],S2[N],S3[N],B1[N],B2[N],B3[N];bool OK[N];int main()&#123; scanf(&quot;%d%d%s%s&quot;,&amp;m,&amp;n,A,B); while(t&lt;=(n+m)) t*=2; reverse(A,A+m); for(int i=0;i&lt;t;i++) A[i]=(A[i]==&#x27;*&#x27; or A[i]&lt;&#x27;a&#x27; or A[i]&gt;&#x27;z&#x27;?0:A[i]-&#x27;a&#x27;+1), B[i]=(B[i]==&#x27;*&#x27; or B[i]&lt;&#x27;a&#x27; or B[i]&gt;&#x27;z&#x27;?0:B[i]-&#x27;a&#x27;+1); for(int i=0;i&lt;t;i++) S1[i]=A[i],S2[i]=A[i]*A[i],S3[i]=A[i]*A[i]*A[i]; for(int i=0;i&lt;t;i++) B1[i]=B[i],B2[i]=B[i]*B[i],B3[i]=B[i]*B[i]*B[i]; FFT(S1,t,false); FFT(S2,t,false); FFT(S3,t,false); FFT(B1,t,false); FFT(B2,t,false); FFT(B3,t,false); for(int i=0;i&lt;t;i++) S3[i]*=B1[i]; for(int i=0;i&lt;t;i++) S1[i]*=B3[i]; for(int i=0;i&lt;t;i++) S2[i]*=B2[i]; for(int i=0;i&lt;t;i++) S3[i]+=S1[i]-2.0*S2[i]; FFT(S3,t,true); int cnt=0; for(int i=m-1;i&lt;n;i++) if(fabs(S3[i].real()/t)&lt;eps) OK[i]=true,cnt++; printf(&quot;%d\\n&quot;,cnt); for(int i=m-1;i&lt;n;i++) if(OK[i]==true) printf(&quot;%d &quot;,i-m+1+1); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://www.goldenpotato.cn/categories/FFT-NTT/"},{"name":"卷积","slug":"卷积","permalink":"http://www.goldenpotato.cn/categories/%E5%8D%B7%E7%A7%AF/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P3338] [ZJOI2014]力","slug":"luogu-p3338-zjoi2014力","date":"2019-03-01T06:54:13.000Z","updated":"2019-03-01T06:54:13.000Z","comments":true,"path":"2019/03/01/luogu-p3338-zjoi2014力/","permalink":"http://www.goldenpotato.cn/2019/03/01/luogu-p3338-zjoi2014%E5%8A%9B/","excerpt":"","text":"题面 传送门： 洛咕 BZOJ Solution 写到脑壳疼，我好菜啊 我们来颓柿子吧 $F_j=\\sum_{i&lt;j}\\frac{q_i*q_j}{(i-j)^2}-\\sum_{i&gt;j}\\frac{q_i*q_j}{(i-j)^2}$ $q_j$与$i$没有半毛钱关系，提到外面去 $F_j=q_j*\\sum_{i&lt;j}\\frac{q_i}{(i-j)^2}-q_j*\\sum_{i&gt;j}\\frac{q_i}{(i-j)^2}$ 左右同时除以$q_j$ $E_j=\\sum_{i=1}^{j-1}\\frac{q_i}{(i-j)^2}-\\sum_{i=j+1}^{n}\\frac{q_i}{(i-j)^2}$ 我们设$f(i)=q(i),g(i)=\\frac{1}{i^2}$，有 $E_j=\\sum_{i=1}^{j-1}f(i)*g(i-j)-\\sum_{i=j+1}^{n}f(i)*g(i-j)$ 因为$g(i)$是个偶函数，因此有： $E_j=\\sum_{i=1}^{j-1}f(i)*g(j-i)-\\sum_{i=j+1}^{n}f(i)*g(i-j)$ 这时候，我们显然可以发现左边那个式子是个卷积，右边的这样一波化简就也变成了卷积形式： 卷积用FFT快速计算即可 时间复杂度$O(nlogn)$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Luogu P3338 [ZJOI2014]力//Jan,18th,2019//FFT加速卷积#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;complex&gt;using namespace std;typedef complex &lt;double&gt; cp;const double PI=acos(-1);const int M=100000+100;const int N=8\\*M;inline cp omega(int K,int n)&#123; return cp(cos(2\\*PI\\*K/n),sin(2\\*PI\\*K/n));&#125;void FFT(cp a[],int n,bool type)&#123; static int len=0,num=n-1,t[N]; while(num!=0) len++,num/=2; for(int i=0,j;i&lt;=n;i++) &#123; for(j=0,num=i;j&lt;len;j++) t[j]=num%2,num/=2; reverse(t,t+len); for(j=0,num=0;j&lt;len;j++) num+=t[j]\\*(1&lt;&lt;j); if(i&lt;num) swap(a[i],a[num]); &#125; for(int l=2;l&lt;=n;l\\*=2) &#123; int m=l/2; cp x0=omega(1,l); if(type==true) x0=conj(x0); for(int j=0;j&lt;n;j+=l) &#123; cp x=cp(1,0); for(int k=0;k&lt;m;k++,x\\*=x0) &#123; cp temp=x\\*a[j+k+m]; a[j+k+m]=a[j+k]-temp; a[j+k]=a[j+k]+temp; &#125; &#125; &#125;&#125;int n,m;double q[N];cp f[N],g[N],f2[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;q[i]); for(int i=1;i&lt;=n;i++) g[i]=(1.0/i/i); m=1; while(m&lt;2\\*n) m\\*=2; for(int i=1;i&lt;m;i++) f[i]=q[i],f2[i]=q[i]; FFT(g,m,false); FFT(f,m,false); reverse(f2+1,f2+n+1); FFT(f2,m,false); for(int i=0;i&lt;m;i++) f[i]\\*=g[i],f2[i]\\*=g[i]; FFT(f,m,true); FFT(f2,m,true); for(int i=1;i&lt;=n;i++) printf(&quot;%lf\\n&quot;,(f[i].real()-f2[n-i+1].real())/m); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://www.goldenpotato.cn/categories/FFT-NTT/"},{"name":"卷积","slug":"卷积","permalink":"http://www.goldenpotato.cn/categories/%E5%8D%B7%E7%A7%AF/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"快速傅里叶变换学习笔记（FFT）","slug":"快速傅里叶变换学习笔记（fft）","date":"2019-03-01T06:50:39.000Z","updated":"2019-03-01T06:50:39.000Z","comments":true,"path":"2019/03/01/快速傅里叶变换学习笔记（fft）/","permalink":"http://www.goldenpotato.cn/2019/03/01/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88fft%EF%BC%89/","excerpt":"","text":"什么是FFT FFT是用来快速计算两个多项式相乘的一种算法。 如果我们暴力计算两个多项式相乘，复杂度必然是$O(n^2)$的，而FFT可以将复杂度降至$O(nlogn)$ 如何FFT 要学习FFT,我们得先了解它的思想。 首先，我们得先了解如何表示一个多项式。显然，我们最传统的方法表示多项式就是表示它的系数就好。但是，如果我们用系数来计算两个多项式相乘，复杂度无论如何都是$O(n^2)$的。因此，我们引入点值表示法。 补充资料：什么是点值表示 设$A(x)$是一个$n−1$次多项式，那么把$n$个不同的$x$代入，会得到$n$个$y$。这$n$对$(x,y)$唯一确定了该多项式，即只有一个多项式能同时满足“代入这些$x$，得到的分别是这些$y$”。 由多项式可以求出其点值表示，而由点值表示也可以求出多项式。 ——胡小兔dalao的博客 所以说，我们要表示一个$n-1$次多项式，可以用$n$个点值来表示。如果用点值来计算两个多项式相乘，那就很简单了，我们只需要两个多项式的点值两两对应相乘即可（如果两个多项式次数不同，我们也必须让次数较小的那个多项式强行算够一样多的点值（即多取几个$x$来计算即可）），这样做的复杂度是$O(n)的$。 因此，如果我们能快速地把一个多项式从系数表示变为点值表示，我们就能快速计算两个多项式相乘啦。 这个快速计算的过程就是FFT。 1.如何取点 我们要把一个多项式从系数形式变为点值形式，肯定躲不开取$x$的过程。先辈傅里叶已经为我们解决了这个问题。他取的$x$为虚数。 如果您没有学习过复数，请移步胡小兔dalao的博客，他有详细的讲解。 所以说，我们是假设把一个单位圆分成n份（纵坐标为虚部，横坐标为实部），单位圆上我们每取的一个点所代表的虚数（实部与虚部相加）即对应一个$x$ 根据我们的数学知识，圆上的任意一个我们取出来的点的坐标都可以表示为$(cos((k2pi)/n),sin((k2pi)/n))$的形式，逆时针将这$n$个点从$0$开始编号，第$k$个点对应的虚数记作$ω_n^k$ 补充资料：单位根的性质 性质一：$ω^{2k}_{2n}=ω^k_n$ 证明：它们对应的点/向量是相同的。 性质二：$ω^{k+n/2}_n=−ω^k_n$ 证明：它们对应的点是关于原点对称的（对应的向量是等大反向的）。 ——胡小兔dalao的博客 这样子，我们就取出了$n$个$x$ 补充资料：为什么要取这些点 如果我们取这些点，我们最后可以快速地把点值式转换为系数式，具体方法及证明见下文 2.如何快速算出每个$x$对应的多项式的值 这就涉及到FFT的核心算法了。如果我们暴力去算，复杂度依旧是$O(n^2)$，并没有什么用。因此，我们FFT的核心思想是分治。 我们先把原多项式拉出来： $A(x)=a_0x^0+a_1x^1+a_2x^2+a_3x^3+a_4*x^4+…+a_{n-1}*x^{n-1}$ 设两个新的多项式： $A_1(x)=a_0x^0+a_2x^1+a_4x^2+a_6x^3+…a_{n-2}*x^{n/2-1}$ $A_2(x)=a_1x^0+a_3x^1+a_5x^2+a_7x^3+…a_{n-1}*x^{n/2-1}$ 显然我们有： $A(x)=A_1(x^2)+x*A_2(x^2)$ 所以说，我们可以把原来得式子分成两个长度只有一半的式子，每次都能减少一半的计算量，这样子，我们复杂度就变成了$O(n*logn)$ 假设我们已经递归下去算出了$A_1$与$A_2$在$(\\omega_{\\frac{n}{2}}^{0}, \\omega_{\\frac{n}{2}}^{1}, \\omega_{\\frac{n}{2}}^{2}, … , \\omega_{\\frac{n}{2}}^{\\frac{n}{2} - 1})$的值，怎么合并回$A$在$(\\omega_n^{0}, \\omega_n^{1}, \\omega_n^{2}, … , \\omega_n^{n-1})$的值呢？ 我们把$\\omega_n^x$带回我们刚刚的这个式子：$A(x)=A_1(x^2)+x*A_2(x^2)$有： $A(\\omega_n^x)=A_1(\\omega_n^{x^2})+\\omega_n^x*A_2(\\omega_n^{x^2})$ $A(\\omega_n^x)=A_1(\\omega_{n/2}^{x})+\\omega_n^x*A_2(\\omega_{n/2}^{x})$ 那另外那一半怎么算呢？ 同样把$\\omega_n^{x+n/2}$带入$A(x)=A_1(x^2)+x*A_2(x^2)$有： $A(\\omega_n^{k + \\frac{n}{2}}) = A_1(\\omega_n^{2k + n}) + \\omega_n^{k + \\frac{n}{2}}A_2(\\omega_n^{2k + n})$ $A(\\omega_n^{k + \\frac{n}{2}}) = A_1(\\omega_{\\frac{n}{2}}^{k} \\times \\omega_n^n) + \\omega_n^{k + \\frac{n}{2}} A_2(\\omega_{\\frac{n}{2}}^{k} \\times \\omega_n^n)$ $A(\\omega_n^{k + \\frac{n}{2}}) = A_1(\\omega_{\\frac{n}{2}}^{k}) - \\omega_n^kA_2(\\omega_{\\frac{n}{2}}^{k})$ 1 实现上，差不多长这样： 123456789101112131415161718192021222324252627const double PI=acos(-1);typedef complex &lt;double&gt; cp;inline cp omega (int K,int n)&#123; return cp(cos(2*PI*K/n),sin(2*PI*K/n));&#125;void FFT(cp a[],int n,bool type)&#123; if(n==1) return; static cp buf[M]; int m=n/2; for(int i=0;i&lt;m;i++) buf[i]=a[i*2],buf[i+m]=a[i*2+1]; for(int i=0;i&lt;n;i++) a[i]=buf[i]; FFT(a,m,type); FFT(a+m,m,type); for(int i=0;i&lt;m;i++) &#123; cp x=omega(i,n); if(type==true) x=conj(x);//conj在这里做取倒的作用，具体作用请看下文第四点 buf[i]=a[i]+x*a[i+m]; buf[i+m]=a[i]-x*a[i+m]; &#125; for(int i=0;i&lt;n;i++) a[i]=buf[i];&#125; 3.后续优化 理论上来说，我们已经可以实现FFT了，很不幸的是，递归版本的常数巨大（递归消耗以及大量的三角函数计算），我们可以通过一些玄学方法来优化这份FFT代码： 在进行fft时，我们要把各个系数不断分组并放到两侧，那么一个系数原来的位置和最终的位置有什么规律呢？ 初始位置：0 1 2 3 4 5 6 7 第一轮后：0 2 4 61 3 5 7 第二轮后：0 42 61 53 7 第三轮后：04261537 “”代表分组界限。 可以发现（这你都能发现？），一个位置a上的数，最后所在的位置是“a二进制翻转得到的数”，例如6(011)最后到了3(110)，1(001)最后到了4(100)。 那么我们可以据此写出非递归版本fft：先把每个数放到最后的位置上，然后不断向上还原，同时求出点值表示 代码大概长这样： 123456789101112131415161718192021222324252627282930void FFT(cp a[],int n,bool type)&#123; static int len=0,t_num=n-1,t[N]; while(t_num!=0) t_num/=2,len++; for(int i=0,j;i&lt;=n;i++) &#123; for(t_num=i,j=0;j&lt;len;j++) t[j]=t_num%2,t_num/=2; reverse(t,t+len); for(t_num=0,j=0;j&lt;len;j++) t_num+=t[j]*(1&lt;&lt;j); if(i&lt;t_num) swap(a[i],a[t_num]); &#125; for(int l=2;l&lt;=n;l*=2) &#123; int m=l/2; cp x0=omega(1,l); if(type==true) x0=conj(x0); for(int i=0;i&lt;n;i+=l) &#123; cp x=cp(1,0); for(int j=0;j&lt;m;j++,x*=x0) &#123; cp temp=x*a[i+j+m]; a[i+j+m]=a[i+j]-temp; a[i+j]=a[i+j]+temp; &#125; &#125; &#125;&#125; 4.怎么把点值式换回系数 FFT有一个性质：把多项式$A(x)$的离散傅里叶变换结果作为另一个多项式$B(x)$的系数，取单位根的倒数即$ω^0_n,ω_n^{-1},ω_n^{-2},…,ω^{-n+1}_n$作为$x$代入$B(x)$，得到的每个数再除以$n$，得到的$是A(x)$的各项系数啦。 补充资料：如何证明这个性质 我们设带入后$B$的某个点值为$z_k$,多项式$B$算出来的某个点值为$j_i$,我们有： $z_k = \\sum_{i = 0}^{n - 1} y_i(\\omega_n^{-k})^i$ $z_k= \\sum_{i = 0}^{n - 1}(\\sum_{j = 0}^{n - 1} a_j(\\omega_n^i)^j)(\\omega_n^{-k})^i$ $z_k= \\sum_{j = 0}^{n - 1}a_j(\\sum_{i = 0}^{n - 1}(\\omega_n^{j - k})^i)$ 这里的$sum_{i = 0}^{n - 1}(omega_n^{j - k})^i$是可以求出来得，当$j=k$的时候，这个式子等于$n$，其他时候均为$0$（使用等比数列求和即可证明） 因此我们有：$z_k=n*a_k$。 证毕 最后的最后… 恭喜你，到此为止，你已经学会了FFT 撒花✿✿ヽ(°▽°)ノ✿","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://www.goldenpotato.cn/categories/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"http://www.goldenpotato.cn/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"[CF932E] Team Work","slug":"cf932e-team-work","date":"2019-02-25T11:29:02.000Z","updated":"2019-02-25T11:29:02.000Z","comments":true,"path":"2019/02/25/cf932e-team-work/","permalink":"http://www.goldenpotato.cn/2019/02/25/cf932e-team-work/","excerpt":"","text":"题面 洛咕 CodeForces Solution 这题写得我脑壳疼，我好菜啊 . 显然，这题让我们求$\\sum_{i=1}^{n}C_n^i\\times i^k$ 这个$i^k$让人浑身难受，我们可以考虑把它搞掉，能搞掉某个数的幂次方的有啥？本蒟蒻只会第二类斯特林数。 . 所以说我们无脑把第二类斯特林数带进去再说： $\\sum_{i=1}^{n}C_n^i\\times \\sum_{j=0}^{i}S(k,j)*j!*C_i^j$ . 然后把组合数展开： $\\sum_{i=1}^{n}\\frac{n!}{i!(n-i)!}\\times \\sum_{j=0}^{i}S(k,j)*j!*\\frac{i!}{j!(i-j)!}$ . 因为前面那一项与j无关，我们可以把它放到后面去 $\\sum_{i=1}^{n} \\sum_{j=0}^{i} \\frac{n!}{i!(n-i)!} * S(k,j)*j!*\\frac{i!}{j!(i-j)!}$ . 约分得： $\\sum_{i=1}^{n} \\sum_{j=0}^{i} \\frac{n!}{(n-i)!} * S(k,j)*\\frac{1}{(i-j)!}$ . 因为$k$很小，$j$很大，而第二类斯特林数的定义告诉我们，当$j&gt;k$时，$S(k,j)=0$。因此，我们可以考虑把$S(k,j)$放到外面来处理，根据交换和号的原则，我们可以处理前面两个$\\sum$来方便把$S(k,j)$提到外面来。 交换和号后得： $\\sum_{j=0}^{n} \\sum_{i=j}^{n} \\frac{n!}{(n-i)!} * S(k,j)*\\frac{1}{(i-j)!}$ . 然后就可以把$S(k,j)$提到外面来了： $\\sum_{j=0}^{n} S(k,j) \\times \\sum_{i=j}^{n} \\frac{n!}{(n-i)!}*\\frac{1}{(i-j)!}$ . 考虑到一点，当我们的$j&gt;k$的时候，$S(k,j)=0$，因此，我们前面$j$的枚举范围可以缩小为$min(k,n)$ $\\sum_{j=0}^{min(n,k)} S(k,j) \\times \\sum_{i=j}^{n} \\frac{n!}{(n-i)!}*\\frac{1}{(i-j)!}$ . 这时候我们可以发现：后面那个循环长得非常像组合数，考虑上下同时乘以$(n-j)!$让它变成组合数: $\\sum_{j=0}^{min(n,k)} S(k,j) \\times \\sum_{i=j}^{n} \\frac{n!}{(n-j)!}*\\frac{(n-j)!}{(n-i)!*(i-j)!}$ $\\sum_{j=0}^{min(n,k)} S(k,j) \\times \\sum_{i=j}^{n} \\frac{n!}{(n-j)!}*C_{(n-j)}^{(n-i)}$ . 同理，我们可以把后面那个阶乘提到前面去 $\\sum_{j=0}^{min(n,k)} S(k,j)*\\frac{n!}{(n-j)!} \\times \\sum_{i=j}^{n} C_{(n-j)}^{(n-i)}$ . 我们还可以注意到，后面那个循环：当$i&lt;j$的时候，算出来的东西是没有意义的，因此我们可以改变循环范围为$i=0$ 来方便把那个难以计算的$\\sum$变为方便计算的$2^x$的形式 $\\sum_{j=0}^{min(n,k)} S(k,j)*\\frac{n!}{(n-j)!} \\times \\sum_{i=0}^{n} C_{(n-j)}^{(n-i)}$ . $\\sum_{j=0}^{min(n,k)} S(k,j)*\\frac{n!}{(n-j)!} \\times 2^{(n-j)}$ . 搞定，到目前为止，这里里面的所有东西都可以方便的求出来了： $S(k,j)$可以用$k^2$的递推暴力求算神犇们大可用FFT或NTT快速计算，可惜我太菜了并不会 $\\frac{n!}{(n-j)!}$可以用一个$O(k)$的暴力递推算即可 $2^{(n-j)}$…如果不会算的话请自行右上角 . 时间复杂度$O(n^2)$ 酱紫，这题就被我们A掉啦~ 撒花ヾ(●´∀｀●) . Code 123456789101112131415161718192021222324252627282930313233343536373839//CF932E Team Work//Jan,15th,2019//第二类斯特林数的应用+奇奇怪怪的推公式#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int poi=1000000007;long long FastPow(long long A,long long B)&#123; if(B==0) return 1; long long t_ans=FastPow(A,B/2); t_ans=t_ans*t_ans%poi; if(B%2==1) t_ans=t_ans*A%poi; return t_ans;&#125;const int N=5000+100;long long S[N][N],jc[N];int n,K;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;K); S[1][1]=1; for(int i=2;i&lt;=K;i++) for(int j=1;j&lt;=i;j++) S[i][j]=(S[i-1][j-1]+j*S[i-1][j])%poi; jc[0]=1; for(int i=1;i&lt;=K;i++) jc[i]=jc[i-1]*(n-i+1)%poi; long long ans=0; int t=min(n,K); for(int i=0;i&lt;=t;i++) ans+=S[K][i]*jc[i]%poi*FastPow(2,n-i),ans%=poi; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://www.goldenpotato.cn/categories/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"第二类斯特林数学习笔记","slug":"第二类斯特林数学习笔记","date":"2019-02-25T11:28:20.000Z","updated":"2019-02-25T11:28:20.000Z","comments":true,"path":"2019/02/25/第二类斯特林数学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本菜鸡尚未学会第二类斯特林数，请各位dalao不要相信本文的任何一个字 什么是第二类斯特林数 在组合数学，Stirling数可指两类数，第一类Stirling数和第二类Stirling数，都是由18世纪数学家James Stirling提出的。 Stirling数有两种，第一类和第二类Stirling数，它们自18世纪以来一直吸引许多数学家的兴趣，如欧拉、柯西、西尔沃斯特和凯莱等。后来哥本哈根（Copenhagen）大学的尼尔森（Niels Nielsen，1865-1931）提出了&quot;Stirlingschen Zahlen erster Art&quot; [第一类Stirling数]和&quot;Stirlingschen Zahlen zweiter Art&quot; [第二类Stirling数]，首次把这两类数冠以「Stirling数」之名 。因为苏格兰数学家斯特林（J. Stirling, 1692-1770）首次发现这些数并说明了它们的重要性。 ——百度百科 用人话来说，第二类斯特林数$S(i,j)$用来表示i个不一样的球放入j个相同盒子里的方案数。 怎么算第二类斯特林数 我们可以假设当前这个球是单独放一个盒子还是放入有别的球的盒子中，如果单独放一个盒子，显然答案为$S(i-1,j-1)$,如果放入别的盒子中，因为它放在不同的盒子后能与盒子中原本有的球组成不同的方案，因此我们要在$S(i-1,j)$前面乘以盒子总数$j$ 因此，我们可以得到以下递推式： $S(i,j)=S(i-1,j-1)+j*S(i-1,j)$ 还有一个我并不会证的通项公式，会证之后再补（咕咕咕） $S(n,m)={\\frac 1 {m!}}\\sum_{k=0}^m (-1)^k C(m,k)(m-k)^n$ 第二类斯特林数有啥性质 有且只有一个，而且我也不会证，会证后补（咕咕咕） $n^k=\\sum_ { i=0}^n S(k,i)×i!×C(n,i)$ 这个式子主要用于算一些蜜汁幂次方的时候可以用得到，例如这道题","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://www.goldenpotato.cn/categories/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"[Luogu P4777] 【模板】扩展中国剩余定理（EXCRT）","slug":"luogu-p4777-【模板】扩展中国剩余定理（excrt）","date":"2019-02-25T11:26:33.000Z","updated":"2019-02-25T11:26:33.000Z","comments":true,"path":"2019/02/25/luogu-p4777-【模板】扩展中国剩余定理（excrt）/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogu-p4777-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%88excrt%EF%BC%89/","excerpt":"","text":"题面 传送门：洛咕 Solution 真*扩展中国剩余定理模板题。我怎么老是在做模板题啊 但是这题与之前不同的是不得不写龟速乘了。 还有两个重点 我们在求LCM的时候，记得先/gcd再去乘另外那个数，直接乘会乘爆的 我们在做龟速乘之前，要保证要乘的两个数&gt;=0,如果&lt;0的话，龟速乘会爆掉的，我们传进去之间记得膜一下 int128:你说啥？这里风太大，我听不见。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Luogu P4777 【模板】扩展中国剩余定理（EXCRT）//Jan,15th,2019//中国剩余定理#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1;char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;long long take(long long A,long long B,long long poi)&#123; if(B==0) return 0; long long temp=take(A,B/2,poi)*2%poi; if(B%2==1) temp=(temp+A)%poi; return temp;&#125;long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)&#123; if(B==0) &#123; x=1,y=0; return A; &#125; long long t_ans=exgcd(B,A%B,x,y),tx=x; x=y,y=tx-(A/B)*y; return t_ans;&#125;const int N=100000+100;int n;long long a[N],p[N];int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) p[i]=read(),a[i]=read(); long long A=a[1],P=p[1]; for(int i=2;i&lt;=n;i++) &#123; long long x,y,gcd=exgcd(P,p[i],x,y); long long t_P=P,t=p[i]/gcd; x=(x%t+t)%t,x=take(x,(((a[i]-A)/gcd)%t+t)%t,t); P=P*(p[i]/gcd),A=(A+take(t_P,x,P))%P; &#125; printf(&quot;%lld&quot;,(A%P+P)%P); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"同余","slug":"同余","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8C%E4%BD%99/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[POJ 2891] Strange Way to Express Integers","slug":"poj-2891-strange-way-to-express-integers","date":"2019-02-25T11:24:58.000Z","updated":"2019-02-25T11:24:58.000Z","comments":true,"path":"2019/02/25/poj-2891-strange-way-to-express-integers/","permalink":"http://www.goldenpotato.cn/2019/02/25/poj-2891-strange-way-to-express-integers/","excerpt":"","text":"题面 传送门：POJ Solution 就是裸的扩展中国剩余定理嘛qwq 注意几点：一定要时时刻刻去膜取模，否则一定会爆long long，尤其是算出来的$k_0$ 这里给出几组易锅数据：(第三组容易爆long long) input: 1234567891011121314151617418373 161478614 149488440 1748022751 21618619576 810918992 241779667 1772616743 1953316358 125248280 2273149397 3849022001 2509433771 3885219405 35943 output 12313052907343337200-178383942913636233 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//POJ2891 Strange Way to Express Integers//Jan,14th,2019//扩展中国剩余定理#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)&#123; if(B==0) &#123; x=1,y=0; return A; &#125; long long t=exgcd(B,A%B,x,y),tx=x; x=y; y=tx-(A/B)*y; return t;&#125;long long lcm(long long A,long long B)&#123; long long tx,ty; return (A*B)/exgcd(A,B,tx,ty);&#125;const int N=100000+1000;long long r[N],p[N];int n;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) p[i]=read(),r[i]=read(); long long R=r[1],P=p[1]; bool OK=true; for(int i=2;i&lt;=n;i++) &#123; long long x,y,gcd=exgcd(P,p[i],x,y); if((r[i]-R)%gcd!=0) &#123; OK=false; break; &#125; long long t_P=P,t=p[i]/gcd; x*=(r[i]-R)/gcd,P=lcm(P,p[i]),x=(x%t+t)%t; R=((t_P*x)%P+R)%P; &#125; if(OK==true) printf(&quot;%lld\\n&quot;,(R%P+P)%P); else printf(&quot;-1\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"同余","slug":"同余","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8C%E4%BD%99/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"扩展中国剩余定理学习笔记","slug":"扩展中国剩余定理学习笔记","date":"2019-02-25T11:23:01.000Z","updated":"2019-02-25T11:23:01.000Z","comments":true,"path":"2019/02/25/扩展中国剩余定理学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"为什么要扩展中国剩余定理？ 建议学习前置芝士：中国剩余定理（不学也不要紧，因为并没有啥关系） 我们知道，中国剩余定理是用来解线性同余方程组的算法，类似下面这个： $x \\equiv a_0 (p_0)$ $x \\equiv a_1 (p_1)$ $x \\equiv a_2 (p_2)$ 很不幸，这里要求$p_0,p_1,p_2$两两互质 . 如果不互质怎么办？当然是把出题者拖出去吊起来打啊。这时候就得有请我们的扩展中国剩余定理了。 什么是扩展中国剩余定理？ 如上说述，就是用来求线性同余方程组的定理，但不要求p两两互质。 怎么扩展中国剩余定理？ 中国剩余定理的基本原则是将原方程组两两合并直至只有一个方程。 那咋合并呢？ 假设我们现在有两个同余方程： $x \\equiv a_0 (p_0)$ $x \\equiv a_1 (p_1)$ 我们可以先写出式子： $x=p_0*k_0+a_0=p_1*k_1+a_1$ 移项得（我们这里的k在R上任意取值，因此不用纠结它的符号）： $p_0*k_0+p_1*k_1=a_1-a_0$ emmmmm，这个式子是不是有一点点眼熟？ 没错，我们可以用exgcd来求这个$k_0$。 这里就引出了我们扩展中国剩余定理的有解的要求：$a_1-a_0$必须为$gcd(p_0,p_1)$的倍数 当然，我们右边的$a_1-a_0$不一定等于$gcd(p_0,p_1)$,因此，我们用exgcd算出来的$k_0$必须乘以$\\frac{a_1-a_0}{gcd(p_0,p_1)}$ 酱紫，我们将$k_0$膜$\\frac{p_1}{gcd(p_0,p_1)}$来得到$k_0$的最小正整数解。（原理请参考这篇文章） 接下来，我们可以通过这个神奇的公式(我并不懂为啥可以这样推)来把这两个式子整合起来： $x \\equiv p_0*k_0 + a_0 (lcm(p_0,p_1)) $ . 酱紫，我们就可以一步步把这个方程组浓缩成一个式子啦φ(&gt;ω&lt;*) 例题： 扩展中国剩余定理模板题：POJ2891","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"同余","slug":"同余","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8C%E4%BD%99/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"扩展欧几里得算法+推论","slug":"扩展欧几里得算法推论","date":"2019-02-25T11:21:55.000Z","updated":"2019-02-25T11:21:55.000Z","comments":true,"path":"2019/02/25/扩展欧几里得算法推论/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%8E%A8%E8%AE%BA/","excerpt":"","text":"什么是扩展欧几里得？ 扩展欧几里得算法是建立在欧几里得算法(gcd)之上。 首先，我们知道有$a_x+b_y=gcd(a,b)$ 我们怎么求这个$x,y$呢？ 这时候我们就得使用exgcd算法，我们来推导一下吧！ $ax+by=gcd(a,b)$ $ax+by=gcd(b,a% b)$ $ax+by=bx’+(a- \\left \\lfloor \\frac{a}{b} \\right \\rfloorb)*y’$ $ax+by= ay’+b(x’-\\left \\lfloor \\frac{a}{b} \\right \\rfloor*y’)$ 因此，根据系数对应，我们得到了 $x=y’$,$y=x’-\\left \\lfloor \\frac{a}{b} \\right \\rfloor*y’$ 那这个式子我们显然可以在递归里面顺带算出来嘛。 再想一想，我们gcd的递归出口为$b=0$，即$a*x=gcd(a,b)$,所以说我们的$x,y$的递归出口也为$x=1,y=0$ 代码大概长这样qwq： 123456789101112long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)&#123; if(B==0) &#123; x=1,y=0; return A; &#125; long long t=exgcd(B,A%B,x,y),tx=x; x=y; y=tx-(A/B)*y; return t;&#125; 酱紫，我们就求出了$x,y$的一组解$x_0,y_0$ 进一步推导 如果我们要求$x$的最小正整数解，那不免要求$x$的通项公式。 首先我们的推导建立在已经求出了一组$(x_0,y_0)$使得$a\\times x+b\\times y=gcd(a,b)$ 我们要求的$x$的通项公式是建立在$x_0$之上的，我们假设$x=x_0+p$，$y=y_0-q$ 现在问题就变为了如何求这个$p$。 原式变为： $$a(x_0+p)+b(y_0-q)=gcd(a,b)$$ 展开得： $$a_{x_0}+a_p+b_{y_0}-q_b=gcd(a,b)$$ 与原式$a_{x_0}+b_{y_0}=gcd(a,b)$相减得 $$ap=bq$$ $$p=\\frac{b*q}{a}$$ 我们设$d=gcd(a,b)$，有$a=a’_d$,$b=b’_d$ 将上一个式子上下同时除以$d$得 $$p=\\frac{b’*q}{a’}$$ 因为$p$为正整数，因此我们的$q$至少等于$a’$才能使得$p$的取值最小 $$p=b*\\frac{a’}{a}=b*\\frac{1}{d}=b*\\frac{1}{gcd(a,b)}$$ 解毕，我们得到了$x$的通项公式$x=x_0+k*\\frac{b}{gcd(a,b)}$ . 完结撒花(*´ﾟ∀ﾟ｀)ﾉ","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SPOJ16607 IE1 - Sweets","slug":"spoj16607-ie1-sweets","date":"2019-02-25T11:21:15.000Z","updated":"2019-02-25T11:21:15.000Z","comments":true,"path":"2019/02/25/spoj16607-ie1-sweets/","permalink":"http://www.goldenpotato.cn/2019/02/25/spoj16607-ie1-sweets/","excerpt":"","text":"题面 传送门： 洛咕 SPOJ Solution 这题的想法挺妙的。 . 首先，对于这种区间求答案的问题，我们一般都可以通过类似前缀和的思想一减来消去a，即求[a,b]的答案可以转化为求[1,b]-[1,a-1] 接下来我们可以先考虑一下每个物品数量不限制的做法。我们可以把这个问题类比为放球问题：我们要在n个相同的盒子里放x个球，这个问题可以用隔板法解决，显然答案为$C_{x+n-1}^{n-1}$ 因为我们的n特别小，而且p为合数，所以可以用分解质因数的方法来算这个组合数。 . 接下来，我们可以考虑一下如何处理多计算的答案，考虑用容斥定理来解决这个问题。 不了解容斥定理的同志可以先看一下这篇文章 我们要求的是至少有一个物品不满足要求的方案总数，即求所有不满足要求的方案的并。 根据容斥定理，这个并的值为 $\\sum有一个物品不满足要求-有两个物品不满足要求+有三个物品不满足要求-…$ 所以说，我们只需要强制某些物品先选$m_i+1$个，再按照上面的放球问题的公式来计算就可以得出有若干个物品不满足要求的方案数。 答案即为总方案数-不满足要求的方案数的并 时间复杂度$O(2^n*log_{max(a,b)})$ 这个问题就被我们切掉啦ヽ(￣▽￣)ﾉ . 如果有不清楚的地方可以看一下代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Luogu SP16607 IE1 - Sweets//Jan,14th,2019//容斥原理的应用#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int poi=2004;const int N=15;int prime[6]=&#123;-1,2,3,5,7&#125;;long long C(long long x,long long y)//x为底，y为指&#123; if(y&gt;x) return 0; int cnt[6]=&#123;0&#125;; long long t_ans=1; for(long long i=x-y+1;i&lt;=x;i++) &#123; long long t_num=i; for(int j=1;j&lt;=4;j++) while(t_num%prime[j]==0) &#123; t_num/=prime[j]; cnt[j]++; &#125; t_ans=(t_ans*t_num)%poi; &#125; for(long long i=1;i&lt;=y;i++) &#123; long long t_num=i; for(int j=1;j&lt;=4;j++) while(t_num%prime[j]==0) &#123; t_num/=prime[j]; cnt[j]--; &#125; &#125; for(int i=1;i&lt;=4;i++) while(cnt[i]&gt;0) t_ans=(t_ans*prime[i])%poi,cnt[i]--; return t_ans;&#125;int m[N],n,a,b;long long t_ans2,t_x;bool used[N];void dfs(int now)&#123; if(now==n+1) &#123; long long t_cnt=0,tot=0; for(int i=1;i&lt;=n;i++) if(used[i]==true) t_cnt+=m[i]+1,tot++; if(t_cnt&gt;t_x) return; long long f=(tot%2==1?-1:1); t_ans2+=f*C(t_x-t_cnt+n,n); t_ans2=(t_ans2%poi+poi)%poi; return; &#125; for(int i=0;i&lt;=1;i++) used[now]=i,dfs(now+1);&#125;long long Calc(long long x)&#123; t_ans2=0,t_x=x; dfs(1); return t_ans2;&#125;int main()&#123; n=read(),a=read(),b=read(); for(int i=1;i&lt;=n;i++) m[i]=read(); printf(&quot;%lld&quot;,((Calc(b)-Calc(a-1))%poi+poi)%poi); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"组合数学","slug":"组合数学","permalink":"http://www.goldenpotato.cn/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"http://www.goldenpotato.cn/categories/%E5%AE%B9%E6%96%A5/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"[Luogu P4124] [CQOI2016]手机号码","slug":"luogu-p4124-cqoi2016手机号码","date":"2019-02-25T11:20:25.000Z","updated":"2019-02-25T11:20:25.000Z","comments":true,"path":"2019/02/25/luogu-p4124-cqoi2016手机号码/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogu-p4124-cqoi2016%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81/","excerpt":"","text":"题面 传送门：洛咕 Solution 感谢神仙@lizbaka的教学 这题是数位DP的非常非常模板的题目，只是状态有点多 . 这题我使用记忆化搜索实现的 中国有句古话说的好，有多少个要求就设多少个状态。 所以说，考虑这样设置状态: 设$f[i][j][k][2][2][2][2][2]$表示当前填到第i位，上一位填了j，上两位填了k，是否卡上界，上一个数是否为前导零，是否有4，是否有8，是否出现了连续三个相同的数字，之后任意填的可行方案总数 使用记忆化搜索的话，转移是非常容易的，我们只需要像写搜索一样递归写下去就好 差不多长成这样： 1234567for(int i=0;i&lt;=(limit==true?l[to]:9);i++) &#123; if(zero==false or i!=0) t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],false,four or i==4,eight or i==8,ok==true or(last1==last2 and last2==i)); else t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],true,false,false,false); &#125; 注：此题不用讨论前导零，但是我为了模板的完整性，也加上了。 注意，递归算法一定要有出口，这里也不例外，出口为i==n+1（即已经填完了） 具体写法还请看代码 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Luogu P4124 [CQOI2016]手机号码//Jan,13rd,2019//测试递归实现数位DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=20;long long f[N][15][15][2][2][2][2][2];//位数，上一位，上两位，limit，zero，4，8，OKint n,l[N];long long dfs(int to,int last1,int last2,bool limit,bool zero,bool four,bool eight,bool ok)&#123; if(f[to][last1][last2][limit][zero][four][eight][ok]&gt;=0) return f[to][last1][last2][limit][zero][four][eight][ok]; long long t_ans=0; if(to==n+1) &#123; if((four and eight)==false and ok==true) t_ans=1; return f[to][last1][last2][limit][zero][four][eight][ok]=t_ans; &#125; for(int i=0;i&lt;=(limit==true?l[to]:9);i++) &#123; if(zero==false or i!=0) t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],false,four or i==4,eight or i==8,ok==true or(last1==last2 and last2==i)); else t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],true,false,false,false); &#125; return f[to][last1][last2][limit][zero][four][eight][ok]=t_ans;&#125;int main()&#123; long long ans[3]; for(int i=1;i&lt;=2;i++) &#123; long long t_num; scanf(&quot;%lld&quot;,&amp;t_num); if(i==1) t_num--; n=0; while(t_num!=0) l[++n]=t_num%10,t_num/=10; reverse(l+1,l+1+n); memset(f,0x80,sizeof f); dfs(1,0,0,true,true,false,false,false); ans[i]=f[1][0][0][true][true][false][false][false]; &#125; printf(&quot;%lld&quot;,ans[2]-ans[1]); return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E4%BD%8DDP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[UOJ 275/BZOJ4737] 【清华集训2016】组合数问题","slug":"uoj-275-bzoj4737-【清华集训2016】组合数问题","date":"2019-02-25T11:18:17.000Z","updated":"2019-02-25T11:18:17.000Z","comments":true,"path":"2019/02/25/uoj-275-bzoj4737-【清华集训2016】组合数问题/","permalink":"http://www.goldenpotato.cn/2019/02/25/uoj-275-bzoj4737-%E3%80%90%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%E3%80%91%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"题面 传送门：UOJ Solution 这题的数位DP好蛋疼啊qwq 好吧，我们说回正题。 首先，我们先回忆一下LUCAS定理： $C_n^m \\equiv C_{n/p}^{m/p} \\times C_{n\\%p}^{m\\%p} (\\%p)$ 我们仔细观察这个定理，就可以发现一个事实：LUCAS定理本质上是在对n，m两个数做K进制下的数位分离 所以说，LUCAS定理我们可以这样表示： $C_n^m \\equiv \\prod C_{a_i}^{b_i}$ （ai与bi为K进制拆分后的两个数的每一位数，若一个数的位数不足另一个数，则以前导零填充） 我们要判断一个$C_n^m$是否能被K整除，只需要保证其中一个$C_{a_i}^{b_i}$能被K整除（即同余K为零）就好。 又因为K为质数，且ai，bi均小于K，所以说我们要使得$C_{a_i}^{b_i}$为0，必须有$b_i$&gt;$a_i$ . . 所以说，问题就变为了对于有多少个$(i,j)$使得$j$中某一位$&gt;i$ 这个新的问题显然可以用数位DP来解决。 在这里，我使用记忆化搜索来写（用记忆化可以减少讨论数） 考虑这样设状态： 设$f[x][0/1][0/1][0/1][0/1][0/1]$表示填到第$x$位， i是否卡上界n，j是否卡上界m，j是否卡上界 $(j&lt;i)$,上一位是否为前导零（这道题不需要，但是为了模板完整性。我还是写上去了），之前是否有某一位达成需求，之后可以达成的总共的可行方案数 转移非常好讨论，我们只需要注意一下j的上界是两个限制的最小值就好。 我是这样写转移的： 12345678910for(int i=0;i&lt;=(limit1==true?l1[to]:K);i++) &#123; int t_j=(limit2==true?l2[to]:K); t_j=(limit3==true?min(i,t_j):t_j); for(int j=0;j&lt;=t_j;j++) &#123; t_ans+=dfs(to+1,limit1==true and i==l1[to],limit2==true and j==l2[to],limit3==true and j==i,zero==true and i==0,OK==true or j&gt;i); t_ans%=poi; &#125; &#125; 这样子写，看起来时间复杂度是 $O(T*n^2*2^5)$ 但是因为我们会少讨论很多没有意义的情况，所以说能跑得过去。 确切复杂度我不会算qwq 还请dalao们指点 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//BZOJ 4737: 组合数问题//Jan,14th,2019//LUCAS定理的运用+鬼畜数位DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int poi=1000000007;const int N=70;long long f[N][2][2][2][2][2];//到i位，底数卡不卡n，指数卡不卡m，指数卡不卡底数，zero，OKint n,l1[N],l2[N],K;long long dfs(int to,bool limit1,bool limit2,bool limit3,bool zero,bool OK)&#123; if(f[to][limit1][limit2][limit3][zero][OK]&gt;=0) return f[to][limit1][limit2][limit3][zero][OK]; long long t_ans=0; if(to==n+1) &#123; if(OK==true) t_ans=1; return f[to][limit1][limit2][limit3][zero][OK]=t_ans; &#125; for(int i=0;i&lt;=(limit1==true?l1[to]:K);i++) &#123; int t_j=(limit2==true?l2[to]:K); t_j=(limit3==true?min(i,t_j):t_j); for(int j=0;j&lt;=t_j;j++) &#123; t_ans+=dfs(to+1,limit1==true and i==l1[to],limit2==true and j==l2[to],limit3==true and j==i,zero==true and i==0,OK==true or j&gt;i); t_ans%=poi; &#125; &#125; return f[to][limit1][limit2][limit3][zero][OK]=t_ans;&#125;int main()&#123; int T=read();K=read(); for(;T&gt;0;T--) &#123; n=0; long long num1=read(),num2=read(); num2=min(num1,num2);//防止m&gt;n while(num1!=0) l1[++n]=num1%K,num1/=K; for(int i=1;i&lt;=n;i++) l2[i]=num2%K,num2/=K; reverse(l1+1,l1+1+n); reverse(l2+1,l2+1+n); memset(f,0x80,sizeof f); K--; dfs(1,true,true,true,true,false); K++; printf(&quot;%lld\\n&quot;,f[1][true][true][true][true][false]); &#125; return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E4%BD%8DDP/"},{"name":"LUCAS","slug":"LUCAS","permalink":"http://www.goldenpotato.cn/categories/LUCAS/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"一些很妙的网站","slug":"一些很妙的网站","date":"2019-02-25T11:16:58.000Z","updated":"2019-02-25T11:16:58.000Z","comments":true,"path":"2019/02/25/一些很妙的网站/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E4%B8%80%E4%BA%9B%E5%BE%88%E5%A6%99%E7%9A%84%E7%BD%91%E7%AB%99/","excerpt":"","text":"米奇妙♂妙♂屋 1.妙不可言的一键作图网站 https://csacademy.com/app/graph_editor/ （抄自神仙lbc的博客） 2.妙妙识图网站 http://www.iqdb.org/ 3.妙妙图床 https://imgchr.com/ 4.妙妙sitemap自动生成网站 https://www.xml-sitemaps.com/ 5.不可描述 https://blog.sprov.xyz/2019/08/03/v2-ui/","categories":[{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"颓废","slug":"颓废","permalink":"http://www.goldenpotato.cn/tags/%E9%A2%93%E5%BA%9F/"}]},{"title":"[Luogu P3157][CQOI2011]动态逆序对","slug":"luogu-p3157cqoi2011动态逆序对","date":"2019-02-25T11:14:26.000Z","updated":"2019-02-25T11:14:26.000Z","comments":true,"path":"2019/02/25/luogu-p3157cqoi2011动态逆序对/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogu-p3157cqoi2011%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/","excerpt":"","text":"题面 传送门：洛谷 Solution 一开始我看到pty巨神写这套题的时候，第一眼还以为是个SB题：这不直接开倒车线段树统计就完成了吗？ 然后冷静思考了一分钟，猛然发现单纯的线段树并不能解决这个问题，好像还要在外面再套上一颗树。 这就很shit了。你问我资磁不资磁树套树，我是不资磁的，树套树是暴力数据结构，我能资磁吗？ 很不幸，昨天现实狠狠地打了我一脸：时间不够开新坑的，不切题又浑身难受，找了半天题，还是把这道题拉了出来（哈，真香） 不扯淡了，这题还是很显然的。 考虑开倒车，我们一个一个往里面加树，然后统计一下这个数能对当前的数列有多少贡献，贡献很容易想到：我们只需要找到在他后面比他小的数以及在他前面比他大的数就好。 然后本蒟蒻写了个蜜汁线段树套splay。 时间复杂度是$O(n∗log2n)$，空间复杂度为$O(n∗logn)$。理论上应该能过 可惜现实非常苦感： … 那咋搞啊。 那我上个线段树套权值线段树吧 然后又码了半个小时。 时空复杂度均为$O(n∗log2n)$ (这明显要MLE啊，问题是题解蜜汁能过) 可惜现实依旧苦感： 难道，改数据了？ 接着，我copy了一发题解，交上去，A掉了… 到目前为止，我还是想不通为啥开同样的数组，他A了，我T了。难道说他外层套的树状数组可以有效减少空间的消耗？ 想不通，还请各位dalao赐教。 Code （并不能A） 线段树套splay： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+1000;struct TreeInTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) #define root son[r][1] static const int M=N*25; int fa[M],son[M][2],size[M],cnt[M],num[M],to; inline void update(int x) &#123; size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x]; &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; son[z][y==son[z][1]]=x,fa[x]=z; son[y][!type]=son[x][type],fa[son[x][type]]=y; son[x][type]=y,fa[y]=x; update(y),update(x); &#125; void splay(int x,int to) &#123; while(fa[x]!=to) &#123; if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and fa[fa[x]]!=to) rotate(fa[x],x==son[fa[x]][0]); rotate(x,x==son[fa[x]][0]); &#125; &#125; void Insert(int w,int r) &#123; if(root==0) &#123; root=++to,fa[root]=r; num[root]=w,update(root); return; &#125; int now=root,last=root; while(now!=0) last=now,now=son[now][w&gt;num[now]]; now=++to,fa[now]=last,son[last][w&gt;num[last]]=now; num[now]=w,update(now); splay(now,r); &#125; int Query1(int x,int r) &#123; int now=root,ans=0; while(now!=0) &#123; if(num[now]&gt;=x) now=son[now][0]; else &#123; if(num[now]&gt;num[ans]) ans=now; now=son[now][1]; &#125; &#125; if(ans==0) return 0; splay(ans,r); return size[son[ans][0]]+cnt[ans]; &#125; int Query2(int x,int r) &#123; int now=root,ans=0; num[0]=0x3f3f3f3f; while(now!=0) &#123; if(num[now]&gt;x) &#123; if(num[now]&lt;num[ans]) ans=now; now=son[now][0]; &#125; else now=son[now][1]; &#125; num[0]=0; if(ans==0) return 0; splay(ans,r); return size[son[ans][1]]+cnt[ans]; &#125; int t[N&lt;&lt;2]; void Build(int now,int now_l,int now_r) &#123; t[now]=++to; if(now_l==now_r) return; Build(lson,now_l,mid); Build(rson,mid+1,now_r); &#125; inline void Insert2(int x,int w,int now,int now_l,int now_r) &#123; Insert(w,t[now]); if(now_l!=now_r) &#123; if(x&lt;=mid) Insert2(x,w,lson,now_l,mid); else Insert2(x,w,rson,mid+1,now_r); &#125; &#125; int Query3(int l,int r,int w,int type,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; if(type==1) return Query1(w,t[now]); else return Query2(w,t[now]); &#125; int sum=0; if(l&lt;=mid) sum+=Query3(l,r,w,type,lson,now_l,mid); if(r&gt;mid) sum+=Query3(l,r,w,type,rson,mid+1,now_r); return sum; &#125; #undef mid #undef lson #undef rson&#125;tit;int n,m,p[N],q[N],unOK[N];long long ans[N];int main()&#123; freopen(&quot;3157.in&quot;,&quot;r&quot;,stdin); freopen(&quot;3157.out&quot;,&quot;w&quot;,stdout); int t=clock(); n=read(),m=read(); for(int i=1;i&lt;=n;i++) p[read()]=i; for(int i=1;i&lt;=m;i++) q[i]=read(),unOK[q[i]]=true; tit.Build(1,1,n); for(int i=1;i&lt;=n;i++) if(unOK[i]==false) &#123; tit.Insert2(p[i],i,1,1,n); ans[m+1]+=tit.Query3(p[i],n,i,1,1,1,n)+tit.Query3(1,p[i],i,2,1,1,n); &#125; for(int i=m;i&gt;=1;i--) &#123; tit.Insert2(p[q[i]],q[i],1,1,n); ans[i]=ans[i+1]+tit.Query3(p[q[i]],n,q[i],1,1,1,n)+tit.Query3(1,p[q[i]],q[i],2,1,1,n); &#125; for(int i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,ans[i]); cerr&lt;&lt;clock()-t&lt;&lt;endl; return 0;&#125; 线段树套权值线段树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+1000;int n,m,p[N],q[N],unOK[N];long long ans[N];struct TreeInTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) static const int M=N*200; int son[M][2],num[M],to; inline void update(int x) &#123; num[x]=num[son[x][0]]+num[son[x][1]]; &#125; void Insert(int x,int now,int now_l,int now_r) &#123; if(now_l==now_r) &#123; num[now]++; return; &#125; if(now&gt;to) cerr&lt;&lt;to; if(x&lt;=mid) &#123; if(son[now][0]==0) son[now][0]=++to; Insert(x,son[now][0],now_l,mid); &#125; else &#123; if(son[now][1]==0) son[now][1]=++to; Insert(x,son[now][1],mid+1,now_r); &#125; update(now); &#125; int Query1(int l,int r,int now,int now_l,int now_r) &#123; if(l&gt;r) return 0; if((now_l&gt;=l and now_r&lt;=r) or now==0) return num[now]; int t_ans=0; if(l&lt;=mid) t_ans+=Query1(l,r,son[now][0],now_l,mid); if(r&gt;mid) t_ans+=Query1(l,r,son[now][1],mid+1,now_r); return t_ans; &#125; int t[N&lt;&lt;2]; void Build(int now,int now_l,int now_r) &#123; t[now]=++to; if(now_l==now_r) return; Build(lson,now_l,mid); Build(rson,mid+1,now_r); &#125; inline void Insert2(int x,int w,int now,int now_l,int now_r) &#123; Insert(w,t[now],1,n); if(now_l!=now_r) &#123; if(x&lt;=mid) Insert2(x,w,lson,now_l,mid); else Insert2(x,w,rson,mid+1,now_r); &#125; &#125; int Query3(int l,int r,int w,int type,int now,int now_l,int now_r) &#123; if(now_l&gt;=l and now_r&lt;=r) &#123; if(type==1) return Query1(1,w-1,t[now],1,n); else return Query1(w+1,n,t[now],1,n); &#125; int sum=0; if(l&lt;=mid) sum+=Query3(l,r,w,type,lson,now_l,mid); if(r&gt;mid) sum+=Query3(l,r,w,type,rson,mid+1,now_r); return sum; &#125; #undef mid #undef lson #undef rson&#125;tit;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) p[read()]=i; for(int i=1;i&lt;=m;i++) q[i]=read(),unOK[q[i]]=true; tit.Build(1,1,n); for(int i=1;i&lt;=n;i++) if(unOK[i]==false) &#123; tit.Insert2(p[i],i,1,1,n); ans[m+1]+=tit.Query3(p[i],n,i,1,1,1,n)+tit.Query3(1,p[i],i,2,1,1,n); &#125; for(int i=m;i&gt;=1;i--) &#123; tit.Insert2(p[q[i]],q[i],1,1,n); ans[i]=ans[i+1]+tit.Query3(p[q[i]],n,q[i],1,1,1,n)+tit.Query3(1,p[q[i]],q[i],2,1,1,n); &#125; for(int i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,ans[i]); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树套树","slug":"树套树","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%A5%97%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P3203] [HNOI2010]弹飞绵羊","slug":"luogu-p3203-hnoi2010弹飞绵羊","date":"2019-02-25T11:10:25.000Z","updated":"2019-02-25T11:10:25.000Z","comments":true,"path":"2019/02/25/luogu-p3203-hnoi2010弹飞绵羊/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogu-p3203-hnoi2010%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A/","excerpt":"","text":"题面 传送门：洛谷 Solution 这题其实是有类似模型的。 我们先考虑不修改怎么写。考虑这样做：每个点向它跳到的点连一条边，最后肯定会连成一颗以n+1为根的树（我们拿n+1代表被弹出去了）。题目所问的即是某个点到树根的链的长度。 那么，如果我们加上修改，显然，某个点连向的点会发生改变。对于一个能修改边的树，我们可以很自然的想到用LCT维护之。 至于怎么求某条链的长度呢？这也是LCT的基础操作之一，我们只需要先MakeRoot（n+1），然后再Acess（x），splay（x）就可以把这条链拉出来了，我们维护splay的size就好。 如果您看不懂上面这句话，请戳我来学习LCT与原树的对应关系 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//Luogu P3203 [HNOI2010]弹飞绵羊//Jan,9th,2018//LCT模板题II#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=200000+100;int n,m;struct LCT&#123; int son[N][2],fa[N],lazy[N],mstack[N],top,size[N]; inline bool isRoot(int x) &#123; return x!=son[fa[x]][0] &amp;&amp; x!=son[fa[x]][1]; &#125; inline void update(int x) &#123; size[x]=size[son[x][0]]+size[son[x][1]]+1; &#125; inline void mirror(int x) &#123; lazy[x]=!lazy[x],swap(son[x][0],son[x][1]); &#125; inline void pushDown(int x) &#123; if(lazy[x]==0) return; lazy[x]=0; mirror(son[x][0]),mirror(son[x][1]); &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; if(isRoot(y)==false) son[z][y==son[z][1]]=x; fa[x]=z; son[y][!type]=son[x][type],fa[son[x][type]]=y; son[x][type]=y,fa[y]=x; update(y),update(x); &#125; void splay(int x) &#123; mstack[top=1]=x; for(int i=x;isRoot(i)==false;i=fa[i]) mstack[++top]=fa[i]; for(int i=top;i&gt;=1;i--) pushDown(mstack[i]); while(isRoot(x)==false) &#123; if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and isRoot(fa[x])==false) rotate(fa[x],x==son[fa[x]][0]), rotate(x,x==son[fa[x]][0]); else rotate(x,x==son[fa[x]][0]); &#125; &#125; void Access(int x) &#123; for(int t=0;x!=0;t=x,x=fa[x]) splay(x),son[x][1]=t,fa[t]=x,update(x); &#125; inline void MakeRoot(int x) &#123; Access(x),splay(x); mirror(x); &#125; inline void Link(int x,int y)//x翻为根连向y &#123; MakeRoot(x); fa[x]=y; &#125; inline void split(int x,int y)//y为根 &#123; MakeRoot(x); Access(y),splay(y); &#125; inline void Cut(int x,int y) &#123; split(x,y); son[y][0]=fa[x]=0; update(y); &#125; int Query(int x) &#123; MakeRoot(n+1); Access(x),splay(x); return size[x]-1; &#125;&#125;lct;int q[N];int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) q[i]=read(); for(int i=n;i&gt;=1;i--) if(i+q[i]&gt;n) lct.Link(i,n+1); else lct.Link(i,i+q[i]); m=read(); for(int i=1;i&lt;=m;i++) &#123; int op=read(); if(op==1) &#123; int x=read()+1; printf(&quot;%d\\n&quot;,lct.Query(x)); &#125; else &#123; int x=read()+1,K=read(); if(x+q[x]&gt;n) lct.Cut(x,n+1); else lct.Cut(x,x+q[x]); q[x]=K; if(x+q[x]&lt;=n) lct.Link(x,x+q[x]); else lct.Link(x,n+1); &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[LuoguP2147] [SDOI2008]洞穴勘测","slug":"luogup2147-sdoi2008洞穴勘测","date":"2019-02-25T11:07:56.000Z","updated":"2019-02-25T11:07:56.000Z","comments":true,"path":"2019/02/25/luogup2147-sdoi2008洞穴勘测/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogup2147-sdoi2008%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/","excerpt":"","text":"题面 传送门：洛谷 Solution 这题… 我们可以发现题目要求我们维护一个动态森林，而且只查询连通性… 显然LCT模板题啊，关于LCT玩法，可以猛戳这里学习 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=10000+100;struct LCT&#123; int fa[N],son[N][2],lazy[N],mstack[N],top; inline bool isRoot(int x) &#123; return x!=son[fa[x]][0]&amp;&amp;x!=son[fa[x]][1]; &#125; inline void pushdown(int x) &#123; if(lazy[x]==0) return; lazy[son[x][0]]=!lazy[son[x][0]],swap(son[son[x][0]][0],son[son[x][0]][1]); lazy[son[x][1]]=!lazy[son[x][1]],swap(son[son[x][1]][0],son[son[x][1]][1]); lazy[x]=0; &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; if(isRoot(y)==false) son[z][y==son[z][1]]=x; fa[x]=z; fa[son[x][type]]=y,son[y][!type]=son[x][type]; son[x][type]=y,fa[y]=x; &#125; void splay(int x) &#123; mstack[top=1]=x; for(int i=x;isRoot(i)==false;i=fa[i]) mstack[++top]=fa[i]; for(int i=top;i&gt;=1;i--) pushdown(mstack[i]); while(isRoot(x)==false) &#123; if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and isRoot(fa[x])==false) rotate(fa[x],x==son[fa[x]][0]), rotate(x,x==son[fa[x]][0]); else rotate(x,x==son[fa[x]][0]); &#125; &#125; void Access(int x) &#123; for(int t=0;x!=0;t=x,x=fa[x]) splay(x),son[x][1]=t; &#125; void MakeRoot(int x) &#123; Access(x); splay(x); lazy[x]=!lazy[x],swap(son[x][0],son[x][1]); &#125; int FindRoot(int x) &#123; Access(x),splay(x); while(son[x][0]!=0) pushdown(x),x=son[x][0]; return x; &#125; void Link(int x,int y) &#123; MakeRoot(x); fa[x]=y; &#125; void split(int x,int y) &#123; MakeRoot(x); Access(y),splay(y); &#125; void Cut(int x,int y) &#123; split(x,y); son[y][0]=fa[x]=0; &#125;&#125;lct;int n,m;int main()&#123; n=read(),m=read(); char OP[15]; for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%s&quot;,OP+1); int u=read(),v=read(); if(OP[1]==&#x27;C&#x27;) lct.Link(u,v); else if(OP[1]==&#x27;D&#x27;) lct.Cut(u,v); else &#123; if(lct.FindRoot(u)==lct.FindRoot(v)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"LCT学习笔记","slug":"lct学习笔记","date":"2019-02-25T11:04:44.000Z","updated":"2019-02-25T11:04:44.000Z","comments":true,"path":"2019/02/25/lct学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/lct%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"为啥要学LCT啊 在开坑之间，我们来先看一段对话： Q：给你一颗森林，现在不断的连接森林中的两棵树，保证不连出环，多次问你某两个点的连通性？ A（dalao&amp;蒟蒻）：这不是SB题吗？显然并查集水过啊。 Q：说的好，但是如果我要删除某些边呢？ A（dalao）：那就可持久化并查集啊，你的问题怎么那么水。 A（蒟蒻）：…（发出gg的声音） 这时候，如果我们并不想写可持久化并查集的话，就得请出我们大名鼎鼎的林特卡特树了。 啥是林特卡特树啊 LCT实质上就是用splay+树剖思想维护的动态森林。 用人话来说，就是维护一个可以随便删边和连边的森林（注：不能连出环来） LCT的基础功能有： 1.连接森林中的两棵树或删除某条边 2.维护这颗森林的连通性 3.内定森林中某颗树的根 事实上，LCT还可以做一些包括但不限于维护一些奇奇怪怪的值的鬼畜操作。 咋林特卡特树啊 首先呢，我们的得先了解LCT树[注1]与原森林的关系。 我们的LCT树是由一堆连通块组成的，一个连通块就是原森林中的一颗树。 而每个连通块又由一堆splay组成，每个splay可以理解为每颗原树中树链剖分上的重边。splay与splay之间又有连接关系，即一颗splay的根单向连到另外一颗splay的孩子上，这一堆有单向关系的splay就构成了一个联通块。（可以对应的理解为一个树的树链剖分是有一堆重链组成的，重链在这里以splay的形式出现）。 注1：（虽然这样叫是绝对不正确的，因为T就是tree的缩写，但是为了与LCT算法分开来，我们姑且把LCT维护的东西叫做LCT树） Acess： 由上定义可以看出，我们要对某个点操作，首先要把这个点的连通块给提到LCT树的根上来（可以类比为splay到根上来），然后还要把这个splay连到到LCT树的根所在的重链上去。 听起来很复杂对不对？的确挺复杂。但是这个操作是LCT最基本的操作，其他所有操作都围绕着它展开。 具体原理可以参考这篇博客的介绍，这里只讲做法： 我们把当前操作的点先splay至它所在的splay的根，把这个根的右孩子连至上一次这样操作的根（即连一条重链），对当前点的父亲重复这个过程。 大概是长成这样： 1234inline void Access(int x) &#123; for(int t=0;x!=0;t=x,x=fa[x]) Splay(x),son[x][1]=t,fa[t]=x,Update(x);//注意这里的update，因为孩子关系变了，要更新根节点的数据 GetRoot: 我们要判断原森林中两个点的连通性，你第一反应是什么？没错，我们只需要判断它们的根是否相同就可以了。因此，我们这里就需要一个getroot函数来得到每个点的根。 方法很简单：我们只需要先Acess这个点使得它所在的splay连通块作为LCT森林的根，把这个点splay到根，再一路向左找就好（因为原树中的根的深度一定是最小的） 代码大概长这样： 12345678inline int FindRoot(int x) &#123; Access(x),Splay(x); while(son[x][0]!=0) PushDown(x),x=son[x][0]; Splay(x);//这里splay是为了让这个点所在的splay更平衡一点 return x; &#125; MakeRoot: 我们既然维护的是一颗动态的森林，那难免会有连边和删边。为了操作的方便，有时我们需要内定一个点作为原森林中的它所在的树的根。 具体做法是这样的：我们先把它Acess(x),splay(x)，让它先处于LCT森林的根，然后在把它的左右子树彻底翻转（即每个孩子都翻转），这里可以通过打标记来降低复杂度。（原理请看上面的链接的博客） 代码这样： 12345inline void MakeRoot(int x) &#123; Access(x),Splay(x); Mirror(x); &#125; Link: LCT既然维护了一个森林，连连边都做不了，岂不是很丢人？ link的意思是连接原森林中的一条边。 我们只需要这样做：先getroot来判断一下他们是否已经在同一颗树上了，然后makeroot（x）来内定x作为它所在的树的根，再指定一下它的父亲为y即可（即连一条轻边） 1234567inline int Link(int x,int y)//x-&gt;y &#123; if(FindRoot(x)==FindRoot(y)) return 1; MakeRoot(x); fa[x]=y; return 0; &#125; Split： 我们有时候要在LCT中拉出原森林中的一条边来获取信息或搞点事情，因此，我们需要一个函数来处理这破事。 我们只需要先内定x为根，然后再Acess(y)，splay(y)，此时，如果这条边存在的话，那么x一定是y的左孩子（因为它们深度相邻且x比y浅） 代码长这样： 12345inline void Split(int x,int y)//y为根 &#123; MakeRoot(x); Access(y),Splay(y); &#125; Cut LCT的意义就在于此（如果不能Cut，那连并查集都不如，人家一个log，LCT两个log呢），我们需要删除原森林中的一条边的时候，就需要cut操作了。 具体方法如下：先把这条边拉出来(Split)，然后再检查一下边是否存在，存在的话双向断边即可。 代码长这样： 1234567891011inline int Cut(int x,int y) &#123; Split(x,y); if(fa[x]==y and son[y][0]==x) &#123; fa[x]=son[y][0]=0; Update(y); return 0; &#125; return 1; &#125; 以上就是LCT的基本操作啦，如果有别的需求，我们可以在splay上多记录一点东西（正如之前专门考splay的题一样）就可以搞定啦。 恭喜你学会了LCT，撒花✿✿ヽ(°▽°)ノ✿ 有啥题目练啊 1.P2147 [SDOI2008]洞穴勘测 （LCT维护森林连通性） 2.P3203 [HNOI2010]弹飞绵羊 （LCT维护森林中的每棵树的长度） 3.P2168 [NOI2015]荷马史诗 （LCT维护边权和）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"[Luogu P2387] [NOI2014]魔法森林","slug":"luogu-p2387-noi2014魔法森林","date":"2019-02-25T10:52:58.000Z","updated":"2019-02-25T10:52:58.000Z","comments":true,"path":"2019/02/25/luogu-p2387-noi2014魔法森林/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogu-p2387-noi2014%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/","excerpt":"","text":"题面 传送门：洛谷 Solution 这题的思想挺好的。 对于这种最大值最小类的问题，很自然的可以想到二分答案。很不幸的是，这题是双关键字排序的，我们怎么二分呢？ 先二分a再二分b？怎么看都布星啊。 那a+b作为关键字二分？也布星啊。 那咋搞啊？ 不如，我们换个想法，我们把其中一个关键字枚举，再看在这个关键字的限制下，另外一个尽可能小。 仔细想想，应该是能覆盖到所有的情况的。 所以说，我们可考虑这样做：我们先枚举a的大小（即所选的边的a必须小于这个值），在满足前者的条件下，使得从出发先到终点的路上的最大的b尽可能小。 对于第二个问题，是不是很眼熟？没错，这个问题就是著名的原题货车运输：我们要使得路径上经过的b值的最大值最小，这条路径一定是在以b为关键字的最小生成树上的（具体证明请移步货车运输那道题的题解）。 所以说，我们现在研究的问题就变为了如何快速的维护一个变化的最小生成树。 快速维护变化的树，我们可以很自然地想到使用LCT来维护。再结合我们之前维护动态最小生存树的知识：每加入一条边，它必定会连接两个点而形成一个环，我们要判断这条边是否会在新的生成树上，只需要看一下环上的最大的边权和这条边的关系就好了，如果这条边的边权比环上的最大值还要小，我们就可以把环上的那条最大的边断开，接上我们这条新的边。否则的话，这条边一定不会成为新的最小生成树的一部分。 所以说，我们的LCT只需要在每新加入一条边时，检查其连接的两端是否是联通的。如果不联通的话，加入这条边一定是没有问题的。如果联通的话，就把所连两端的链split出来，找到最大值，比较一下大小关系就好。 至于如何用LCT维护边，我的方法是用点来代替边，即一条边以一个有连向它的两个端点的边的点来替代。具体写法可以参照一下代码。 时间复杂度为$O(n∗logn∗logn)$ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int M=100000+100;const int N=50000+100;const int T=N+M;struct road&#123; int s,t,a,b;&#125;e[M];int n,m;bool cmp(road x,road y)&#123; return x.a&lt;y.a;&#125;struct LCT&#123; int son[T][2],fa[T],lazy[T],MAX[T],num[T],mstack[T],top; inline void Update(int x) &#123; MAX[x]=0; if(num[MAX[son[x][0]]]&gt;=num[x] and num[MAX[son[x][0]]]&gt;=num[MAX[son[x][1]]]) MAX[x]=MAX[son[x][0]]; if(num[MAX[son[x][1]]]&gt;=num[x] and num[MAX[son[x][1]]]&gt;=num[MAX[son[x][0]]]) MAX[x]=MAX[son[x][1]]; if(num[x]&gt;=num[MAX[son[x][0]]] and num[x]&gt;=num[MAX[son[x][1]]]) MAX[x]=x; &#125; inline void Mirror(int x) &#123; lazy[x]=!lazy[x],swap(son[x][0],son[x][1]); &#125; inline void PushDown(int x) &#123; if(lazy[x]==0) return; lazy[x]=0; Mirror(son[x][0]),Mirror(son[x][1]); &#125; inline bool IsRoot(int x) &#123; return x!=son[fa[x]][0] and x!=son[fa[x]][1]; &#125; inline void Rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; if(IsRoot(y)==false) son[z][y==son[z][1]]=x; fa[x]=z; son[y][!type]=son[x][type],fa[son[x][type]]=y; son[x][type]=y,fa[y]=x; Update(y),Update(x); &#125; inline void Splay(int x) &#123; mstack[top=1]=x; for(int i=x;i!=0;i=fa[i]) mstack[++top]=fa[i]; for(int i=top;i&gt;=1;i--) PushDown(mstack[i]); while(IsRoot(x)==false) &#123; if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and IsRoot(fa[x])==false) Rotate(fa[x],x==son[fa[x]][0]), Rotate(x,x==son[fa[x]][0]); else Rotate(x,x==son[fa[x]][0]); &#125; &#125; void Access(int x) &#123; for(int t=0;x!=0;t=x,x=fa[x]) Splay(x),son[x][1]=t,fa[t]=x,Update(x); &#125; inline void MakeRoot(int x) &#123; Access(x),Splay(x); Mirror(x); &#125; inline int FindRoot(int x) &#123; Access(x),Splay(x); while(son[x][0]!=0) PushDown(x),x=son[x][0]; Splay(x); return x; &#125; inline void Link(int x,int y)//x-&gt;y &#123; if(FindRoot(x)==FindRoot(y)) return; MakeRoot(x); fa[x]=y; &#125; inline void Split(int x,int y)//root:y &#123; MakeRoot(x); Access(y),Splay(y); &#125; inline void Cut(int x,int y) &#123; Split(x,y); if(x==son[y][0] and fa[x]==y) &#123; son[y][0]=fa[x]=0; Update(y); &#125; &#125; inline int Query(int x,int y) &#123; MakeRoot(x); Access(y),Splay(y); return MAX[y]; &#125; inline void AddLine(int x) &#123; if(e[x].s==e[x].t) return;//自环 num[n+x]=e[x].b,MAX[n+x]=n+x; if(FindRoot(e[x].s)!=FindRoot(e[x].t)) &#123; Link(n+x,e[x].s),Link(n+x,e[x].t); return ; &#125; int t=Query(e[x].s,e[x].t); if(num[n+x]&lt;num[t]) &#123; Cut(e[t-n].s,t); Cut(e[t-n].t,t); Link(e[x].s,n+x); Link(e[x].t,n+x); &#125; &#125; inline int Query2() &#123; if(FindRoot(n)!=FindRoot(1)) return 0x3f3f3f3f; return num[Query(1,n)]; &#125;&#125;lct;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) e[i].s=read(),e[i].t=read(),e[i].a=read(),e[i].b=read(); sort(e+1,e+1+m,cmp); int ans=0x3f3f3f3f; for(int i=1;i&lt;=m;i++) &#123; lct.AddLine(i); ans=min(ans,e[i].a+lct.Query2()); &#125; if(ans==0x3f3f3f3f) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P4178]Tree","slug":"luogu-p4178tree","date":"2019-02-25T10:08:21.000Z","updated":"2019-02-25T10:08:21.000Z","comments":true,"path":"2019/02/25/luogu-p4178tree/","permalink":"http://www.goldenpotato.cn/2019/02/25/luogu-p4178tree/","excerpt":"","text":"题面 传送门：洛谷 Solution 首先，长成这样的题目一定是淀粉质跑不掉了。 考虑到我们不知道K的大小，我们可以开一个splay来统计比某个数小的数的数量。 不会点分治的戳我 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=40000+100;struct road&#123; long long w; int to; road(int A,long long B) &#123; to=A,w=B; &#125;&#125;;struct SBT&#123; #define root son[0][1] int fa[N],son[N][2],w[N],size[N],cnt[N],to; inline void update(int now) &#123; size[now]=size[son[now][0]]+size[son[now][1]]+cnt[now]; &#125; inline void rotate(int x,int type) &#123; int y=fa[x],z=fa[y]; fa[x]=z,son[z][y==son[z][1]]=x; son[y][!type]=son[x][type],fa[son[x][type]]=y; son[x][type]=y,fa[y]=x; update(y),update(x); &#125; void splay(int now,int to) &#123; while(fa[now]!=to) &#123; if(now==son[fa[now]][fa[now]==son[fa[fa[now]]][1]] and fa[fa[now]]!=to) rotate(fa[now],now==son[fa[now]][0]), rotate(now,now==son[fa[now]][0]); else rotate(now,now==son[fa[now]][0]); &#125; &#125; inline void InitTree() &#123; root=to=0; &#125; inline void init(int now) &#123; fa[now]=son[now][0]=son[now][1]=size[now]=w[now]=0; &#125; void Insert(int num) &#123; if(root==0) &#123; root=++to; init(root); fa[root]=0; w[root]=num,cnt[root]=1,update(root); return; &#125; int now=root,last=root; while(now!=0) &#123; if(w[now]==num) &#123; cnt[now]++; splay(now,0); return; &#125; last=now,now=son[now][num&gt;w[now]]; &#125; now=++to,init(now); w[now]=num,cnt[now]=1; fa[now]=last,son[last][num&gt;w[last]]=now; update(now),splay(now,0); &#125; int Query(int num) &#123; int now=root,t_ans=0; while(now!=0) &#123; if(num&gt;=w[now]) &#123; if(w[now]&gt;=w[t_ans]) t_ans=now; now=son[now][1]; &#125; else now=son[now][0]; &#125; if(t_ans==0) return 0; splay(t_ans,0); return size[son[root][0]]+cnt[root]; &#125; #undef root&#125;sbt;vector &lt;road&gt; e[N];long long n,K;bool vis[N],t_vis[N],done[N];int size[N],cnt,root;int GetSize(int now)&#123; t_vis[now]=true; size[now]=1; for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false) size[now]+=GetSize(e[now][i].to); t_vis[now]=0; return size[now];&#125;void GetRoot(int now)&#123; t_vis[now]=true,size[now]=1; bool OK=true; for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false) &#123; GetRoot(e[now][i].to); size[now]+=size[e[now][i].to]; if(size[e[now][i].to]&gt;cnt/2) OK=false; &#125; if(cnt-size[now]&gt;cnt/2) OK=false; if(OK==true) root=now; t_vis[now]=0;&#125;int ans;void dfs2(int now,long long dis,int type)&#123; t_vis[now]=true; if(type==1 and K-dis&gt;=0) ans+=sbt.Query(K-dis); else if(type==2) sbt.Insert(dis); for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and done[e[now][i].to]==true) dfs2(e[now][i].to,dis+e[now][i].w,type); t_vis[now]=false;&#125;void dfs(int now)&#123; //cerr&lt;&lt;now&lt;&lt;endl; vis[now]=true; vector &lt;road&gt; son; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i].to]==false) &#123; cnt=GetSize(e[now][i].to); GetRoot(e[now][i].to); son.push_back(e[now][i]); dfs(root); &#125; sbt.InitTree(); sbt.Insert(0); for(int i=0;i&lt;int(son.size());i++) dfs2(son[i].to,son[i].w,1),dfs2(son[i].to,son[i].w,2); done[now]=true;&#125;int main()&#123; freopen(&quot;4178.in&quot;,&quot;r&quot;,stdin); n=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;n;i++) &#123; long long s=read(),t=read(),w=read(); e[s].push_back(road(t,w)); e[t].push_back(road(s,w)); &#125; K=read(); cnt=GetSize(1); GetRoot(1); dfs(root); printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"splay","slug":"splay","permalink":"http://www.goldenpotato.cn/categories/splay/"},{"name":"点分治","slug":"点分治","permalink":"http://www.goldenpotato.cn/categories/%E7%82%B9%E5%88%86%E6%B2%BB/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"淀粉质(点分治) 学习笔记","slug":"淀粉质点分治-学习笔记","date":"2019-02-25T10:05:43.000Z","updated":"2019-02-25T10:05:43.000Z","comments":true,"path":"2019/02/25/淀粉质点分治-学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E6%B7%80%E7%B2%89%E8%B4%A8%E7%82%B9%E5%88%86%E6%B2%BB-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是淀粉质点分治？ 就是把分治搬到树上，以某个点为根，分别分治处理子树的答案，再计算子树与子树间的答案的玄学算法。 举个例子： 如何求出一颗树上距离为K且所经过的点最少的点对？ 对于这种题，我们可以把某个点（一般为重心）作为根，然后对左右子树递归处理，先分别得出左右子树的答案，再求出横跨两个子树之间的点对的答案。 为什么要学淀粉质 对于上面那道题，如果我们用传统的暴力做法，最优的复杂度只能得到$O(n^2)$的暴力枚举，但是如果我们用淀粉质来搞，我们就可以做到$O(n∗logn)$的复杂度。 如果K很大的话。我们可能还得套个数据结构上去，复杂度就变成了$O(n∗log2n)$，我们就可以通过这类题目。 怎么淀粉质啊 正如我们刚刚说说的，淀粉质的实质是选出一个点，对其左右子树分治，再计算组合不同子树的答案。 所以说，我们在处理某颗子树之前，必须先选出来一个点作为这个子树的根。 我们选的这个点，对我们复杂度的影响极其巨大。 我们可以考虑选重心，重心就是指如果这个点做为根，其任意一颗子树大小均不会超过总点树的1/2。 如果我们每次对子树分治的时候，新选的根是重心，那我们的树的总层数一定不会超过$logn$层。 对于找重心，我们每次都做一遍dfs就好。 1234567891011121314151617181920212223242526int GetSize(int now)&#123; t_vis[now]=true; size[now]=1; for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false) size[now]+=GetSize(e[now][i].to); t_vis[now]=false; return size[now];&#125;int root,cnt;void GetRoot(int now)&#123; t_vis[now]=true; int t_size=1,OK=true; for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false) &#123; GetRoot(e[now][i].to); if(size[e[now][i].to]&gt;cnt/2) OK=false; t_size+=size[e[now][i].to]; &#125; if(cnt-t_size&gt;cnt/2) OK=false; if(OK==true) root=now; t_vis[now]=false;&#125; 选出来重心之后，我们就可以以重心为根分治了。 首先，我们显然可以递归处理子树，然后再处理跨越两个子树的情况。 对于我们上面讲的那道题，我们所需要求的就是跨过两个子树且距离为K的点对的数量。 我们可以考虑这样做： 我们先开一个桶来记录长度为x的路径的点的数量，然后对每颗子树先做两遍dfs，第一遍先去桶里找到目前的点为止，之前找到的子树中有没有K-dis_now的路径。第二遍我们再把到每个点的距离放到桶里面去。 搞完之后，我们可以再dfs一次来回溯掉之前加上的东西，如果我们直接memset的话，会T的。 注意：我们这里的dfs必须只能走已经分治完成的点，分治完成的点才是其儿子 123456789101112131415161718192021222324252627282930313233void dfs2(int now,int dis,int t_cnt,int type)&#123; t_vis[now]=true; if(type==1 and K-dis&gt;=0) ans=min(ans,t_cnt+tot[K-dis]); if(type==2 and dis&lt;M) tot[dis]=min(tot[dis],t_cnt); if(type==3 and dis&lt;M) tot[dis]=inf; for(int i=0;i&lt;int(e[now].size());i++) if(done[e[now][i].to]==true and t_vis[e[now][i].to]==false) dfs2(e[now][i].to,dis+e[now][i].w,t_cnt+1,type); t_vis[now]=false;&#125;void dfs(int now)&#123; vis[now]=true; vector &lt;road&gt; son; son.reserve(32); for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i].to]==false) &#123; cnt=GetSize(e[now][i].to); GetRoot(e[now][i].to); dfs(root); son.push_back(e[now][i]); &#125; for(int i=0;i&lt;int(son.size());i++) dfs2(son[i].to,son[i].w,1,1),dfs2(son[i].to,son[i].w,1,2); for(int i=0;i&lt;int(son.size());i++) dfs2(son[i].to,son[i].w,1,3); done[now]=true;&#125; 这样子搞，看起来时间复杂度很爆炸，其实并不大，因为我们最多有$logn$层，每层做$n$次，总复杂度也就只有$O(n∗logn)$ 这样子，我们就搞定啦φ(&gt;ω&lt;*) 完整的代码 题目传送门：https://www.luogu.org/problemnew/show/P4149（题目稍有变动，但方法类似） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=200000+100;const int M=1000000+100;const int inf=0x3f3f3f3f;struct road&#123; int to,w; road (int A,int B) &#123; to=A,w=B; &#125;&#125;;vector &lt;road&gt; e[N];int n,K;bool vis[N],t_vis[N],done[N];int size[N],cnt,root;int GetSize(int now)&#123; t_vis[now]=true; size[now]=1; for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false) size[now]+=GetSize(e[now][i].to); t_vis[now]=false; return size[now];&#125;void GetRoot(int now)&#123; t_vis[now]=true; int t_size=1,OK=true; for(int i=0;i&lt;int(e[now].size());i++) if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false) &#123; GetRoot(e[now][i].to); t_size+=size[e[now][i].to]; if(size[e[now][i].to]&gt;(cnt/2)) OK=false; &#125; if(cnt-t_size&gt;(cnt/2)) OK=false; if(OK==true) root=now; t_vis[now]=false;&#125;int ans=inf,tot[M];void dfs2(int now,int dis,int t_cnt,int type)&#123; t_vis[now]=true; if(type==1 and K-dis&gt;=0) ans=min(ans,t_cnt+tot[K-dis]); if(type==2 and dis&lt;M) tot[dis]=min(tot[dis],t_cnt); if(type==3 and dis&lt;M) tot[dis]=inf; for(int i=0;i&lt;int(e[now].size());i++) if(done[e[now][i].to]==true and t_vis[e[now][i].to]==false) dfs2(e[now][i].to,dis+e[now][i].w,t_cnt+1,type); t_vis[now]=false;&#125;void dfs(int now)&#123; vis[now]=true; vector &lt;road&gt; son; son.reserve(32); for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i].to]==false) &#123; cnt=GetSize(e[now][i].to); GetRoot(e[now][i].to); dfs(root); son.push_back(e[now][i]); &#125; for(int i=0;i&lt;int(son.size());i++) dfs2(son[i].to,son[i].w,1,1),dfs2(son[i].to,son[i].w,1,2); for(int i=0;i&lt;int(son.size());i++) dfs2(son[i].to,son[i].w,1,3); done[now]=true;&#125;int main()&#123; n=read(),K=read(); for(int i=1;i&lt;n;i++) &#123; int s=read(),t=read(),w=read(); e[s].push_back(road(t,w)); e[t].push_back(road(s,w)); &#125; cnt=GetSize(1); GetRoot(1); memset(tot,0x3f,sizeof tot); tot[0]=0; dfs(root); if(ans&gt;N) ans=-1; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"点分治","slug":"点分治","permalink":"http://www.goldenpotato.cn/categories/%E7%82%B9%E5%88%86%E6%B2%BB/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"NOIp2018 滚粗记","slug":"noip2018-滚粗记","date":"2019-02-25T10:02:16.000Z","updated":"2019-02-25T10:02:16.000Z","comments":true,"path":"2019/02/25/noip2018-滚粗记/","permalink":"http://www.goldenpotato.cn/2019/02/25/noip2018-%E6%BB%9A%E7%B2%97%E8%AE%B0/","excerpt":"","text":"DAY 1 8：30 总算拿到题目啦！ 打开题目一看，T1T2T3全部512MB，1s，没有什么特别奇怪的时间限制的题目，题目应该可做(吧)。 8：32 啥废事都没做，直接开T1。 等等。。。。。。等一下下 这熟悉的题意。。。。。。 这不是神TM的积木大赛原题吗？ 直接5min消灭，过了大样例，稳如老狗。 8：37 快速过了一眼T2,T3。T2好像不怎么可做，想了5分钟只会一个a^n的10分暴力。T3好像更不可做，想了5分钟没啥头绪，连暴力都不怎么会写。那还是去开T2好了。 在草稿纸上YY了一下，觉得这题跟裴蜀定理有这什么不可描述的关系，回头读题，不对啊，不能找零啊。 又YY了半个小时，想了想怎么优化之前那个a^n次方的暴力，感觉不怎么可以优化…怎么办啊，要退役辣。 打了个哈欠冷静一下，猛然发现好像我们只会选之前有过的纸币，并不会新造别的面额的纸币出来。一看样例解释…好像蜜汁有道理。 就酱，我的复杂度成功优化到了2^n,总算能得50分辣，（但是还是要退役） 赶紧花了10分钟敲完了暴力，过了一下样例，结论应该没有猜错。 下一秒，我就想出了怎么优化这个暴力：我们能组合出来的面额的钞票一定不会使用。 然后又花了10分钟去敲了一个优化后的暴力，即我们不枚举哪些不可能使用的钞票。 等等…我怎么感觉不用枚举？ 当然不用枚举啊喂 (*´ﾉ皿`) ，我们都把能组合的去掉了，再不用剩下的纸币一定会gg啊。 又花了10分钟敲了个数据生成器跑对拍，对拍没啥问题，稳如老狗。 9：15 辣么快就到T3了，今天应该很稳啊。(/ω＼) 掏出草稿纸开始yy，最小值最大…emmmmmm，这显然二分鸭。 那怎么判断呢…gg 想了半个小时，还是没啥头绪，有点点虚，就去上了个厕所冷静一下。 回来路上发现我们好像可以用树形DP来搞二叉树和m=1的链的情况。 问题是暴力怎么写啊w 又想了10分钟，好像我们可以直接每次暴力枚举选哪条路，判断一下可不可行就好。 接下来当然是写写写写写啦。 10min敲完大暴力，直接过前两个样例，稳。 20min敲完链的树形DP，又花了10min写对拍，没有拍出任何错误，稳。 20min敲完二叉树的树形DP,又花了5min改数据生成器，结果并拍不上，不稳了 猛然发现我犯了一个很脑残的细节错误，改了改就能过对拍了，稳 11:30 总算弄好了，拍也拍上了，如果没啥意外的话应该就这样了吧。 剩下半个小时没能做啥事，也就对拍一下，检查一下拼写，检查数据范围，也就结束了。 12:10 woc，好像T3的根节点不一定只有两个叉，（怕不是要gg）（出题人应该不会卡吧） woc，人均AK，我又要被暴打了 woc，dalao们居然玩了1个小时贪吃蛇，太强了 DAY 2 8:30 早有耳闻昨天晚上紧急换题，今天会难到起飞。 一眼T1:woc,这不是SB题吗？我们只需要每次贪心的选能到达的点中编号最小的就好啦。 然后5min敲完，一测，并不能过样例。 回头去读题目：woc，我看错题了，走过的点不能再回去。 那…好像不可做啊。 打个哈欠冷静一下，看一眼数据范围：m&lt;=n … 那个60分的树显然直接在树上贪心暴做就可以…问题是剩下40分的gay环外向树怎么做… 好像可以用一个很骚的贪心配合找环强行搞一波。 在草稿纸上yy了半个小时，感觉可能很难写，决定战略放弃一下，先去看T2T3，有空再回来写T1（flag）。 9:17 快速过了一眼T2和T3。T2:woc，这啥题啊，怎么看起来辣么不可做啊。T3:前44分显然是保安站岗原题啊，还有8分的随机树我们也是可以暴力维护一下的。 进过几轮思维上的挣扎，决定先去写T3。 花了30分钟快速打完了保安站岗那道题的代码，略作修改，直接取跑样例。 woc，怎么过不了“大”样例啊。 赶紧肉眼静态查错，没问题啊，没有任何地方写挂了。 woc，那怎么搞啊。 上了个厕所冷静一下，回来后直接在草稿纸上手玩样例。 不对啊，我手玩的结果和我的程序一模一样啊。 赶紧回头读题，猛然发现读错题了，这题要求每两个点之间都必须至少有一个人，和保安站岗并不同。 emmmmmm，好像更好维护了 又花了15分钟魔改之前写的DP，总算能“大”样例了。 此时已经10:00了，觉得还是先战略放缓一下那8分，先去看一眼T2好了（flag*2） 10:02 花了5分钟，总算彻底理解了题意，同时脑子里马上出现一个看起来可行的结论：每个格子的左下角那个格子一定比右上角那个格子更大才有可能满足题目要求。 花2分钟对着样例解释观察了一波，好像是对的。 那这个东西显然可以用状压暴力维护啊，然后再上个矩阵快速幂暴力优化一下就好了吧（数据范围也是这样说的） 为了求稳，先写了个暴力搜索验证一下想法。 拍了15分钟，拍好了，过了样例1，稳。 很不幸，这个东西并不能过样例2，事实上，样例2的答案为121，我的答案为144。 … 这就很尴尬了。 花了15分钟验证想法…并没有问题鸭… 那我写一个直接按题意模拟的暴力试试？ 又过去了15分钟，我把更暴力的暴力打完了。 一测样例2，依旧是神TM的144。 黑人问号.jpg 难道我读错题了？？？ 回头一个一个字读题，并没有啥问题啊。 … 到这个时候，已经11点了，距离考试结束仅有1个小时了。难道真的要退役了？ 不，还有希望，立马放弃T2，先把T3的8分先写了，再回去写不稳的T1。 11:02 根据往年的剧本，这个时候我应该要不就弃疗了，要不就在搞对拍。然而今年，我到现在连题都没写完。 凭借着17年单身的手速，以光速魔改了T3的暴力做法，把它成功地优化到了m*深度的复杂度。 然后当场爆写对拍，爆调代码，总算在11:30分的时候拍上了。 11:31 为了尽快写完T1，我赶紧对之前的做法简化了一波，并魔改了一下做法，变成了一个有可能写出来的东西。 当场爆写。 距离考试结束还有10分钟的时候，我写完了，但并过不了样例。 我快速写出来的代码一般都有成吨的问题，这次也逃不过一劫，我的代码有成吨的bug。 凉了，直到最后一刻我也没有调完T1。 最后还是没有检查后面的文件名和数组，祈祷自己不要写爆吧。 12:30 woc，T1我干嘛要写O（n）的SB贪心啊，我直接m*n暴力枚举那一条边被干掉不就好了吗？也许这就是题好人菜吧。 DAY 1 + DAY 2 期望得分：100+100+75+60+10(?)+52=397(?) = gg 洛咕数据：100+100+65+60+25+52=402 = gg 牛客数据：100+100+65+60+15+52=392=进一步gg 咕咕f数据:100+100+60+60+15+44=379=滚回去学文化 比起上年，我有了30分的“巨大进步” 也许这就是颓的后果罢。 总体来说，DAY1发挥得比较正常，DAY2在解题策略上有严重失误，T2浪费了过多时间，为了追求一个看起来的正解花了太多的时间，却抛弃了能得到的T1的40分。这种错误正是我批判的，没想到，自己也会在正式比赛上成为自己批判的对象。 update 2019/1/14 虽然我DAY2考得十分爆炸，但是还是凭着GX-10的成绩苟进了省选轮。 在这之后一定不能再颓了呢，这样下去怕不是要文化竞赛两爆零","categories":[{"name":"游记/自闭记/滚粗记","slug":"游记-自闭记-滚粗记","permalink":"http://www.goldenpotato.cn/categories/%E6%B8%B8%E8%AE%B0-%E8%87%AA%E9%97%AD%E8%AE%B0-%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}],"tags":[{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/tags/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}]},{"title":"裴蜀定理学习笔记","slug":"裴蜀定理学习笔记","date":"2019-02-25T09:58:58.000Z","updated":"2019-02-25T09:58:58.000Z","comments":true,"path":"2019/02/25/裴蜀定理学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是裴蜀定理 裴蜀定理（或贝祖定理，Bézout’s identity）得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约 数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且（a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。 ——百度百科 用人话来说就是： $\\sum a_i*x_i=b$ 上面的x有解当且仅当 $gcd(ai)b$ 例题 luogu P4549 【模板】裴蜀定理 12345678910111213141516171819202122232425262728293031323334//Luogu P4549 【模板】裴蜀定理//Nov,9th,2018//裴蜀定理模板提#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;int main()&#123; int n=read(); int ans; if(n&lt;2) ans=read(); else &#123; ans=gcd(read(),read()); for(int i=3;i&lt;=n;i++) ans=gcd(ans,read()); &#125; printf(&quot;%d&quot;,ans&gt;0?ans:-ans); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"边双学习笔记","slug":"边双学习笔记","date":"2019-02-25T09:56:31.000Z","updated":"2019-02-25T09:56:31.000Z","comments":true,"path":"2019/02/25/边双学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E8%BE%B9%E5%8F%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"什么是边双？ 双连通分量又分点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量。求双连通分量可用Tarjan算法。——百度百科 用人话来说，就是在无向图上以边为关键字，对原图缩点 为什么要学边双 与强连通分量类似，我们可以求出边双之后对原图缩点，使原图变为一个没有环的图，方便我们后续处理。 边双怎么写 跟强连通分量做法一模一样，唯一的不同就是我们在取low的时候要小心一下不能取父节点，以防之前取回去 例题： luogu P2783 有机化学之神偶尔会做作弊 这题我们只需要对原图做边双缩点之后LCA直接前缀和做就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//Luogu P2783 有机化学之神偶尔会做作弊//Nov,9th,2018//边双#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f; &#125;const int N=10000+100;vector &lt;int&gt; e[N],e2[N];int low[N],dfn[N],dfn_to,mstack[N],top,belong[N],cnt;bool vis[N],InStack[N];void Tarjan(int now,int fa)&#123; low[now]=dfn[now]=++dfn_to; vis[now]=InStack[now]=true; mstack[++top]=now; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) &#123; Tarjan(e[now][i],now); low[now]=min(low[now],low[e[now][i]]); &#125; else if(e[now][i]!=fa and InStack[e[now][i]]==true) low[now]=min(low[now],low[e[now][i]]); if(dfn[now]==low[now]) &#123; cnt++; while(top&gt;0) &#123; InStack[mstack[top]]=false; belong[mstack[top--]]=cnt; if(mstack[top+1]==now) break; &#125; &#125;&#125;int n,m;int fa[N][21],pre[N],depth[N];void dfs(int now)&#123; vis[now]=true; for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;int(e2[now].size());i++) if(vis[e2[now][i]]==false) &#123; depth[e2[now][i]]=depth[now]+1; fa[e2[now][i]][0]=now; pre[e2[now][i]]=pre[now]+1; dfs(e2[now][i]); &#125;&#125;int LCA(int x,int y)&#123; if(depth[x]&lt;depth[y]) swap(x,y); for(int i=20;i&gt;=0;i--) if(depth[x]-(1&lt;&lt;i)&gt;=depth[y]) x=fa[x][i]; if(x==y) return x; for(int i=20;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void OutPut(int x)&#123; if(x==0) &#123; printf(&quot;0&quot;); return; &#125; int temp[50],ws=0; while(x&gt;0) temp[++ws]=x%2,x/=2; for(int i=ws;i&gt;=1;i--) printf(&quot;%d&quot;,temp[i]);&#125;int main()&#123; //freopen(&quot;2783.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;2783.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4), e2[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; Tarjan(1,1); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;int(e[i].size());j++) if(belong[i]!=belong[e[i][j]]) e2[belong[i]].push_back(belong[e[i][j]]); memset(vis,0,sizeof vis); pre[1]=1; dfs(1); int q=read(); for(int i=1;i&lt;=q;i++) &#123; int x=belong[read()],y=belong[read()],lca=LCA(x,y); int ans=pre[x]+pre[y]-pre[lca]; if(lca!=1) ans-=pre[fa[lca][0]]; OutPut(ans); printf(&quot;\\n&quot;); //printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"边双/点双","slug":"边双-点双","permalink":"http://www.goldenpotato.cn/categories/%E8%BE%B9%E5%8F%8C-%E7%82%B9%E5%8F%8C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"卡特兰数学习笔记","slug":"卡特兰数学习笔记","date":"2019-02-25T09:53:29.000Z","updated":"2019-02-25T09:53:29.000Z","comments":true,"path":"2019/02/25/卡特兰数学习笔记/","permalink":"http://www.goldenpotato.cn/2019/02/25/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"为什么要学卡特兰数？ 为了解决一类计数问题 NOIp能考吗：能 以此记录我模拟赛中被强行卡特兰数卡爆的贪心神题 什么是卡特兰数？ 卡特兰数又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。–百度百科 用人话来说，就是开头为1，2，5，14，42，132，429，1430，4862…的数列 卡特兰数的公式 卡特兰数的一般公式 (只有下标的是卡特兰数，右边那个是组合数) 卡特兰数的递推式 卡特兰数有什么用 此处内容借鉴了:https://blog.csdn.net/wu_tongtong/article/details/78161211 1.括号匹配类计数问题： 给你n个左括号,n个右括号,问有多少种合法的括号放置方案 eg. ()()()是合法的方案，)( 是不合法的方案 能抽象为这类问题的题目，其方案数就是卡特兰数 例题：luogu P3200 有趣的数列 2.出栈次序问题 有1-n个元素，依次进栈，问你有多少种合法的出栈方案 能抽象为这类问题的题目，其方案数也是卡特兰数。 例子： 有2n个人去餐厅吃饭，有n个人有10块钱纸币，n个人有5块钱纸币，餐厅的饭卖5块钱一份，问有多少种可行的买饭顺序 我们可以抽象为：用5块钱买饭就入栈一次，用10块钱买饭就出栈一次 3.二叉树形态数问题 有n个叶子，问你有多少个形态不同的二叉树 这种类型的题目方案数就是卡特兰数 暂无例子( ･´ω`･ )","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"NOIP2018 填坑记","slug":"noip2018-填坑记","date":"2019-02-25T09:48:47.000Z","updated":"2019-02-25T09:48:47.000Z","comments":true,"path":"2019/02/25/noip2018-填坑记/","permalink":"http://www.goldenpotato.cn/2019/02/25/noip2018-%E5%A1%AB%E5%9D%91%E8%AE%B0/","excerpt":"","text":"Oct,22ed,2018 DAY -18 又是颓废的一天呢 我好菜啊，一个圆方树弄了一整天（点双怎么那么毒瘤）。（铁人两项怎么那么多点） Oct,23rd,2018 DAY -17 又双叒叕颓了一天 下午考了一个蜜汁模拟塞，全部都是历年T1，写的是时候出现了巨多问题，什么输入写挂啊，忘记初始化啊，双向边写成单项边啊，导致我比机房dalao多调了半个小时。（好在我最终的没有写挂。）先膜一下10分钟ak的lyj dalao。有好多机房dalao因为各种各样的原因没有ak。wzj dalao忘开longlong挂了20分，太惨了。 晚上听了神仙讲课，半程自闭，好神啊。怎么还有那么毒的二分答案的check。（以及我的南普口音造成的“额分”尴尬） 走之前两位教练做了训话，以后不能再颓废了呢。（再这样颓下去怕不是noip退役）（第二天:真香） ps：怎么爆名费辣么贵啊，不愧是china cheating money founderation Oct,24th,2018 DAY -16 被暴打的一天 早上考了一个膜你赛，T1是一道蜜汁背包带贪心的题目，T2因为不会卡特兰数被lyj暴打，T3的数位DP又双叒叕调爆了。成功滚粗。 下午当然是调调调调调上午的代码（T2的线段数怎么辣么难写啊w） 晚上又考了一个武汉zyb邀请赛，依旧被暴打。T1被错误的大样例卡了一个小时（现在我还是忍不住暴打出题人的想法），T2是典型的不可做题（这样还绑subtest，毒瘤出题人），T3写了一个蜜汁分块+biteset+线段树的做法，当时对拍了半个小时，觉得稳如老狗，很不幸，T3依旧爆零了，（应该是随机的数据太弱了），成功滚粗*2 我又菜又颓，真的是要退役 Oct,25th,2018 DAY -15 又被暴打了 上午又考了一个膜你赛，T1写了一个nlog^2的玄学二分答案+线段树上二分（事实上，那题可以直接在数组上二分），结果线段树常数爆大，卡成暴力分（事实上，lowerbound也会T，要手写二分，在这里问候卡常出题人和他的家人）。T2是一道区间DP带上一些玄学优化（结果被机房dalao们贪心爆踩），我只能想出n^3的区间DP啊，我好菜啊，T3是一道期望不可做题，推半天式子还是调不出大样例，理所当然的爆零了。 下午写出T2贪心A掉的问题引起了写了正解以及没写贪心的wzj和lyjdalao的愤怒，直接对着标程把所有贪心卡掉了w（真爽）（我只是因为没有写贪心而爽） 然后当然是调调调调上午被卡常卡爆的T1，然后写了一下T2，昨晚的T3好妙啊，居然可以在数列上做哈希。（还是想不通为啥我的分块+bitset会wa） 又被打爆了，我好菜啊 Oct,26th,2018 DAY -14 今天并没有考试（失去了一雪前耻的机会（或者说是再一次被打爆的机会）） 那裆燃是去学前一天怨念十足的卡特兰数啊（卡特兰数真好玩）（真香） 我已经决定了，将来出题一定要当一个毒瘤，不仅要卡常，而且要求答案膜上一个卡特兰数输出，让所有不注意常数与不会卡特兰数的人全部爆零，哇哈哈 Oct,27th,2018 DAY -13 周六，当然是颓颓颓颓颓颓颓啦。 顺便做了几道题愉悦身心，结果被神题暴打 ZJOI2013蚂蚁寻路一眼看上去是可做题，写起来却极其恶心，细节讨论起来比模拟题还多，毒瘤不可做题 交了6次之后总算A掉了（真香） 很不幸，还是被暴打了，神犇学弟这道题1A，tql Oct,29th,2018 DAY -12 今天学到了好多新东西呢。 LUCAS定理真好玩鸭（居然膜着膜着会出现n&lt;m的情况，感谢学弟的指点，学弟太强啦） 欧拉函数真好玩鸭（玄学线性塞写了一个极度恶心的三目运算符，我是谁，我在哪里，我写的是啥） 带修莫队真好玩鸭（好玩个鬼，怎么数颜色那么毒瘤啊，卡了奇偶排序，块大小，居然还要对t排序） 今天好多姬房惨案啊，场面一度混乱 Oct,31st,2018 DAY -9 今天的模拟赛又被暴打了。 T1是个玄学模拟题，大致读了一眼题意，发现不会输出顺序…然后写了个60分暴力就草草下一题了。 T2是个玄学逆序对题，完全没有任何思路，就写了个40分的暴力。 T3是个不可做题，考场上想了一个玄学做法，期望30分。 好消息是，我的T3，T3并没有写挂…坏消息是T1挂掉了 原因是TM的读错题 一定好好审题啊！！！！！如果是在NOIp考场上就真的退役了。 又被暴打了，我怎么那么菜啊 Nov,5th,2018 DAY-4 今天的模拟赛非常信心，非常可做。 T1是一个斐波那契数列大水题，5minA掉直接下一题。 T2是一个LCA+树上倍增乱搞小水题，30min写了个正解，30min写了暴力和对拍，跑了3w组数据，没啥问题。 T3是一个树上DP求最大匹配的正常题，先花了30min写了个大暴力。我在考场上第一反应是贪心，花了30min写了一个贪心做法，并不能过对拍。冷静之后发现这题好像是求树上的最大匹配问题，那显然可以网络流做啊。接着就开始怀疑人生：我已经半年没有写过网络流了，我很有可能调不出，建图有可能建错,有可能被卡掉…赶紧上了个厕所冷静一下，回来猛然发现这题可以树形DP乱搞水过，赶紧写了一个树形DP，顺便上了对拍。总共用时1h。 接下来的一个半小时，检查了一下极限数据和数据范围，输入输出之后，当然是打开emacs颓五子棋啊（电脑好强啊，连跪5局），连带做着AK的美梦。 很不幸的是，T1挂成了30分，原因是我又双叒叕TM的读错题了。 斐波那契数列第0项居然是0！！！！！！！！ 很显然，在人均AK的神仙群中，我又被暴打了。 以后一定要好好审题！！！！！这样下去吃枣药丸。","categories":[{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}],"tags":[]},{"title":"[Luogu P2824] [HEOI2016/TJOI2016]排序","slug":"luogu-p2824-heoi2016-tjoi2016排序","date":"2019-02-22T09:33:55.000Z","updated":"2019-02-22T09:33:55.000Z","comments":true,"path":"2019/02/22/luogu-p2824-heoi2016-tjoi2016排序/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p2824-heoi2016-tjoi2016%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题面 传送门：洛谷 Solution 这题极其巧妙。 首先，如果直接做m次排序，显然会T得起飞。 注意一点：我们只需要找到一个数。 所以说，我们可以考虑一个绝妙的想法：我们可以用二分答案的方法缩小要找的数的区间。 考虑二分一个值，判定p位置的数排序之后，p位置上的数是否&gt;=mid 如果&gt;=mid,则向右找，否则向左找。 怎么判定p位置的数排序之后是否&gt;=mid呢？ 考虑这样做：扫描一遍原数组，&gt;=mid的数赋值为1，&lt;mid的数赋值为0。 这样子，题目就变成了一个01序列排序。 这就很可做了，我们直接线段树维护之即可，我们只需要实现区间查询与区间赋值。 对于一个01区间排序，我们只需要知道这个区间有多少个0，多少个1，然后区间修改即可。 时间复杂度$O(m*logn^2)$ . 就酱，这题就可以切掉啦(ﾉ´▽｀)ﾉ♪ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//Luogu P2824 [HEOI2016/TJOI2016]排序//Oct,19th,2018//二分答案缩小范围+线段树妙题#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;)f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=30000+100;int a[N],w[N];struct SegmentTree&#123; #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) #define mid ((now_l+now_r)&gt;&gt;1) static const int M=N&lt;&lt;2; int sum[M][2],lazy[M]; inline void update(int now) &#123; sum[now][0]=sum[lson][0]+sum[rson][0]; sum[now][1]=sum[lson][1]+sum[rson][1]; &#125; inline void pushdown(int now,int now_l,int now_r) &#123; if(now_l==now_r) &#123; lazy[now]=2; return; &#125; lazy[lson]=lazy[rson]=lazy[now]; sum[lson][lazy[now]]=mid-now_l+1,sum[lson][!lazy[now]]=0; sum[rson][lazy[now]]=now_r-mid,sum[rson][!lazy[now]]=0; lazy[now]=2; &#125; void Build(int now,int now_l,int now_r) &#123; sum[now][0]=sum[now][1]=0; lazy[now]=2; if(now_l==now_r) &#123; sum[now][w[now_l]]++; return; &#125; Build(lson,now_l,mid); Build(rson,mid+1,now_r); update(now); &#125; void Change(int L,int R,int x,int now,int now_l,int now_r) &#123; if(L&gt;R) return; if(lazy[now]!=2) pushdown(now,now_l,now_r); if(now_l&gt;=L and now_r&lt;=R) &#123; sum[now][x]=now_r-now_l+1,sum[now][!x]=0; lazy[now]=x; return; &#125; if(L&lt;=mid) Change(L,R,x,lson,now_l,mid); if(R&gt;mid) Change(L,R,x,rson,mid+1,now_r); update(now); &#125; int Query(int L,int R,int x,int now,int now_l,int now_r) &#123; if(lazy[now]!=2) pushdown(now,now_l,now_r); if(now_l&gt;=L and now_r&lt;=R) return sum[now][x]; int ans=0; if(L&lt;=mid) ans+=Query(L,R,x,lson,now_l,mid); if(R&gt;mid) ans+=Query(L,R,x,rson,mid+1,now_r); return ans; &#125; #undef lson #undef rson #undef mid&#125;sgt;struct OP&#123; int type,L,R;&#125;op[N];int n,m,p;bool Check(int x)&#123; for(int i=1;i&lt;=n;i++) if(a[i]&gt;=x) w[i]=1; else w[i]=0; sgt.Build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int cnt0=sgt.Query(op[i].L,op[i].R,0,1,1,n),cnt1=op[i].R-op[i].L+1-cnt0; if(op[i].type==0) sgt.Change(op[i].L,op[i].L+cnt0-1,0,1,1,n), sgt.Change(op[i].L+cnt0,op[i].R,1,1,1,n); else sgt.Change(op[i].L,op[i].L+cnt1-1,1,1,1,n), sgt.Change(op[i].L+cnt1,op[i].R,0,1,1,n); &#125; if(sgt.Query(p,p,1,1,1,n)==1) return true; return false;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=m;i++) op[i].type=read(),op[i].L=read(),op[i].R=read(); p=read(); int L=0,R=n+100,ans=0; while(L&lt;=R) &#123; int mid=(L+R)/2; if(Check(mid)==true) ans=max(ans,mid),L=mid+1; else R=mid-1; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[CF893F]Subtree Minimum Query","slug":"cf893fsubtree-minimum-query","date":"2019-02-22T09:30:47.000Z","updated":"2019-02-22T09:30:47.000Z","comments":true,"path":"2019/02/22/cf893fsubtree-minimum-query/","permalink":"http://www.goldenpotato.cn/2019/02/22/cf893fsubtree-minimum-query/","excerpt":"","text":"题面： 传送门：Codeforces 题目大意：给你一颗有根树，点有权值，问你每个节点的子树中距离其不超过k的点的权值的最小值。（边权均为1，强制在线） Solution 这题很有意思。 我们一般看到这种距离不超过k的题目，第一反应一般是建以深度为下标，以dfs序为时间轴的的主席树。 很不幸，区间最小值并不能通过减去历史状态得出某个子树的状态。 所以说，这题妙在思想的转换。 考虑以dfs序为下标，以深度为时间轴建一颗主席树。 我们可以bfs，按深度一层层地把点加进去。 这样子，我们就可以查询对应深度之内的这颗子树的最小权值啦。 就酱，我们就可以把这题切掉啦ヽ(￣▽￣)ﾉ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+1000;const int M=30*N;int n,r,a[N];vector &lt;int&gt; e[N];struct SegmentTree&#123; static const int inf=0x3f3f3f3f; #define mid ((now_l+now_r)&gt;&gt;1) int MIN[M],son[M][2],cnt; inline void update(int now) &#123; MIN[now]=min(MIN[son[now][0]],MIN[son[now][1]]); &#125; void Build(int now,int now_l,int now_r) &#123; if(now_l==now_r) &#123; MIN[now]=inf; return; &#125; Build(son[now][0]=++cnt,now_l,mid); Build(son[now][1]=++cnt,mid+1,now_r); update(now); &#125; void Change(int x,int num,int now,int pre,int now_l,int now_r) &#123; if(now_l==now_r) &#123; MIN[now]=num; return; &#125; if(x&lt;=mid) son[now][1]=son[pre][1],Change(x,num,son[now][0]=++cnt,son[pre][0],now_l,mid); else son[now][0]=son[pre][0],Change(x,num,son[now][1]=++cnt,son[pre][1],mid+1,now_r); update(now); &#125; int Query(int L,int R,int now,int now_l,int now_r) &#123; if(now_l&gt;=L and now_r&lt;=R) return MIN[now]; int ans=inf; if(L&lt;=mid) ans=min(ans,Query(L,R,son[now][0],now_l,mid)); if(R&gt;mid) ans=min(ans,Query(L,R,son[now][1],mid+1,now_r)); return ans; &#125; void Print(int now,int now_l,int now_r) &#123; cerr&lt;&lt;&quot;no.&quot;&lt;&lt;now&lt;&lt;&quot; now_l&amp;r:&quot;&lt;&lt;now_l&lt;&lt;&quot; &quot;&lt;&lt;now_r&lt;&lt;&quot; sonl&amp;r&quot;&lt;&lt;son[now][0]&lt;&lt;&quot; &quot;&lt;&lt;son[now][1]&lt;&lt;&quot; MIN:&quot;&lt;&lt;MIN[now]&lt;&lt;endl; if(now_l!=now_r) &#123; Print(son[now][0],now_l,mid); Print(son[now][1],mid+1,now_r); &#125; &#125; #undef mid&#125;sgt;int dfn[N],depth[N],dfn_to,size[N],depth_MAX;void dfs(int now)&#123; depth_MAX=max(depth_MAX,depth[now]); dfn[now]=++dfn_to; size[now]=1; for(int i=0;i&lt;int(e[now].size());i++) if(dfn[e[now][i]]==0) &#123; depth[e[now][i]]=depth[now]+1; dfs(e[now][i]); size[now]+=size[e[now][i]]; &#125;&#125;int dl[N],front,tail,root[N];void bfs()&#123; dl[tail++]=r; int depth_now=0; while(tail&gt;front) &#123; int now=dl[front]; int temp=root[depth_now]; if(depth[now]!=depth_now) &#123; depth_now=depth[now]; temp=root[depth_now-1]; &#125; root[depth_now]=++sgt.cnt; sgt.Change(dfn[now],a[now],root[depth_now],temp,1,n); //sgt.Print(root[depth_now],1,n); //cerr&lt;&lt;endl; for(int i=0;i&lt;int(e[now].size());i++) if(depth[e[now][i]]&gt;depth[now]) dl[tail++]=e[now][i]; front++; &#125;&#125;int main()&#123; n=read(),r=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;n;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; depth[r]=1; dfs(r); sgt.Build(0,1,n); //sgt.Print(0,1,n); //cerr&lt;&lt;endl; bfs(); int m=read(),lans=0; for(int i=1;i&lt;=m;i++) &#123; int x=read(),K=read(); x=((x+lans)%n)+1,K=(K+lans)%n; int temp=min(depth[x]+K,depth_MAX); lans=sgt.Query(dfn[x],dfn[x]+size[x]-1,root[temp],1,n); printf(&quot;%d\\n&quot;,lans); &#125; return 0;&#125;","categories":[{"name":"主席树","slug":"主席树","permalink":"http://www.goldenpotato.cn/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P3899] [湖南集训]谈笑风生","slug":"luogu-p3899-湖南集训谈笑风生","date":"2019-02-22T09:27:54.000Z","updated":"2019-02-22T09:27:54.000Z","comments":true,"path":"2019/02/22/luogu-p3899-湖南集训谈笑风生/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p3899-%E6%B9%96%E5%8D%97%E9%9B%86%E8%AE%AD%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F/","excerpt":"","text":"题面 传送门：洛谷 Solution 你们搞的这道题啊，excited！ . 这题真的很有意思。 首先，我们可以先理解一下题面：固定一个a，找到一个b，c就是a与b的公共子树中的某个点。 那么，我们显然可以把这个b分成两类，第一种是在a上面的，第二种在a下面的。 对于b在a上面的情况，**显然，c一定是a的子树中的某个点，**答案即为$min(K，depth[a])*size[a]$ 对于b在a下面的情况，问题就会变得比较exciting了。 我们可以考虑使用主席树来搞这个问题。 考虑建一颗这样的主席树，以节点深度为主席树下标。 对于一个节点，如果B在这个节点上，那么，它对答案的贡献显然是它的$size-1$。 那么，我们把它的贡献插入到它对应的主席树中（以深度为下标）。 每一个子节点开一颗主席树，记录到它为止所有的深度的答案和，有点类似前缀和，以dfs序为时间轴。 这样，我们可以用一种类似树上差分的办法来“抠”出一颗子树对应的线段数（以深度为下标），这颗线段数中的$[depth[x]+1,depth[x]+K]$区间的sum就是这个x点的答案啦。 . 就酱，这题就被我们切掉啦٩(๑&gt;◡&lt;๑)۶ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const long long N=300000+100;const long long M=N*30;struct SegmentTree&#123; #define mid ((now_l+now_r)&gt;&gt;1) long long son[M][2],cnt; long long sum[M]; inline void update(long long now) &#123; sum[now]=sum[son[now][0]]+sum[son[now][1]]; &#125; void Build(long long now,long long now_l,long long now_r) &#123; if(now_l==now_r) return; Build(son[now][0]=++cnt,now_l,mid); Build(son[now][1]=++cnt,mid+1,now_r); &#125; void Add(long long x,long long num,long long now,long long pre,long long now_l,long long now_r) &#123; if(now_l==now_r) &#123; sum[now]=sum[pre]; sum[now]+=num; return ; &#125; if(x&lt;=mid) son[now][1]=son[pre][1],Add(x,num,son[now][0]=++cnt,son[pre][0],now_l,mid); else son[now][0]=son[pre][0],Add(x,num,son[now][1]=++cnt,son[pre][1],mid+1,now_r); update(now); &#125; long long Query(long long L,long long R,long long now,long long pre,long long now_l,long long now_r) &#123; if(now_l&gt;=L and now_r&lt;=R) return sum[now]-sum[pre]; long long ans=0; if(L&lt;=mid) ans+=Query(L,R,son[now][0],son[pre][0],now_l,mid); if(R&gt;mid) ans+=Query(L,R,son[now][1],son[pre][1],mid+1,now_r); return ans; &#125; void Print(long long now,long long now_l,long long now_r) &#123; cerr&lt;&lt;&quot;no.&quot;&lt;&lt;now&lt;&lt;&quot; now_l&amp;r:&quot;&lt;&lt;now_l&lt;&lt;&quot; &quot;&lt;&lt;now_r&lt;&lt;&quot; sonl&amp;r&quot;&lt;&lt;son[now][0]&lt;&lt;&quot; &quot;&lt;&lt;son[now][1]&lt;&lt;&quot; sum:&quot;&lt;&lt;sum[now]&lt;&lt;endl; if(now_l!=now_r) &#123; Print(son[now][0],now_l,mid); Print(son[now][1],mid+1,now_r); &#125; &#125; #undef mid&#125;sgt;vector &lt;long long&gt; e[N];long long n,m,depth[N],size[N],dfn[N],dfn_to,r[N];void dfs2(long long now)&#123; dfn[now]=++dfn_to; size[now]=1; for(long long i=0;i&lt;(long long)(e[now].size());i++) if(depth[e[now][i]]==0) &#123; depth[e[now][i]]=depth[now]+1; dfs2(e[now][i]); size[now]+=size[e[now][i]]; &#125;&#125;void dfs(long long now)&#123; r[dfn[now]]=++sgt.cnt; sgt.Add(depth[now],size[now]-1,r[dfn[now]],r[dfn[now]-1],1,n); //sgt.Print(r[dfn[now]],1,n); //cerr&lt;&lt;endl; for(long long i=0;i&lt;(long long)(e[now].size());i++) if(depth[e[now][i]]&gt;depth[now]) dfs(e[now][i]);&#125;int main()&#123; n=read(),m=read(); for(long long i=1;i&lt;=n;i++) e[i].reserve(4); for(long long i=1;i&lt;n;i++) &#123; long long s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; sgt.Build(0,1,n); //sgt.Print(0,1,n); //cerr&lt;&lt;endl; depth[1]=1; dfs2(1); dfs(1); for(long long i=1;i&lt;=m;i++) &#123; long long p=read(),K=read(); long long ans=sgt.Query(depth[p]+1,depth[p]+K,r[dfn[p]+size[p]-1],r[dfn[p]-1],1,n); ans+=min(K,depth[p]-1)*(size[p]-1); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"主席树","slug":"主席树","permalink":"http://www.goldenpotato.cn/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P4215] 踩气球","slug":"luogu-p4215-踩气球","date":"2019-02-22T09:23:08.000Z","updated":"2019-02-22T09:23:08.000Z","comments":true,"path":"2019/02/22/luogu-p4215-踩气球/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p4215-%E8%B8%A9%E6%B0%94%E7%90%83/","excerpt":"","text":"题面 洛谷 Solution 这题十分有意思。 首先，我们可以先想想离线做法，因为在线做法可以从离线做法推出。（虽然这题推不出） 我们可以明确一点，一个熊孩子开心的时间是满足二分的要求的（如果他某个时刻开心了，那之后的时刻都会保持开心）。 对于判断一个区间是否为全0，我们可以用主席树以一个log的代价来判断。 得到每个熊孩子开心的时刻之后，我们就可以直接前缀和解决问题了。 时间复杂度$O(m*log^2)$ . 很可惜，这题强制在线。 很可惜*2，刚刚的做法跟正解一点关系都没有。 我们可以考虑用线段树。 问题是怎么判断一个熊孩子在某个操作后是否开心呢？ 我们显然可以快速地判断线段树上的一个直接的区间（即这个区间可以用一个节点表示）是否全为0，问题是我们不能很快地判断一个非直接的区间是否全为0。 所以说，我们可以考虑把熊孩子“拆开”。 因为一个熊孩子的区间一定可以表示为线段树上的几个直接区间，我们可以在这些直接区间上打上标记，记录这个区间被哪几个熊孩子直接包含。 我们再记录一下每个熊孩子被拆成了几个区间。 一个区间全部变为0的时候，我们把它对应的熊孩子的记录值-1，当一个熊孩子记录值为0的时候，就代表着这个熊孩子的区间被彻底干掉了。 时间复杂度$O(mlogn+qlogn)$ . 就酱，这题就被我们切掉啦φ(&gt;ω&lt;*) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Luogu P4215 踩气球//Oct,14th,2018//有意思的线段树#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;int ans,tot[N];struct SegmentTree&#123; #define lson (now&lt;&lt;1) #define rson (now&lt;&lt;11) #define mid ((now_l+now_r)/2) vector &lt;int&gt; son[N&lt;&lt;2]; int IsClear[N&lt;&lt;2],cnt[N]; inline void update(int now) &#123; IsClear[now]=IsClear[lson]&amp;IsClear[rson]; &#125; void Mark(int L,int R,int x,int now,int now_l,int now_r) &#123; if(now_l&gt;=L and now_r&lt;=R) &#123; tot[x]++; son[now].push_back(x); return; &#125; if(L&lt;=mid) Mark(L,R,x,lson,now_l,mid); if(R&gt;mid) Mark(L,R,x,rson,mid+1,now_r); &#125; void Sub(int x,int now,int now_l,int now_r) &#123; if(now_l==now_r) &#123; cnt[x]--; if(cnt[x]==0) IsClear[now]=true; &#125; if(now_l!=now_r) &#123; if(x&lt;=mid) Sub(x,lson,now_l,mid); else Sub(x,rson,mid+1,now_r); update(now); &#125; if(IsClear[now]==true) for(int i=0;i&lt;int(son[now].size());i++) &#123; tot[son[now][i]]--; if(tot[son[now][i]]==0) ans++; &#125; &#125; #undef lson #undef rson #undef mid&#125;sgt;int n,m,q;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) sgt.cnt[i]=read(); for(int i=1;i&lt;=m;i++) &#123; int L=read(),R=read(); sgt.Mark(L,R,i,1,1,n); &#125; int q=read(),lans=0; for(int i=1;i&lt;=q;i++) &#123; int x=read(); x=(x+lans-1)%n+1; sgt.Sub(x,1,1,n); lans=ans; printf(&quot;%d\\n&quot;,lans); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"[Luogu P2831] 愤怒的小鸟","slug":"luogu-p2831-愤怒的小鸟","date":"2019-02-22T09:21:20.000Z","updated":"2019-02-22T09:21:20.000Z","comments":true,"path":"2019/02/22/luogu-p2831-愤怒的小鸟/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/","excerpt":"","text":"题面：洛谷 Solution 首先，我们可以先康一康题目的数据范围：n&lt;=18，应该是状压或者是搜索。 事实上，这题搜索和状压DP都是能做的。 （因为搜索在我心中留下了阴影（斗地主），所以在这里，我讲状压DP的做法） 根据我们以往设计状压DP的经验，我们可以很轻松地设计这一题的状态： 设f[i]表示打下的猪猪的状态为i的方案数，（状态在这里用二进制方式来表示，例如：00101表示打下了第1和第3只猪） 那么有： $f[i] = min(f[j])+1$ （j为i的子集） 这里用到一个枚举子集的技巧，对于一个状态i，它可以这样枚举子集： for(int j=i;j&gt;=0;j=(j-1)&amp;i) (至于证明，你可以在草稿纸上画画，很快就会发现它的精妙了) 那我们怎么判断能否从状态 j 转移到 i 呢？ 首先，根据数学常识，我们需要3个x不一样的点才能确定一条抛物线。这题已经固定了原点了，所以我们还需要两个点来确定一条抛物线。 如果j与i只有一个或两个x不同的点 是不同的，那显然是可以转移的。 对于有两个以上的点，我们可以用前两个点通过解二元一次方程来计算函数的a与b，然后再去一个一个判断每个不同的点是否在这条抛物线上。 对于如何解二元一次方程…（这应该是数学常识吧） 复杂度$O(3^n*n*T)$ 显然TLE，事实上，这样做只能得60分。 那怎么优化复杂度呢？ 刚刚的枚举子集显然是不可行了，那我们可以换个思路。 我们可以枚举点。 对于某一种状态，我们肯定可以枚举两个（或一个）没有用过的点去构成新的抛物线从而更新其他的状态。 这样子，我们成功地把复杂度降为了 $O(2^n*n^2*T)$ 依然过不了，事实上，这样做能得85分。 上一个作法已经和正解很接近了。 我们可以考虑这样优化方程： 这样子，我们复杂度就降为了$ O(2^n*n*T)$ 就酱，我们就可以把这道题切掉啦(´▽`)ﾉ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Luogu P2831 愤怒的小鸟//Sep,19th,2018//状压DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int N=18+2;const double eps=1e-7;struct node&#123; double x,y;&#125;nd[N];long long f[1&lt;&lt;N];int n,POW[N],g[N][N];inline double pf(double x)&#123; return x*x;&#125;bool solve(node A,node B,double &amp;a,double &amp;b)&#123; if(fabs(A.x-B.x)&lt;=eps) return false; a=(B.x*A.y-A.x*B.y)/(pf(A.x)*B.x-pf(B.x)*A.x); b=(pf(B.x)*A.y-pf(A.x)*B.y)/(pf(B.x)*A.x-pf(A.x)*B.x); if(a&gt;=0) return false; return true;&#125;double fun(double x,double a,double b)&#123; return a*pf(x)+b*x;&#125;int main()&#123; POW[0]=1; for(int i=1;i&lt;N;i++) POW[i]=POW[i-1]*2; int T,tt; scanf(&quot;%d&quot;,&amp;T); for(;T&gt;0;T--) &#123; memset(g,0,sizeof g); scanf(&quot;%d%d&quot;,&amp;n,&amp;tt); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;nd[i].x,&amp;nd[i].y); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) &#123; double a=0,b=0; bool OK=solve(nd[i],nd[j],a,b); if(OK==false) continue; for(int k=1;k&lt;=n;k++) if(fabs(fun(nd[k].x,a,b)-nd[k].y)&lt;=eps) g[i][j]+=POW[k-1]; &#125; memset(f,0x3f,sizeof f); f[0]=0; int to=(1&lt;&lt;n)-1,used[N]; for(int i=0;i&lt;to;i++) &#123; memset(used,0,sizeof used); int temp=i,j; for(j=n-1;j&gt;=0;j--) if(temp-POW[j]&gt;=0) &#123; temp-=POW[j]; used[j+1]=true; &#125; for(j=1;j&lt;=n;j++) if(used[j]==false) break; f[iPOW[j-1]]=min(f[iPOW[j-1]],f[i]+1); for(int k=j+1;k&lt;=n;k++) if(used[k]==false and g[j][k]!=0) f[ig[j][k]]=min(f[ig[j][k]],f[i]+1); &#125; printf(&quot;%lld\\n&quot;,f[to]); &#125; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://www.goldenpotato.cn/categories/%E7%8A%B6%E5%8E%8BDP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P3953] 逛公园","slug":"luogu-p3953-逛公园","date":"2019-02-22T09:04:16.000Z","updated":"2019-02-22T09:04:16.000Z","comments":true,"path":"2019/02/22/luogu-p3953-逛公园/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p3953-%E9%80%9B%E5%85%AC%E5%9B%AD/","excerpt":"","text":"题面 蒟蒻博客：QAQ Solution 这是一道神题 首先，我们不妨想一下K=0，即求最短路方案数的部分分。 我们很容易可以想到一个做法，就是魔改迪杰斯特拉做法： 一个点可以更新到达其他点的距离，那个点的方案数就是这个点的方案数；如果一个点所更新出来的距离和之前的相等，那个点的方案数加等当前点的方案数。 用式子可以表现为： $$f[i]=f[i] (dis[j]&gt;dis[i]+x)$$ $$f[j]+=f[i] (dis[j]==dis[i]+x)$$ (i表示当前点，j表示它更新的点，x为i到j那条路的距离) 那我们怎么保证它的顺序不会出错，即如何保证一个点去更新其他点的方案数的时候，这个点的方案数是正确的呢？ 事实上，这种做法就是一种DP。 那么，对于K！=0的情况怎么处理呢？ 观察数据，我们会发现K最大只有50。 因此，我们可以考虑在DP上加一维来解决这个K值。 考虑这样设状态： f[i][j] 表示到达i点，距离为dis[i]+j 的方案数 转移非常好写 $$f[i][j] = sigema (f[k][dis[i]+j-dis[k]-a])$$ (k为直接连到i的点，a表示它们之间的边权) 初始化其实我们在30分做法中就已经求好了。 转移顺序是个问题。 我们显然可以在外层枚举j，问题是，有时候，dis[i]+j-dis[k]-a会等于j，如果枚举i的顺序错了，答案肯定会跟着错。 对于dis[i]+j-dis[k]-a==j 的点，肯定是k去更新i，又因为边权没有负值，所以我们就可以按照dis从小到大去去枚举i的值。 以上是没有零边的做法。 对于有零边的情况，我们刚刚的做法就会出问题。如图： 所以说，我们把原图转换一下**，只保留0边，对新图做拓扑排序**。 如果做完拓扑排序之后，有几个点没有进入过排序中，就说明这个图有零环，就gg了。 我们把拓扑序做完之后再执行原来有的最短路和dp，这样就不会错了。 就酱，我们就嘴巴AC这道题啦o(￣▽￣)o 。 事实上，这样做并A不了，因为这题TM卡常(╯°Д°)╯︵┻━┻ 然后，你会被卡30分并因此退役（或者是开O2A掉这道题（但是NOIP中并不开O2，所以你还是因此退役了）） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//Luogu P3953 逛公园//Sep,18th,2018//最短路+拓扑排序+DP+卡常神题// luogu-judger-enable-o2#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int M=50+5;const int inf=0x3f3f3f3f;struct DIS&#123; int dis,no,zero;&#125;dis[N];bool cmp(DIS A,DIS B)&#123; if(A.dis==B.dis) return A.zero&lt;B.zero; return A.dis&lt;B.dis;&#125;struct road&#123; int to,w; road(int A,int B) &#123; to=A,w=B; &#125; friend bool operator &lt; (road A,road B) &#123; if(A.w==B.w) return dis[A.to].zero &gt; dis[B.to].zero; return A.w &gt; B.w; &#125;&#125;;vector &lt;road&gt; e[N],rev[N];int n,m,K,poi,T,rd[N],dl2[N],front2,tail2,dis2[N];long long f[N][M];priority_queue &lt;road,vector&lt;road&gt; &gt; dl;bool vis[N];void dj()&#123; for(int i=1;i&lt;=n;i++) dis[i].dis=inf,dis[i].no=i; dis[1].dis=0; memset(dis2,0x3f,sizeof dis2); dis2[1]=0; while(dl.empty()==false) dl.pop(); memset(vis,0,sizeof vis); dl.push(road(1,0)); f[1][0]=1; int cnt=0; while(cnt!=n and dl.empty()==false) &#123; road temp=dl.top(); dl.pop(); if(vis[temp.to]==true) continue; vis[temp.to]=true; int now=temp.to,dis_now=temp.w; for(int i=0;i&lt;int(e[now].size());i++) if(dis_now+e[now][i].w &lt; dis[e[now][i].to].dis) &#123; f[e[now][i].to][0]=f[now][0]; dis[e[now][i].to].dis=dis_now+e[now][i].w; dis2[e[now][i].to]=dis_now+e[now][i].w; dl.push(road(e[now][i].to,dis[e[now][i].to].dis)); &#125; else if(dis_now+e[now][i].w == dis[e[now][i].to].dis) f[e[now][i].to][0]=(f[e[now][i].to][0]+f[now][0])%poi; &#125;&#125;void GetTP()&#123; tail2=front2=0; memset(vis,0,sizeof vis); for(int i=1;i&lt;=n;i++) if(rd[i]==0) dl2[tail2++]=i; int cnt=0; while(tail2&gt;front2) &#123; dis[dl2[front2]].zero=++cnt; vis[dl2[front2]]=true; for(int i=0;i&lt;int(e[dl2[front2]].size());i++) if(e[dl2[front2]][i].w==0 and vis[e[dl2[front2]][i].to]==false) &#123; rd[e[dl2[front2]][i].to]--; if(rd[e[dl2[front2]][i].to]==0) dl2[tail2++]=e[dl2[front2]][i].to; &#125; front2++; &#125;&#125;int main()&#123; T=read(); for(int i=1;i&lt;N;i++) e[i].reserve(4),rev[i].reserve(4); for(;T&gt;0;T--) &#123; memset(f,0,sizeof f); memset(rd,0,sizeof rd); n=read(),m=read(),K=read(),poi=read(); for(int i=1;i&lt;=n;i++) e[i].clear(),rev[i].clear(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(),c=read(); e[a].push_back(road(b,c)); rev[b].push_back(road(a,c)); if(c==0) rd[b]++; &#125; GetTP(); bool OK=true; for(int i=1;i&lt;=n;i++) if(vis[i]==false) OK=false; if(OK==false) &#123; printf(&quot;-1\\n&quot;); continue; &#125; dj(); sort(dis+1,dis+1+n,cmp); for(int j=1;j&lt;=K;j++) for(int i=1;i&lt;=n;i++) for(int k=0;k&lt;int(rev[dis[i].no].size());k++) &#123; int t=dis[i].no,s=rev[t][k].to; if(dis2[t]!=inf and dis2[s]!=inf and dis2[t]+j-dis2[s]-rev[t][k].w&gt;=0 ) f[t][j]=(f[t][j]+f[s][dis2[t]+j-dis2[s]-rev[t][k].w])%poi; &#125; long long ans=0; for(int i=0;i&lt;=K;i++) ans=(ans+f[n][i])%poi; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"DAG DP","slug":"DAG-DP","permalink":"http://www.goldenpotato.cn/categories/DAG-DP/"},{"name":"最短路径","slug":"最短路径","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P2827] 蚯蚓","slug":"luogu-p2827-蚯蚓","date":"2019-02-22T04:44:49.000Z","updated":"2019-02-22T04:44:49.000Z","comments":true,"path":"2019/02/22/luogu-p2827-蚯蚓/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p2827-%E8%9A%AF%E8%9A%93/","excerpt":"","text":"题面： 传送门：洛谷 Solution 看到这题，我们肯定会有一个大胆想法。 那就是直接用堆模拟这个过程。 对于q，我们只需要在堆中多维护一个T,记录每个点插入的时间，在新的元素插入时直接计算所比较的点的当前长度就可以完成插入了。 时间复杂度$O(M*log(M))$ 这样的做法只能获得65-70分，因为后面的数据非常大。 所以说，我们要另寻他路。 首先，我们经过看题解手玩可以发现一个很显然但是很重要的结论： 在$q=0$的时候，一条线段所分裂出来的两条线段肯定要比它更小的线段分裂出来的对应的两条线段更大。 证明十分简单，设x，y为两条分裂前的线段，且x&gt;y 那么，较长的那一条(假设p&gt;0.5(p为分割点)) 为： px 与 py， 显然，px&gt;py 同理可证另一条线段也有这种关系。 根据这个关系，我们可以考虑这样的做法： 我们开三个队列，第一个队列放入排好序的原序列，第二个队列放每次分裂出来的较长的蚯蚓，第三个放每次分裂出来的较短的蚯蚓。 那么根据刚才的证明，我们可以得出，第二个与第三个队列一定是有序的，因为我们每次取的蚯蚓一定比之前取的更短，所以分裂出来的肯定比比之前分裂出来的蚯蚓更短。 这样子，我们就可以模拟这个过程，每次取三个队列中最大的那一个，并把分裂出来的对应放到第二第三个队列的末尾就好。 事实上，对于$q&gt;0$的情况，这个推论也是成立的。 首先，我们可以假设出来x与y分别是分裂前的线段长度且x&gt;y,假设x与y之间间隔的时间为T 那么，在y分裂的时刻，x分裂出来的线段较长的长度为(假设p&gt;0.5)： $px+T_q $ y分裂出来的较长的线段长度为： $(y+T_q)_p = py + T_q_p $ 显然 $ px+T_q &gt; py + T_q_p$ 所以说，我们刚刚的结论在这里也是成立的。 对于在某一时刻的线段的具体长度，我们可以通过在队列中多记录一个插入时间，这样就可以算出某一时刻的某条线段的具体长度了。 时间复杂度$O（nlogn+m）$ . 就酱，我们就可以AC这道题啦(≧ω≦)/ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//Luogu P2827 蚯蚓//Sep,9th,2018//巧妙的三个队列#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;const int M=7000000+N+2000;int a[M],n,m,q,u,v,t;struct worm&#123; int T,s; worm (int A,int B) &#123; s=A,T=B; &#125; inline int GetLen(int mtime)//mtime秒后的长度 &#123; return s+(mtime-T)*q; &#125;&#125;;queue &lt;worm&gt; A,B,C;double p;bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; n=read(),m=read(),q=read(),u=read(),v=read(),t=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+1+n); for(int i=n;i&gt;=1;i--) A.push(worm(a[i],0)); for(int i=1;i&lt;=m;i++) &#123; long long from=-1,t_MAX=-0x3f3f3f3f; if(A.empty()==false) from=1,t_MAX=A.front().GetLen(i-1); if(B.empty()==false and B.front().GetLen(i-1)&gt;t_MAX) from=2,t_MAX=B.front().GetLen(i-1); if(C.empty()==false and C.front().GetLen(i-1)&gt;t_MAX) from=3,t_MAX=C.front().GetLen(i-1); int px=(t_MAX*u)/v,t_px=t_MAX-px; B.push(worm(max(px,t_px),i)); C.push(worm(min(px,t_px),i)); if(from==1) A.pop(); else if(from==2) B.pop(); else C.pop(); if(i%t==0) printf(&quot;%lld &quot;,t_MAX); &#125; printf(&quot;\\n&quot;); n=0; while(A.empty()==false) a[++n]=A.front().GetLen(m),A.pop(); while(B.empty()==false) a[++n]=B.front().GetLen(m),B.pop(); while(C.empty()==false) a[++n]=C.front().GetLen(m),C.pop(); sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++) if(i%t==0) printf(&quot;%d &quot;,a[i]); return 0;&#125;","categories":[{"name":"模拟","slug":"模拟","permalink":"http://www.goldenpotato.cn/categories/%E6%A8%A1%E6%8B%9F/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://www.goldenpotato.cn/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"[Luogu P1066] 2^k进制数","slug":"luogu-p1066-2k进制数","date":"2019-02-22T04:39:53.000Z","updated":"2019-02-22T04:39:53.000Z","comments":true,"path":"2019/02/22/luogu-p1066-2k进制数/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p1066-2k%E8%BF%9B%E5%88%B6%E6%95%B0/","excerpt":"","text":"题面 传送门：洛谷 Solution 这是一道神奇的题目，我们有两种方法来处理这个问题，一种是DP，一种是组合数。 这题需要高精度，以下省略此声明 . DP 如果你对数学不感兴趣/喜欢写DP/(不想虐待自己)，这里是DP做法。 首先，我们可以发现，这个数最多有$w/k$位(向上取整),如下图所示： 那么，我们就可以以这个特性做DP啦。 设$f[i][j]$表示枚举到第i位(指2^k进制下的)，最后一位数为j。 $f[i][j] = ∑ f[i-1][k] ((j==0\\ and\\ k==0)\\ or\\ k&lt;j) $ 这里的k显然是可以用前缀和优化的 初始化 $f[1][i]=1$ (i=0~2^(w%k)-1) 当然，还有一些小细节:f[倒数第2/第1个][0]=0 答案为$∑f[w/k][i] $ （因为我没写过DP做法，这个做法纯口胡，如有错误请通知蒟蒻博主） 组合数 那…组合数呢？ 事实上，这题的组合数做法的确很妙，（当然也有不少细节） 假设我们枚举了第一位数，那么后面位数的方案数是可以通过组合数来计算出来的。 因为后面的数要比第一位大，那么后面的数相当于从 [第一位数+1,2^k-1] 这个数的区间中选出x个数（x为后面的位数数量）来 （因为每一种方案都可以通过摆成升序满足题目要求）。 但是考虑到有可能有若干个前导零，我们还要枚举第一个位数从哪开始。 因为枚举了前导零，我们枚举第一位数时应该从1开始（从0开始会有重复） 这样子，答案为: (事实上口胡起来简单，写起来还有很多细节，这得亲自体会然后就会感到这题的毒瘤) . 就酱，我们就可以切掉嘴巴AC出这道题啦(～￣▽￣)～ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct Int128&#123; static const int N=500; int a[N],len; Int128() &#123; memset(a,0,sizeof a); len=0; &#125; void Print() &#123; for(int i=len;i&gt;=1;i--) printf(&quot;%d&quot;,a[i]); &#125; friend Int128 operator * (Int128 A,int B) &#123; for(int i=1;i&lt;=A.len;i++) A.a[i]*=B; bool IsFullZero=true; for(int i=1;i&lt;=A.len;i++) &#123; if(A.a[i]&gt;=10) &#123; A.a[i+1]+=A.a[i]/10,A.a[i]%=10; if(i==A.len and A.a[i+1]!=0) A.len++; &#125; if(A.a[i]!=0) IsFullZero=false; &#125; if(IsFullZero==true) A.len=1; return A; &#125; friend Int128 operator / (Int128 A,int B) &#123; Int128 ans; int temp=0; for(int i=A.len;i&gt;=1;i--) &#123; temp=temp*10+A.a[i]; if(temp&gt;=B) &#123; ans.a[i]=temp/B,temp=temp%B; ans.len=max(ans.len,i); &#125; &#125; return ans; &#125; friend Int128 operator + (Int128 A,Int128 B) &#123; if(A.len&lt;B.len) swap(A,B); for(int i=1;i&lt;=A.len;i++) &#123; A.a[i]=A.a[i]+B.a[i]; if(A.a[i]&gt;9) &#123; A.a[i+1]++;A.a[i]-=10; if(i==A.len) A.len++; &#125; &#125; return A; &#125;&#125;;const int N=1&lt;&lt;(9+1);Int128 C[N];int n,x,K,w,first,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;K,&amp;w); first=1&lt;&lt;(w%K),x=w/K; if(w%K==0) first=1&lt;&lt;K,x--; m=1&lt;&lt;K; Int128 ans; for(int j=0;j&lt;=x-1;j++) &#123; int tx=x-j; memset(C[tx].a,0,sizeof C[tx].a); C[tx].a[1]=1,C[tx].len=1; for(int i=tx+1;i&lt;=m;i++) &#123; memset(C[i].a,0,sizeof C[i].a); C[i]=(C[i-1]*i)/(i-tx); &#125; if(j!=0) first=m; for(int i=1;i&lt;m and i&lt;first;i++) &#123; if(m-1-i&lt;tx) break; ans=ans+C[m-1-i]; &#125; //ans.Print(); //cerr&lt;&lt;endl; &#125; ans.Print(); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"组合数学","slug":"组合数学","permalink":"http://www.goldenpotato.cn/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P3959] 宝藏","slug":"luogu-p3959-宝藏","date":"2019-02-22T04:34:44.000Z","updated":"2019-02-22T04:34:44.000Z","comments":true,"path":"2019/02/22/luogu-p3959-宝藏/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p3959-%E5%AE%9D%E8%97%8F/","excerpt":"","text":"题面 传送门：洛谷 Solution 这道题的是一道很巧妙的状压DP题。 首先，看到数据范围，应该状压DP没错了。 根据我们之前状压方程的设计经验，我们很快就能设计出这样的方程： 设$f[i][j]$表示用到第i个元素，当前连接状态为j的开销的min 但是我们很快就会发现，这个方程没法转移，因为随着连接方案的不同，新插入的点的K值会不同。 怎么办呢？ 这时候我们可以重新设计一个巧妙的的状态。 重新阅读题目，我们可以发现题目中的K值可以理解为距离初始点的“层数”，下面这幅图可以简单的表示出来: 那么，我们可以考虑这样子设状态： 设$f[i][j]$表示到第$i$层，总共取了的点的状态为$j$。 这样的话，转移就可以取出来了： $f[i][j]=MIN(f[i-1][k]+trans[k][j]*(i-1))$ (k为j的子集，即有可能转移到j的状态) (trans[k][j]表示从状态k转移到状态j的最小花费的路程) trans需要暴力预处理出来。 怎么枚举子集呢？ 如果$2^n$枚举就会T掉，因为我们枚举到了非子集的情况。 这里就引出了枚举子集的小技巧 对于状态x，它的子集为：$p=x,p!=0,p=(p-1)\\&amp;x $ (至于怎么证明，这里就不给出了，在草稿上推一推就会发现里面的精妙了) 答案就是$min(f[i][2^{n-1}])$，初始化$f[1][2^{i-1}]=0 (i∈[1,n])$ 就酱，这道题就被我们切掉啦φ(&gt;ω&lt;*) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Luogu P3959 宝藏 //Sep,5th,2018//状压DP+枚举子集小技巧#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=12+2;const int M=1&lt;&lt;N;int n,m,dis[N][N],trans[M][M],POW[N];long long f[N][M];int main()&#123; n=read(),m=read(); memset(dis,0x3f,sizeof dis); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(),v=read(); if(dis[s][t]&gt;v) dis[s][t]=dis[t][s]=v; &#125; m=(1&lt;&lt;n); POW[0]=1; for(int i=1;i&lt;=n;i++) POW[i]=POW[i-1]*2; for(int i=0;i&lt;m;i++) for(int j=i;j!=0;j=(j-1)&amp;i) &#123; bool OK=true; int temp=i^j; for(int k=n-1;k&gt;=0;k--) if(temp&gt;=POW[k]) &#123; int tmin=0x3f3f3f3f; for(int o=1;o&lt;=n;o++) if((POW[o-1]&amp;j)==POW[o-1]) tmin=min(tmin,dis[o][k+1]); if(tmin==0x3f3f3f3f) &#123; OK=false; break; &#125; trans[j][i]+=tmin; temp-=POW[k]; &#125; if(OK==false) trans[j][i]=0x3f3f3f3f; &#125; /*cerr&lt;&lt;endl&lt;&lt;endl; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) if(trans[i][j]!=0x3f3f3f3f and trans[i][j]!=0) cerr&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;trans[i][j]&lt;&lt;endl;*/ memset(f,0x3f,sizeof f); for(int i=1;i&lt;=n;i++) f[1][POW[i-1]]=0; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;m;j++) for(int k=j;k!=0;k=(k-1)&amp;j) if(trans[k][j]!=0x3f3f3f3f) f[i][j]=min(f[i][j],f[i-1][k]+(i-1)*trans[k][j]); long long ans=0x3f3f3f3f3f3f3f3fll; for(int i=1;i&lt;=n;i++) ans=min(ans,f[i][m-1]); printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状压DP","slug":"状压DP","permalink":"http://www.goldenpotato.cn/categories/%E7%8A%B6%E5%8E%8BDP/"}],"tags":[]},{"title":"[Luogu P3986] 斐波那契数列","slug":"luogu-p3986-斐波那契数列","date":"2019-02-22T04:31:00.000Z","updated":"2019-02-22T04:31:00.000Z","comments":true,"path":"2019/02/22/luogu-p3986-斐波那契数列/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p3986-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"","text":"题面 传送门：洛谷 Solution 这是一道很有意思的数论题。 首先，我们可以发现直接枚举a和b会T的起飞。 接下来，我们就可以观察一下式子了，我们略微手算一下，就会有这样的结果： 我们可以发现，a，b在每一项中的数量都可以用同一个斐波那契数列表示。 我们可以用$g[x]$表示斐波那契数列的第x项，那么，我们可以得到$f[x]=a_g[x-1]+b_g[x]$ 接下来，由常识可以知道，斐波那契数列的第40项就差不多有10^9那么大了。 所以说，我们可以考虑枚举当前项x，问题就变为了有多少个$a，b$使得 $K=a_g[x-1]+b_g[x]$ 移项得：$b=(K-g[x-1]*a)/g[x]$ 因为$a，b$都是整数，问题就变为了有多少个$a$，使得$K-g[x-1]*a$能被$g[x]$整除 即： 对于斐波那契数列，有一个定理，就是$f[x]$与$f[x-1]$互质（证明略复杂，在这里就不给出了），这样就保证了同余方程有解。 同时，我们还有一个限制，就是$ K-g[x-1]*a &gt; 0 $(因为b&gt;0)即$ a&lt;K/g[x-1] $的 由这两个式子，我们就可以求出对于每一个$x$，有多少个$a，b$可以使得$K=a_g[x-1]+b_g[x]$ . 酱紫，我们就可以AC这道题(≧∀≦)♪ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N=45;const int n=40+2;const int poi=1000000007;long long f[N],K,ans;long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)&#123; if(B==0) &#123; x=1,y=0; return A; &#125; long long temp=exgcd(B,A%B,x,y),tx=x; x=y,y=tx-(A/B)*y; return temp;&#125;long long inv(long long A,long long POI)&#123; long long t,tt; exgcd(A,POI,t,tt); return (t%POI+POI)%POI;&#125;int main()&#123; scanf(&quot;%lld&quot;,&amp;K); f[1]=f[2]=1; for(int i=3;i&lt;=n;i++) f[i]=f[i-1]+f[i-2]; for(int i=2;i&lt;=n;i++) &#123; long long a=(K*inv(f[i-1],f[i]))%f[i],to=K/f[i-1]-1; if(a&lt;to) &#123; if(a==0) ans--; ans=(ans+1+(to-a)/f[i])%poi; &#125; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"[Luogu P3626] [APIO2009] 会议中心","slug":"luogu-p3626-apio2009-会议中心","date":"2019-02-22T04:26:58.000Z","updated":"2019-02-22T04:26:58.000Z","comments":true,"path":"2019/02/22/luogu-p3626-apio2009-会议中心/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p3626-apio2009-%E4%BC%9A%E8%AE%AE%E4%B8%AD%E5%BF%83/","excerpt":"","text":"题面 传送门：洛谷 Solution 如果题目只要求求出第一问，那这题显然就是大水题。 但是加上第二问的话…那这题就成为大（du）火（liu）题了。 对于第一问：求一整个区间的最大线段总数，我们可以很轻松的切掉。 怎么处理第二问呢？ 我们可以考虑这样做： 对于一条线段，如果它属于答案的一部分，那么它一定会有以下性质： 区间③的最大线段数 = 区间①的最大线段数 + 区间②的最大线段数 + 1（当前线段） （区间最大线段数指用传统贪心方法求出的一段区间的可能的最多的线段的数量） 那怎么求一段区间的最大线段数呢？ 第一想法是前缀和？看起来很OK？ nope 因为不同区间中，里面的的初始线段会不同，以下这个图可以简单说明这种情况 但是，我们可以发现一个很重要的特点： 每条线段的下一条可行线段是固定的 有了这个特点，我们就可以对路径做倍增，就可以在log的时间求出某一个区间的线段数。 至于求每一个区间的第一条线段，我们可以用set+lowbound的方法找。 这样子，你就可以嘴巴AC这道题啦 实际上你会花费大量的时间来调这道毒瘤题 Code （我常数太大，开O2才能卡过（set太辣鸡）） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// luogu-judger-enable-o2#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=200000+100;struct line&#123; int l,r,no; friend bool operator &lt; (line A,line B) &#123; return A.l&lt;B.l; &#125;&#125;l[N];bool cmp(line A,line B)&#123; if(A.l==B.l) &#123; if(A.r!=B.r) return A.r&gt;B.r; else return A.no&gt;B.no; &#125; return A.l&lt;B.l;&#125;bool cmp2(line A,line B)&#123; return A.no&lt;B.no;&#125;int n,ans,root,fa[N][20+2];bool use[N],vis[N];stack &lt;int&gt; ms;set &lt;line&gt; mset;set &lt;line&gt; used;vector &lt;int&gt; e[N];void dfs(int now,int FA)&#123; vis[now]=true; fa[now][0]=FA; for(int i=1;i&lt;=20;i++) fa[now][i]=fa[fa[now][i-1]][i-1]; for(int i=0;i&lt;int(e[now].size());i++) if(vis[e[now][i]]==false) dfs(e[now][i],now);&#125;int POW[21];int Count(int L,int R)&#123; line temp; temp.l=L; set&lt;line&gt;:: iterator t=mset.lower_bound(temp); if((*t).r &gt; R) return 0; int now=(*t).no,ans=1; for(int i=20;i&gt;=0;i--) if(l[fa[now][i]].r&lt;=R and fa[now][i]!=0) now=fa[now][i],ans+=POW[i]; return ans;&#125;int main()&#123; //freopen(&quot;center.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;center.out&quot;,&quot;w&quot;,stdout); n=read(); for(int i=1;i&lt;=n;i++) l[i].l=read(),l[i].r=read(),l[i].no=i; sort(l+1,l+1+n,cmp); memset(use,1,sizeof use); for(int i=1;i&lt;=n;i++) &#123; while(ms.empty()==false and l[ms.top()].r&gt;=l[i].r) &#123; use[ms.top()]=false; ms.pop(); &#125; ms.push(i); &#125; int to=-1; for(int i=1;i&lt;=n;i++) if(use[i]==true and l[i].l&gt;to) &#123; ans++; to=l[i].r; &#125; for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=n;i++) if(use[i]==true) &#123; //cerr&lt;&lt;l[i].no&lt;&lt;&quot; &quot;; mset.insert(l[i]); bool OK=false; for(int j=i+1;j&lt;=n;j++) if(use[j]==true and l[j].l&gt;l[i].r) &#123; e[l[j].no].push_back(l[i].no); OK=true; break; &#125; if(OK==false) e[0].push_back(l[i].no); &#125; printf(&quot;%d\\n&quot;,ans); dfs(0,0); sort(l+1,l+1+n,cmp2); for(int i=0;i&lt;=20;i++) POW[i]=1&lt;&lt;i; l[0].r=0x3f3f3f3f; line tt; tt.l=-1,tt.r=-1,tt.no=0; mset.insert(tt),used.insert(tt); tt.l=0x3f3f3f3f,tt.r=0x3f3f3f3f;mset.insert(tt),used.insert(tt); for(int i=1;i&lt;=n;i++) &#123; int L,R; set&lt;line&gt;:: iterator t=used.lower_bound(l[i]); if((*t).l&lt;=l[i].r) continue; R=(*t).l-1; t--; if((*t).r&gt;=l[i].l) continue; L=(*t).r+1; if(Count(L,l[i].l-1)+Count(l[i].r+1,R)==Count(L,R)-1) &#123; printf(&quot;%d &quot;,i); used.insert(l[i]); &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"堆","slug":"堆","permalink":"http://www.goldenpotato.cn/categories/%E5%A0%86/"},{"name":"set","slug":"set","permalink":"http://www.goldenpotato.cn/categories/set/"},{"name":"倍增","slug":"倍增","permalink":"http://www.goldenpotato.cn/categories/%E5%80%8D%E5%A2%9E/"},{"name":"贪心","slug":"贪心","permalink":"http://www.goldenpotato.cn/categories/%E8%B4%AA%E5%BF%83/"}],"tags":[]},{"title":"[Luogu P1450] [HAOI2008]硬币购物","slug":"luogu-p1450-haoi2008硬币购物","date":"2019-02-22T01:35:37.000Z","updated":"2019-02-22T01:35:37.000Z","comments":true,"path":"2019/02/22/luogu-p1450-haoi2008硬币购物/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p1450-haoi2008%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9/","excerpt":"","text":"题面 传送门：洛谷 Solution 这是一道很有意思的在背包里面做容斥的题目。 首先，我们可以很轻松地想到暴力做背包的做法。 就是对于每一次询问，我们都做一次背包。 复杂度$O(tot_s_log(di))$ (使用二进制背包优化) 显然会T得起飞。 接下来，我们可以换一种角度来思考这个问题。 首先，我们可以假设没有每个物品的数量的限制，那么这样就会变成一个很简单的完全背包问题。 至于完全背包怎么写，我们在这里就不做过多讨论，如有需要，看看代码就能理解了。 完全背包做完后，我们可以得到一个$f[i]$表示填满i的背包的方案数的数组。 那么，我们接下来可以用容斥来解决不可行的方案的问题。 假设只有1件物品的使用次数超出了所给的数量，假设这件物品是第x件。 那么可以用 $f[s-(d[x]+1)*c[x]]$ 表示这件物品不可行的方案总数。 因为对于花钱数为$s-(d[x]+1)_c[x]$ 里面的每一种方法，都可以通过使用购买$d[x]+1$件的$x$物品来超出所给的数量。所以 $f[s-(d[x]+1)_c[x]]$ 可以表示该物品不可行方案总数。 那么答案是四件物品不可行方案总数这和吗？ nope 因为我们会重复减去一些东西。例如：一种方案即超出了第一件物品的使用数，也超出了第二件物品的使用数，我们却重复扣除了这种方案两次。 所以说我们这时候就得使用容斥来解决这个问题。 容斥中有一个很基础的定理（我不会证）： 对于有n的限制条件的事件，只要其中符合一个条件就算可行，其可行方案总数为： （符合其中0个（条件的方案数，后同）-符合其中1个+符合其中2个-符合其中3个+符合其中4个-符合其中5个+符合其中6个…） 那么，我们就可以根据这个定理求出不可行的方案总数。 对于这题来说，代码如下: 1234567891011121314for(a[1]=0;a[1]&lt;=1;a[1]++) for(a[2]=0;a[2]&lt;=1;a[2]++) for(a[3]=0;a[3]&lt;=1;a[3]++) for(a[4]=0;a[4]&lt;=1;a[4]++) &#123; int cnt=0,t_s=s; for(int j=1;j&lt;=4;j++) if(a[j]==1) cnt++,t_s-=(d[j]+1)*c[j]; if(cnt%2==0) cnt=1; else cnt=-1; if(t_s&gt;=0) ans=ans+cnt*f[t_s]; &#125; Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Luogu P1450 [HAOI2008]硬币购物//Aug,27th,2018//DP+容斥#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+1000;long long f[N];int n,m;long long c[5],d[5];int main(int argc, char **argv)&#123; for(int i=1;i&lt;=4;i++) c[i]=read(); m=read(); f[0]=1; for(int j=1;j&lt;=4;j++) for(int i=c[j];i&lt;=100000;i++) f[i]+=f[i-c[j]]; for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=4;j++) d[j]=read(); int s=read(),a[5]; long long ans=0; for(a[1]=0;a[1]&lt;=1;a[1]++) for(a[2]=0;a[2]&lt;=1;a[2]++) for(a[3]=0;a[3]&lt;=1;a[3]++) for(a[4]=0;a[4]&lt;=1;a[4]++) &#123; int cnt=0,t_s=s; for(int j=1;j&lt;=4;j++) if(a[j]==1) cnt++,t_s-=(d[j]+1)*c[j]; if(cnt%2==0) cnt=1; else cnt=-1; if(t_s&gt;=0) ans=ans+cnt*f[t_s]; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;//正解(c++)","categories":[{"name":"背包DP","slug":"背包DP","permalink":"http://www.goldenpotato.cn/categories/%E8%83%8C%E5%8C%85DP/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"容斥","slug":"容斥","permalink":"http://www.goldenpotato.cn/categories/%E5%AE%B9%E6%96%A5/"}],"tags":[]},{"title":"[Luogu P2014]选课","slug":"luogu-p2014选课","date":"2019-02-22T01:30:50.000Z","updated":"2019-02-22T01:30:50.000Z","comments":true,"path":"2019/02/22/luogu-p2014选课/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p2014%E9%80%89%E8%AF%BE/","excerpt":"","text":"题面 传送门：洛谷 Solution 这是一道十分经典的树形DP题，这种类型的树形DP有一种很普遍的解法。 首先，观察题目，我们把这道题转换一下：给定一颗树，选出包含1号节点（根)的一颗子树，使得点权和最大。 我们可以这样子定义状态： 设$f[i][j]$ 表示以i为根节点的子树，选出j个节点，所能达到的最大点权值。 对于二叉树来说，转移很显然，就是枚举左子树分配多少个节点，就可以对应的得出右子树能分配到多少个节点，对所有情况取最大值就好。 对于多叉树来说，问题就没有那么简单了，这里，我们有两个方案可以解决这个问题： 一是多叉树转二叉树， 二是树上背包。 因为我不会多叉树转二叉树，所以在这里我主要讲一讲第二种方法。 我们一般在树上做的是多重背包问题。 我以本题为例子，讲一下树上如何做多重背包。 首先，我们肯定要一层循环枚举子树(可以类似为背包问题中枚举第几件物品)。 第二层循环我们得枚举当前以节点的子树能分配的节点数（可以类似为背包问题中枚举背包容量） (这一层循环一定要从后往前枚举，类似与背包压在一维做的做法) 第三层循环我们就可以枚举当前子树分配多少个节点了（可以类似多重背包中枚举第i件物品要几件） 下面是这种枚举在这道题应用的代码： 123456789for(int i=0;i&lt;int(e[x].size());i++)//枚举子树 &#123; int temp=dfs(e[x][i]);//先把子树的f递归下去算出来 tot+=temp;//tot记录到当前子树为止总节点数 for(int j=tot;j&gt;=1;j--)//枚举自己这颗树的总分配数 for(int k=0;k&lt;=temp;k++)//枚举子树分配多少个节点 if(j-k&gt;=1) f[x][j]=max(f[x][j],f[x][j-k]+f[e[x][i]][k]); &#125; 树上背包一般看上去是三重循环，非常恐怖。 但事实上，根据一堆证明（不会证），其复杂度为两重循环。 所以复杂度应该是O（能过） 复杂度是$O(N_N_M)$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1;char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=300+10;vector &lt;int&gt; e[N];long long n,m,f[N][N],v[N];int dfs(int x)&#123; int tot=1; f[x][1]=v[x]; for(int i=0;i&lt;int(e[x].size());i++) &#123; int temp=dfs(e[x][i]); tot+=temp; for(int j=tot;j&gt;=1;j--) for(int k=0;k&lt;=temp;k++) if(j-k&gt;=1) f[x][j]=max(f[x][j],f[x][j-k]+f[e[x][i]][k]); &#125; return tot;&#125;int main()&#123; n=read(),m=read(); for(int i=0;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=n;i++) &#123; e[read()].push_back(i); v[i]=read(); &#125; dfs(0); printf(&quot;%lld&quot;,f[0][m+1]); return 0;&#125;//正解(c++)","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%BD%A2DP/"}],"tags":[]},{"title":"[Luogu P1122]最大子树和","slug":"luogu-p1122最大子树和","date":"2019-02-22T01:26:58.000Z","updated":"2019-02-22T01:26:58.000Z","comments":true,"path":"2019/02/22/luogu-p1122最大子树和/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p1122%E6%9C%80%E5%A4%A7%E5%AD%90%E6%A0%91%E5%92%8C/","excerpt":"","text":"题面 传送门：洛谷 Solution 这是一道简单的树形DP题。 首先，我们可以转换一下题面，可以发现，题目要求我们求出一颗树上的最大联通子图。 因为我们是在树上取的，实际上就是取一颗子树。 这个就是最基础的树形DP模型了。 我们可以设f[i]表示我们选的子图以i为根所能取的子树的最大值。 转移是： $f[i] = beauty[i] + xigema(max(f[j],0))$ （也就是一颗树的孩子所能取的子树，如果它孩子为根的子树&gt;0，就取它，否则不取） 答案就是最大的$f[i]$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Luogu P1122 最大子树和//Jul,30th,2018//树形DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=16000+100;const int inf=0x3f3f3f3f;vector &lt;int&gt; e[N];int n,beauty[N];long long f[N];bool vis[N];long long dfs(int x)&#123; f[x]=beauty[x]; vis[x]=true; for(int i=0;i&lt;int(e[x].size());i++) if(vis[e[x][i]]==false) f[x]=max(f[x],f[x]+dfs(e[x][i])); return f[x];&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4); for(int i=1;i&lt;=n;i++) beauty[i]=read(); for(int i=1;i&lt;n;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; dfs(1); long long ans=-inf; for(int i=1;i&lt;=n;i++) ans=max(ans,f[i]); printf(&quot;%lld&quot;,ans); return 0;&#125;//正解(C++)","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%BD%A2DP/"}],"tags":[]},{"title":"[Luogu P2261] [CQOI2007]余数求和","slug":"luogu-p2261-cqoi2007余数求和","date":"2019-02-22T01:08:07.000Z","updated":"2019-02-22T01:08:07.000Z","comments":true,"path":"2019/02/22/luogu-p2261-cqoi2007余数求和/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p2261-cqoi2007%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C/","excerpt":"","text":"题面 传送门：洛谷 Solution 这题显然有一个$O(n)$的直接计算法，$60$分到手。 接下来我们就可以拿出草稿纸推一推式子了 首先，取模运算在这里很不和谐，我们得转换一下。 对于任意取模计算，我们都有： 所以，我们可以做以下推算 经过一些手算，我们发现$k/i$(向下取整)是由一段一段的区间组成的，如下图 显然，每段区间的右端点可以通过二分的方法来找 对于每一段区间，我们可以把k/i提出来，括号里面就变成了（i+(i+1)+(i+2)+(i+3)+…+右端点） 直接用等差数列来算就好 时间复杂度我不会算XD Code 1234567891011121314151617181920212223242526272829303132333435//Luogu P2261 [CQOI2007]余数求和//Jul,7th//取模运算推一推#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(int argc, char **argv)&#123; //freopen(&quot;sum.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;sum.out&quot;,&quot;w&quot;,stdout); long long n,K; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;K); long long ans=n*K; for(long long i=1;i&lt;=n;i++) &#123; long long temp=K/i; long long l=i,r=n,mid,nxt=i; while(l&lt;=r) &#123; mid=(l+r)/2; if(K/mid==temp) nxt=max(nxt,mid),l=mid+1; else r=mid-1; &#125; ans-=(((i+nxt)*(nxt-i+1))/2)*temp; i=nxt; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;//正解（C++）","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"一些坑点","slug":"一些坑点-2","date":"2019-02-22T01:03:37.000Z","updated":"2019-02-22T01:03:37.000Z","comments":true,"path":"2019/02/22/一些坑点-2/","permalink":"http://www.goldenpotato.cn/2019/02/22/%E4%B8%80%E4%BA%9B%E5%9D%91%E7%82%B9-2/","excerpt":"","text":"填坑中 $\\color{blue} {last update ： Jan,21st,2019}$ 通用 $\\color {red} {-1.仔细审题*2}$ 永远要有想法，不要觉得复杂度不对空间就不开够。空间永远开到最大值（或者说是自己不MLE的极限），以免发生复杂度正确但是空间没有开够的惨痛教训（NOI.ac WHZZT 邀请赛R1） 在会爆int的题目中，一定要仔细检查是否有会爆int的中间变量写了int。 （from NNEZ_R2_T1） 使用-=时，把-=后面的东西用括号括起来，防止可能出现的负负为正等SB错误 (from Luogu P1270) 在需要mod一个数的题目中，要检查输出(printf)时有没有做计算,如果有计算，要括起来再mod一次(Luogu P2679) 使用迭代器时，不要在if中++或–，以免出现奇奇怪怪的顺序问题。 (Luogu P3626) 二分答案/二分时，不要瞎JB对左端点和右端点优化，直接取题面的最大值和最小值就好，防止因端点取错而爆炸（from NNEZ_R2_T3） DP 在初始化不是0（0作为极值的情况下），一定要讨论可以取得到的边界条件，否则会听取WA声一片。 (Luogu P1437) 一定要仔细检查答案应该取哪个状态。 ([HAOI2008]木棍分割) 数论 使用exgcd时，记得检查x，y变量前是否加上了&amp;。 （Luogu P1516） 计算lcm时，先除gcd再乘，以防乘爆 （Luogu P4777） 线性求欧拉函数和莫比乌斯函数时，要注意初始化phi[1]=1或miu[1]=1 写FFT时，记得加上对type的判断，若type=true，则x0=conj(x0); 计算几何 求凸包的时候要对x，y都排序，且要去重，在一条直线上也要弹栈（防止全部全在一条直线上的数据）。否则将会在用凸包求其他东西的时候出现奇奇怪怪的问题。 旋转卡壳一定要特判n==2的情况。 数据结构 并查集中在求需要父亲的地方，请直接调用函数，而不要相信你路径压缩过的fa[x]，直接调用的话有可能因为各种各样奇怪的原因导致你取到的不是最终父亲。(from Luogu P2170) 线段树pushdown的时候记得特判叶子节点的情况，否则会RE到飞起 （NOI2015 软件包管理器） 圆方树一定要开2倍空间（来存额外的方点） ([BeiJing2013]压力) 小心线段树的常数 (NNEZ noip2018R2 T1) splay查询时也要splay以保证势能分析有效 ([Luogu P4197] Peaks ) 图论 Dinic在分层时记得$vis[S]=true;$ (P4174 [NOI2006]最大获利) 在多组数据时，Tarjan的栈一定要清空，防止一些偶然事件 (Uva610) 字符串 SAM要开两倍空间。 (Luogu P3975[TJOI]弦论)","categories":[{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"[Luogu P1613]跑路","slug":"luogu-p1613跑路","date":"2019-02-22T00:55:58.000Z","updated":"2019-02-22T00:55:58.000Z","comments":true,"path":"2019/02/22/luogu-p1613跑路/","permalink":"http://www.goldenpotato.cn/2019/02/22/luogu-p1613%E8%B7%91%E8%B7%AF/","excerpt":"","text":"题面 传送门:洛咕 Solution 挺有意思的一道题。 题面已经挺明显的描述出了这题的主要思想：倍增。 先这样想，我们可以把这题这样建模：有一堆点，若两个点之间的距离之和可以达到2的n次方，那么这两个点可以用1的时间相互到达。 也就是说，我们把距离能为2的n次方的点对用边权为1的边连上，再做一次最短路径，就可以求出答案了。 接下来问题就是如何求出每两个点是否能以2的n次方的时间相互到达。 考虑使用DP。 我们设$f[i][j][k]$ 表示 $i$到$j$是否能以$2$的$k$次方的距离相互到达。 转移的时候得运用倍增的思想：若两个点能以两端$2$的$k-1$次方的距离相互到达，那么两个点就能以2的k次方的距离相互到。 接下来我们就可以运用类似Floyd的办法来处理这个DP，我们可以在最外层枚举这个k，里面三层和Floyd的意义一模一样，就是枚举中转点与起始点。 初始化就是题目中直接相连的两个点，它们的$f[a][b][0]=1$ （它们距离为1,是2的0次方） 时间复杂度： $O(n^3*64)$ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Luogu P1613 跑路//June,13th,2018//倍增+DP+最短路#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=50+10;const int K=65+10;int f[N][N][K],dis[N][N],n,m;int main()&#123; n=read(),m=read(); memset(dis,0x3f,sizeof dis); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); f[s][t][0]=1; dis[s][t]=1; &#125; for(int o=1;o&lt;=64;o++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) if(f[j][i][o-1]==true and f[i][k][o-1]==true) &#123; f[j][k][o]=true; dis[j][k]=1; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) dis[j][k]=min(dis[j][k],dis[j][i]+dis[i][k]); printf(&quot;%d&quot;,dis[1][n]); return 0;&#125;//正解（C++）","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"DAG DP","slug":"DAG-DP","permalink":"http://www.goldenpotato.cn/categories/DAG-DP/"},{"name":"最短路径","slug":"最短路径","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P3469] [POI2008]BLO-Blockade (割点)","slug":"luogu-p3469-poi2008blo-blockade-割点","date":"2019-02-19T11:34:22.000Z","updated":"2019-02-19T11:34:22.000Z","comments":true,"path":"2019/02/19/luogu-p3469-poi2008blo-blockade-割点/","permalink":"http://www.goldenpotato.cn/2019/02/19/luogu-p3469-poi2008blo-blockade-%E5%89%B2%E7%82%B9/","excerpt":"","text":"题面 传送门：洛谷 Solution 先跟我大声念： $\\huge poi!$ . 然后开始干正事。 首先，我们先把题目中的点分为两类：去除这个点能把图分为几个部分的，去除这个点不影响整个图的连通性的。 如下图： 点上的数字表示这个点的搜索序。 我们称这些对连通性有影响的点为割点。 先假设我们能求出这些点以及其出去后把图分为几块之后那几块分别的大小。 是不是发现了什么？ 对于非割点，答案显然是$2*(n-1)$ (因为它不能影响别的点对连通性，能影响的只是别人到它以及它到别人) 对于割点，它把那几块弄得无法联通，即那几块中不同块的两个点肯定就无法联通了，答案也就是每组块的点的数量互相乘出来，再加上$2*(n-1)$。 接下来就是如何求割点了。 这时候我们又得请出伟大的$Tarjan$了。 先回忆一下求强连通分块的做法，我们这里求割点的做法与其类似。 但有以下几点不同： 1.我们在求low的时候不用讨论所连向的点是否在栈中了，因为无向图中没有横插边的说法（但是要记录当前的父亲，防止我们的low直接计算回去） 2.当一个点的某一个孩子的low&gt;=此点的dfn时，说明这个点就是割点。因为孩子的low大于当前节点的dfn，说明它没有办法直接从当前节点回到搜索树搜过的节点。如果当前节点删除了，此孩子将会分割开来） 至于怎么求每个孩子的size… （我想这个应该不用说了吧） 就是搜的时候加上去就好，如果不清楚的话看一下代码就懂了。 时间复杂度$O(n)$ 完全OjbK Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Luogu P3469 [POI2008]BLO-Blockade//June,11th,2018//玄幻割点#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;vector &lt;long long&gt; e[N],nd_size[N];int n,m;int dfn[N],low[N],IsGD[N],nd_to,size[N];void Tarjan(int now,int fa)&#123; dfn[now]=low[now]=++nd_to; size[now]++; int temp=0; for(int i=0;i&lt;int(e[now].size());i++) if(dfn[e[now][i]]==0) &#123; Tarjan(e[now][i],now); size[now]+=size[e[now][i]]; low[now]=min(low[now],low[e[now][i]]); if(low[e[now][i]]&gt;=dfn[now]) &#123; temp+=size[e[now][i]]; IsGD[now]=true; nd_size[now].push_back(size[e[now][i]]); &#125; &#125; else if(e[now][i]!=fa) low[now]=min(low[now],low[e[now][i]]); if(IsGD[now]==true and n-temp-1!=0) nd_size[now].push_back(n-temp-1);&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) &#123; e[i].reserve(4); nd_size[i].reserve(4); &#125; for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); e[t].push_back(s); &#125; Tarjan(1,0); for(int i=1;i&lt;=n;i++) &#123; long long ans=2*(n-1); if(nd_size[i].size()!=0 and nd_size[i].size()!=1) &#123; for(int j=0;j&lt;int(nd_size[i].size());j++) for(int k=j+1;k&lt;int(nd_size[i].size());k++) ans+=2*nd_size[i][j]*nd_size[i][k]; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"缩点/强连通分量","slug":"缩点-强连通分量","permalink":"http://www.goldenpotato.cn/categories/%E7%BC%A9%E7%82%B9-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P3119] [USACO15JAN]草鉴定Grass Cownoisseur","slug":"luogu-p3119-usaco15jan草鉴定grass-cownoisseur","date":"2019-02-17T03:02:38.000Z","updated":"2019-02-17T03:02:38.000Z","comments":true,"path":"2019/02/17/luogu-p3119-usaco15jan草鉴定grass-cownoisseur/","permalink":"http://www.goldenpotato.cn/2019/02/17/luogu-p3119-usaco15jan%E8%8D%89%E9%89%B4%E5%AE%9Agrass-cownoisseur/","excerpt":"","text":"题面 传送门：洛谷 Solution 这题显然要先把缩点做了。 然后我们就可以考虑如何处理走反向边的问题。 像我这样的蒟蒻，当然是使用搜索，带记忆化的那种（滑稽）。 考虑设$f(i,j)$表示到达第i个点，还能走j次反向边，所能到达的最多的点的数量。 转移可以表示为： 如果x能到达1所在的强连通分量或max出来的值不为0，说明当前状态可行，否则不可行。 然后用记忆化搜索表达出来就OK了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+100;struct road&#123; int to,IsBack; road (int A,int B) &#123; to=A,IsBack=B; &#125;&#125;;vector &lt;int&gt; e[N];vector &lt;road&gt; e2[N];int belong[N],nd_tot,nd_to,low[N],dfn[N],InStack[N],cnt[N];stack &lt;int&gt; st;void Tarjan(int now)&#123; low[now]=dfn[now]=++nd_to; InStack[now]=true; st.push(now); for(int i=0;i&lt;int(e[now].size());i++) if(dfn[e[now][i]]==0) &#123; Tarjan(e[now][i]); low[now]=min(low[now],low[e[now][i]]); &#125; else if(InStack[e[now][i]]==true) low[now]=min(low[now],low[e[now][i]]); if(low[now]==dfn[now]) &#123; nd_tot++; while(st.empty()==false) &#123; int temp=st.top(); st.pop(); belong[temp]=nd_tot; InStack[temp]=false; cnt[nd_tot]++; if(temp==now) break; &#125; &#125;&#125;int n,m,S,f[N][2];int dfs(int now,int back)&#123; if(f[now][back]&gt;=0) return f[now][back]; int t_ans=0; bool OK=false; for(int i=0;i&lt;int(e2[now].size());i++) if(e2[now][i].to!=S and back-e2[now][i].IsBack&gt;=0) t_ans=max(t_ans,dfs(e2[now][i].to,back-e2[now][i].IsBack)); else if(back&gt;=e2[now][i].IsBack) OK=true; if(t_ans!=0 or OK==true) return f[now][back]=t_ans+cnt[now]; else return f[now][back]=0;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(4), e2[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[s].push_back(t); &#125; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) Tarjan(i); S=belong[1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;int(e[i].size());j++) if(belong[i]!=belong[e[i][j]]) &#123; e2[belong[i]].push_back(road(belong[e[i][j]],0)); e2[belong[e[i][j]]].push_back(road(belong[i],1)); &#125; memset(f,0x80,sizeof f); int ans=0; for(int i=0;i&lt;int(e2[S].size());i++) ans=max(ans,dfs(e2[S][i].to,1-e2[S][i].IsBack)); printf(&quot;%d&quot;,ans+cnt[S]); return 0;&#125;//C++（正解）","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"DAG DP","slug":"DAG-DP","permalink":"http://www.goldenpotato.cn/categories/DAG-DP/"},{"name":"缩点/强连通分量","slug":"缩点-强连通分量","permalink":"http://www.goldenpotato.cn/categories/%E7%BC%A9%E7%82%B9-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P2341] [HAOI2006]受欢迎的牛","slug":"luogu-p2341-haoi2006受欢迎的牛","date":"2019-02-15T15:52:43.000Z","updated":"2019-02-15T15:52:43.000Z","comments":true,"path":"2019/02/15/luogu-p2341-haoi2006受欢迎的牛/","permalink":"http://www.goldenpotato.cn/2019/02/15/luogu-p2341-haoi2006%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/","excerpt":"","text":"题面 传送门：洛谷 Solution 前排提示，本蒟蒻做法既奇葩又麻烦 我们先可以把题目转换一下。 可以把一头牛喜欢另外一头牛理解为另外一头牛被一头牛喜欢。 我们把被喜欢的关系建边，即B被A喜欢，从B向A连一条有向边。 显然，一个点若能到达其他所有节点，它就是题目中的明星牛。 接下来，我们可以考虑一个类似于DP的做法。 即一个点能访问到的点，等同于它的儿子们访问的到的点加上它自己。 显然，这种特性要在DAG（有向无环图）上才能方便的使用。 所以说，我们第一步要对题目做的是缩点。 缩完点之后，我们就可以进行图上DP了。 我们可以用一个01数组$f[i][j]$表示i能具体能到达的点为j（用010101数列表示）。 显然 f[i] = f[k] （或运算）（k为i直接相连的点） 答案为f[i][j] j=11111111… 的点 当然，这样做有一个问题。 点的最大数目为n，我们这样做是$O(n^2)$的，在最坏条件（没有一个点能缩在一起）的情况下，会T。 我们这时候就得请出bitset。 bitset的食用方法（借用胡小兔dalao的博客） 使用bitset后，我们计算一个点能到达其他的点的复杂度一下子降为了$O(n/32)$ 总复杂度为$O(n^2/32)$ 然后就可以过啦。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Luogu P2341 [HAOI2006]受欢迎的牛//June,5th,2018//缩点+（完全没必要的）bitset#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;bitset&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=10000+100;vector &lt;int&gt; e[N],e2[N];int n,m,belong[N],nd_tot,dfn[N],mcount,low[N],cnt[N];bool InStack[N];stack &lt;int&gt; s;bitset &lt;N&gt; arrival[N]; void Tarjan(int now)&#123; InStack[now]=true; s.push(now); dfn[now]=low[now]=++mcount; for(int i=0;i&lt;int(e[now].size());i++) if(dfn[e[now][i]]==0) &#123; Tarjan(e[now][i]); low[now]=min(low[now],low[e[now][i]]); &#125; else if(InStack[e[now][i]]==true) low[now]=min(low[now],low[e[now][i]]); if(low[now]==dfn[now]) &#123; nd_tot++; while(s.empty()==false) &#123; int temp=s.top(); s.pop(); InStack[temp]=false; belong[temp]=nd_tot; cnt[nd_tot]++; if(temp==now) break; &#125; arrival[nd_tot][nd_tot]=true; &#125;&#125;bool vis[N];int ans=0;void dfs(int now)&#123; vis[now]=true; for(int i=0;i&lt;int(e2[now].size());i++) &#123; if(vis[e2[now][i]]==false) dfs(e2[now][i]); arrival[now]=arrival[e2[now][i]]; &#125; if(int(arrival[now].count())==nd_tot) ans+=cnt[now];&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) e2[i].reserve(4), e[i].reserve(4); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); e[t].push_back(s); &#125; for(int i=1;i&lt;=n;i++) if(dfn[i]==0) Tarjan(i); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;int(e[i].size());j++) if(belong[i]!=belong[e[i][j]]) e2[belong[i]].push_back(belong[e[i][j]]); for(int i=1;i&lt;=nd_tot;i++) if(vis[i]==false) dfs(i); printf(&quot;%d&quot;,ans); return 0;&#125;//正解（C++）","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"缩点/强连通分量","slug":"缩点-强连通分量","permalink":"http://www.goldenpotato.cn/categories/%E7%BC%A9%E7%82%B9-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P1345] [USACO5.4]奶牛的电信Telecowmunication","slug":"luogu-p1345-usaco5-4奶牛的电信telecowmunication","date":"2019-02-15T15:48:11.000Z","updated":"2019-02-15T15:48:11.000Z","comments":true,"path":"2019/02/15/luogu-p1345-usaco5-4奶牛的电信telecowmunication/","permalink":"http://www.goldenpotato.cn/2019/02/15/luogu-p1345-usaco5-4%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1telecowmunication/","excerpt":"","text":"题面 传送门:洛谷 Solution 这道题,需要一个小技巧了解决。 我相信很多像我这样接蒟蒻，看到这道题，不禁兴奋起来：“这道题是裸的割边，我会做！！！” 然后兴冲冲的打了个DINIC，交一发，80分。 所以说我们有时候还是太naive。 重新读题，会发现这题割的不是边，是点。这样还能80分，数据真水 所以说，我们需要一个割边转割点的小技巧。 我们可以考虑“拆点”，即把一个点拆成两个点，中间连一条边权为1的边。 前一个点作为“入点”，别的点连边连入这里。 后一个点作为“出点”，出去的边从这里出去。 这样，只要我们切断中间那条边，就可以等效于除去这个点 如图： 红色的边边权为1，黑色的边边权为inf。 原点和汇点的内部边权为inf，因为显然这两个点不能删除。 题面给的边删除没意义（因为我们要删点），所以也设为inf(事实上设为1也没问题，因为删除这条边的权值可以理解为删除了一个点) 至于怎么算割边，可以证明割边在数值上等于最大流（本蒟蒻不会证） 至于怎么求最大流…可以参考这个博客 最后记得双倍空间 然后就OjbK了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Luogu P1345 [USACO5.4]奶牛的电信Telecowmunication//June,3rd,2018//割边转割点#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1; c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=200+10;const int inf=0x3f3f3f3f;struct road&#123; int to,w,rev; road (int A,int B,int C) &#123; to=A,w=B,rev=C; &#125;&#125;;vector &lt;road&gt; e[N];int n,m,c1,c2,depth[N];queue &lt;int&gt; dl;bool bfs()&#123; memset(depth,0,sizeof depth); depth[c1]=1; dl.push(c1); while(dl.empty()==false) &#123; int now=dl.front(); dl.pop(); for(int i=0;i&lt;int(e[now].size());i++) if(e[now][i].w&gt;0 and depth[e[now][i].to]==0) &#123; depth[e[now][i].to]=depth[now]+1; dl.push(e[now][i].to); &#125; &#125; if(depth[c2]==0) return false; return true;&#125;int dfs(int now,int f)&#123; if(now==c2) return f; int ans=0; for(int i=0;i&lt;int(e[now].size());i++) if(e[now][i].w&gt;0 and depth[e[now][i].to]==depth[now]+1) &#123; int temp=dfs(e[now][i].to,min(f,e[now][i].w)); e[now][i].w-=temp; e[e[now][i].to][e[now][i].rev].w+=temp; f-=temp,ans+=temp; if(f==0) break; &#125; return ans;&#125;int Dinic()&#123; int ans=0; while(bfs()==true) ans+=dfs(c1,inf); return ans;&#125;inline void AddLine(int s,int t,int w)&#123; e[s].push_back(road(t,w,e[t].size())); e[t].push_back(road(s,0,e[s].size()-1));&#125;int main()&#123; n=read(),m=read(),c1=read(),c2=read(); for(int i=1;i&lt;=n;i++) e[i].reserve(8); for(int i=1;i&lt;=n;i++) if(i==c1 or i==c2) AddLine(i,i+n,inf); else AddLine(i,i+n,1); for(int i=1;i&lt;=m;i++) &#123; int s=read(),t=read(); AddLine(s+n,t,inf); AddLine(t+n,s,inf); &#125; printf(&quot;%d&quot;,Dinic()); return 0;&#125;//正解（C++）","categories":[{"name":"最小割","slug":"最小割","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"网络流","slug":"网络流","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[Luogu P1119] 灾后重建","slug":"luogu-p1119-灾后重建","date":"2019-02-15T15:42:30.000Z","updated":"2019-02-15T15:42:30.000Z","comments":true,"path":"2019/02/15/luogu-p1119-灾后重建/","permalink":"http://www.goldenpotato.cn/2019/02/15/luogu-p1119-%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/","excerpt":"","text":"题面 传送门:洛谷 Solution 这题的思想很巧妙. 首先,我们可以考虑一下最暴力的做法,对每个时刻的所有点都求一遍单元最短路 因为最多只有200个时刻,时间复杂度为$O(n^3log(n+m)))$ (堆优化的迪杰斯特拉) 显然对于$n=200$,并过不了 我们可有进一步分析 这一题,我们堆优化的迪杰斯特拉慢在每加入一个点,我们每一次都得对全图彻彻底底做一轮松弛 那换个角度考虑,如果我只松弛经过新加入的点的点对呢? 没错,就得用Floyd了. 因为Floyd本质就是一个DP,给了我们极大的魔改的空间 考虑到Floyd最外层循环就是枚举加入的点,我们就可以只枚举里面那两层枚举点对的循环. 也就是说我们只用考虑它有可能松弛到的点. 当然,在此之前,我们得先把这个点有关的边先连回去 然后先用两层循环(枚举中转点和起始点)来松弛终点为加入点的路径 接下来用刚刚说的两层循环来松弛经过新加入点路径就好 时间复杂度$O(n^3)$ 然后就OjbK了 具体请看代码 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Luogu P1119 灾后重建//May,28th,2018//巧妙的floyed松弛#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=200+10;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;int n,m,T[N],dis[N][N],e[N][N];int main()&#123; n=read(),m=read(); memset(T,0x3f,sizeof T); memset(dis,0x3f,sizeof dis); memset(e,0x3f,sizeof e); for(int i=0;i&lt;n;i++) T[i]=read(); for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(),temp=read(); e[a][b]=e[b][a]=temp; &#125; for(int i=0;i&lt;n;i++) e[i][i]=dis[i][i]=0; int Q=read(),to=0; for(int i=1;i&lt;=Q;i++) &#123; int x=read(),y=read(),t=read(); while(T[to]&lt;=t) &#123; for(int j=0;T[j]&lt;=t;j++) dis[to][j]=dis[j][to]=min(dis[to][j],e[to][j]); for(int j=0;T[j]&lt;=t;j++) for(int k=0;T[k]&lt;=t;k++) dis[to][k]=dis[k][to]=min(dis[k][to],dis[k][j]+dis[j][to]); for(int j=0;T[j]&lt;=t;j++) for(int k=0;T[k]&lt;=t;k++) dis[j][k]=min(dis[j][k],dis[j][to]+dis[to][k]); to++; &#125; if(dis[x][y]==0x3f3f3f3f) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,dis[x][y]); &#125; return 0;&#125;//正解(c++)","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路径","slug":"最短路径","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[{"name":"floyd","slug":"floyd","permalink":"http://www.goldenpotato.cn/tags/floyd/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[P2114] [NOI2014]起床困难综合症","slug":"p2114-noi2014起床困难综合症-位运算","date":"2019-02-15T15:37:46.000Z","updated":"2019-02-15T15:37:46.000Z","comments":true,"path":"2019/02/15/p2114-noi2014起床困难综合症-位运算/","permalink":"http://www.goldenpotato.cn/2019/02/15/p2114-noi2014%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87-%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"题面 传送门:洛谷 Solution 一道很有意思的位运算题. 要做这一题,我们首先得了解一个很重要的特点 位运算过程中每一位都不会进位 有了这个特点,我们可以考虑一个很妙的做法 我们可以把每一扇门的那个数转为2进制 就可以在$O(n)$的时间内找到这一位以1或0为初始数,过完所有门后的这位数的结果 显然,结果为1是对答案有贡献的 然后,我们从后往前,一位一位枚举看一下初始值是填1还是填0 然后就OjbK了 时间复杂度$O(logm\\cdot n)$ Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Luogu P2114 [NOI2014]起床困难综合症//May,26th,2018//位运算拆分法#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100000+1000;const int LEN=35;struct OP&#123; int a[LEN],type;&#125;op[N];long long n,m;int Count(int x,int p)&#123; for(int i=1;i&lt;=n;i++) &#123; if(op[i].type==1) x=x &amp; op[i].a[p]; else if(op[i].type==2) x=x op[i].a[p]; else x=x ^ op[i].a[p]; &#125; return x;&#125;int main()&#123; n=read(),m=read(); char temp[5]; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%s&quot;,temp+1); if(temp[1]==&#x27;A&#x27;) op[i].type=1; else if(temp[1]==&#x27;O&#x27;) op[i].type=2; else op[i].type=3; int t_num=read(); for(int j=0;t_num!=0;j++) &#123; op[i].a[j]=t_num%2; t_num/=2; &#125; &#125; long long used=0,ans=0; for(int i=0;i&lt;=30;i++) &#123; int temp=Count(0,i); if(temp==1) &#123; ans+=(1&lt;&lt;i); continue; &#125; temp=Count(1,i); if(temp==1 and used+(1&lt;&lt;i) &lt;=m) &#123; ans+=(1&lt;&lt;i); used+=(1&lt;&lt;i); &#125; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"位运算","permalink":"http://www.goldenpotato.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://www.goldenpotato.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"妙题","slug":"妙题","permalink":"http://www.goldenpotato.cn/tags/%E5%A6%99%E9%A2%98/"}]},{"title":"[Luogu P1462] 通往奥格瑞玛的道路","slug":"luogu-p1462-通往奥格瑞玛的道路-二分答案最短路径","date":"2019-02-14T08:17:51.000Z","updated":"2019-02-14T08:17:51.000Z","comments":true,"path":"2019/02/14/luogu-p1462-通往奥格瑞玛的道路-二分答案最短路径/","permalink":"http://www.goldenpotato.cn/2019/02/14/luogu-p1462-%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题面 传送门:https://www.luogu.org/problemnew/show/P1462 Solution 这道题如果去除掉经过城市的收费.那么就是裸的最短路 但是题目要求经过城市中最多的一次性收费的最小值,也就是说让经过的最大值尽可能小 那我们可以考虑二分这个最大值 一切收费大于我们二分的值的城市统统不走 在最短路那里改一下就好了 然后就OjbK了 时间复杂度 $O(n*logn*logb)$ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Luogu P1462 通往奥格瑞玛的道路//May,27th,2018//最短路+二分答案#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=10000+100;const int V_MAX=1000000000;struct road&#123; int to,dis; friend bool operator &lt; (road A,road B) &#123; return A.dis &gt; B.dis; &#125;&#125;;vector &lt;road&gt; e[N]; priority_queue &lt;road,vector&lt;road&gt; &gt; dl;int dis[N],vis[N],n,m,b,v[N];void dj(int lim)&#123; while(dl.empty()==false) dl.pop(); memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); if(v[1]&gt;lim) return; road now; now.to=1,now.dis=0,dis[1]=0; dl.push(now); while(dl.empty()==false) &#123; now=dl.top(); dl.pop(); if(vis[now.to]==true) continue; vis[now.to]=true; for(int i=0;i&lt;int(e[now.to].size());i++) if(dis[e[now.to][i].to] &gt; now.dis+e[now.to][i].dis and v[e[now.to][i].to]&lt;=lim) &#123; dis[e[now.to][i].to]=now.dis+e[now.to][i].dis; road temp; temp.to=e[now.to][i].to,temp.dis=dis[e[now.to][i].to]; dl.push(temp); &#125; &#125;&#125;int main()&#123; n=read(),m=read(),b=read(); for(int i=1;i&lt;=n;i++) &#123; e[i].reserve(4); v[i]=read(); &#125; for(int i=1;i&lt;=m;i++) &#123; int a=read(),b=read(),c=read(); road temp; temp.dis=c,temp.to=b; e[a].push_back(temp); temp.to=a; e[b].push_back(temp); &#125; int L=0,R=V_MAX,ans=0x3f3f3f3f; while(L&lt;=R) &#123; int mid=(L+R)/2; dj(mid); if(dis[n]&lt;=b) &#123; ans=min(ans,mid); R=mid-1; &#125; else L=mid+1; &#125; if(ans!=0x3f3f3f3f) printf(&quot;%d&quot;,ans); else printf(&quot;AFK&quot;); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"二分/二分答案","slug":"二分-二分答案","permalink":"http://www.goldenpotato.cn/categories/%E4%BA%8C%E5%88%86-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"最短路径","slug":"最短路径","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"tags":[{"name":"二分/二分答案","slug":"二分-二分答案","permalink":"http://www.goldenpotato.cn/tags/%E4%BA%8C%E5%88%86-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"最短路","slug":"最短路","permalink":"http://www.goldenpotato.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"[Luogu P4147] 玉蟾宫","slug":"luogu-p4147-玉蟾宫","date":"2019-02-14T07:50:24.000Z","updated":"2019-02-14T07:50:24.000Z","comments":true,"path":"2019/02/14/luogu-p4147-玉蟾宫/","permalink":"http://www.goldenpotato.cn/2019/02/14/luogu-p4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/","excerpt":"","text":"题面 传送门:洛谷 Solution 裸的求极大子矩阵 感谢wzj dalao的教学 首先,有一个很显然但很重要的结论,那就是求极大子矩阵肯定要贴着边或一个障碍点,否则就会浪费 根据这个定理,我们可以考虑一种做法 我们可以枚举每一个可放置的点 我们可以很轻松的得知它与它左边的障碍点(或边界)的距离,也可以得知它上面与下面能扩展到哪里(即无障碍点最多能到哪里) 那这个点能扩出的长方形的最大面积就是它左边的上面与下面能扩展出来的距离的最小值*它到左边障碍点的距离 然后取一个最大的面积就好 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Luogu P4147 玉蟾宫//May,9th,2018//悬线法旋转90°求极大子矩阵#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=1000+10;const int inf=0x3f3f3f3f;int up[N][N],down[N][N],a[N][N],n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); char c[2]; memset(a,0x80,sizeof a); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; scanf(&quot;%s&quot;,c+1); if(c[1]==&#x27;F&#x27;) a[i][j]=0; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(a[i][j]==0 and a[i-1][j]==0) up[i][j]=up[i-1][j]+1; for(int i=n;i&gt;=1;i--) for(int j=1;j&lt;=m;j++) if(a[i][j]==0 and a[i+1][j]==0) down[i][j]=down[i+1][j]+1; int ans=0,u=inf,d=inf,w=0; for(int i=1;i&lt;=n;i++) &#123; u=d=inf; w=0; for(int j=1;j&lt;=m;j++) if(a[i][j]!=0) &#123; u=d=inf; w=0; &#125; else &#123; u=min(u,up[i][j]); d=min(d,down[i][j]); ans=max(ans,(++w)*(u+d+1)); &#125; &#125; printf(&quot;%d&quot;,ans*3); return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"网格DP","slug":"网格DP","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E6%A0%BCDP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[Luogu P2278] [HNOI2003]操作系统","slug":"luogu-p2278-hnoi2003操作系统","date":"2019-02-12T15:57:02.000Z","updated":"2019-02-12T15:57:02.000Z","comments":true,"path":"2019/02/12/luogu-p2278-hnoi2003操作系统/","permalink":"http://www.goldenpotato.cn/2019/02/12/luogu-p2278-hnoi2003%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"题面 传送门:洛咕 Solutiton 挺简单的一道模拟题,拿堆模拟一下题目意思就好 堆中有两个关键字,分别是优先级和到达时间 还要维护一下每个任务剩余时间(还有多久完成) 因为堆不能直接改.得在堆里记录编号然后映射出来 这里总结一下要注意的细节: 1.在下一个任务到达之前,尽可能把CPU内的任务完成了 2.注意读入 3.注意注释文件读写233(我因为这破事爆零一次) 4.没了 好像不需要记录到达时间,编号即为到达时间先后 但懒得改了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//Luogu P2278 [HNOI2003]操作系统//May,4th,2018//堆+模拟#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const int N=1000000;int t[N];struct op&#123; int a,no,at; friend bool operator &lt; (op A,op B) &#123; if(A.a==B.a) return A.at &gt; B.at; return A.a &lt; B.a; &#125;&#125;;priority_queue &lt;op,vector&lt;op&gt; &gt; d;int main()&#123; //freopen(&quot;system.in&quot;,&quot;r&quot;,stdin); int no,at,T,a,t_now=0; while(scanf(&quot;%d%d%d%d&quot;,&amp;no,&amp;at,&amp;T,&amp;a)==4) &#123; while(d.empty()==false) &#123; op now=d.top(); if(t[now.no]&lt;=at-t_now) &#123; d.pop(); t_now+=t[now.no]; printf(&quot;%d %d\\n&quot;,now.no,t_now); &#125; else &#123; t[now.no]-=at-t_now; break; &#125; &#125; op temp; temp.no=no,temp.a=a,temp.at=at,t[no]=T; d.push(temp); t_now=at; &#125; while(d.empty()==false) &#123; op now=d.top(); d.pop(); t_now+=t[now.no]; printf(&quot;%d %d\\n&quot;,now.no,t_now); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆","slug":"堆","permalink":"http://www.goldenpotato.cn/categories/%E5%A0%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆","slug":"堆","permalink":"http://www.goldenpotato.cn/tags/%E5%A0%86/"},{"name":"模拟","slug":"模拟","permalink":"http://www.goldenpotato.cn/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"[Luogu P1006]传纸条","slug":"luogu-p1006传纸条","date":"2019-02-12T15:52:12.000Z","updated":"2019-02-12T15:52:12.000Z","comments":true,"path":"2019/02/12/luogu-p1006传纸条/","permalink":"http://www.goldenpotato.cn/2019/02/12/luogu-p1006%E4%BC%A0%E7%BA%B8%E6%9D%A1/","excerpt":"","text":"题面 传送门:洛咕 Solution 挺显然但需要一定理解的网络(应该是那么叫吧)DP 首先有一个显然但重要的结论要发现:从左上走到右下再从右下走回左上=从左上走两次到右下 那么接下来可以考虑: 设f[i][j][k][l]为第一次走到了(i,j)第二次走到了(k,l) 在路径不交错为前提下的能取到的最大友好值 转移方程也挺好写的 考虑这种情况能从哪里转移过来就好(i,j)可以从(i-1,j)或(i,j-1)转移过来,(k,l)可以从(k-1,l)或(k-1,l-1)转移过来 排列组合一下,总共4种可能性,取个最大值再加上a[i][j]和a[k][l]就好 当然(i==k and j==l) 即两个点重合的情况直接continue,因为f 的意义是之前的不重合,当前的也不能重合 预处理整个f设为0就好 时间复杂度O(n^4) n=50,显然能过 接下来我们可以考虑一个优化 因为我们两次从左上到右下是一起走的 就有这么一个推论: i+j = k+l (画个图就好,挺好发现的) 既然这两个相等,也就意味着我们可以通过总和与i,k推算出j,l 然后我们的方程就可以优化成这样的: f[i][j][k]的意思为:走了i步,第一次走到了第j行,第二次走到了第k行 它们的橫坐标分别为:i-j+2,i-k+2 转移同理 这样,时间复杂度就可以优化为O(n^3),相较之前的可以称为巨大的飞跃 然后就OjbK了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142//Luogu P1006 传纸条//May,4th,2018//网格DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=50+5;int f[2*N][N][N],a[N][N],n,m;int main()&#123; m=read(),n=read(); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) a[i][j]=read(); int MAX=n+m; for(int i=1;i&lt;=MAX;i++) for(int j=1;j&lt;=m;j++) for(int k=1;k&lt;=m;k++) &#123; int X1=i-j+2,Y1=j,X2=i-k+2,Y2=k; if((X1==X2 and Y1==Y2)==false and X1&gt;0 and X2&gt;0 and X1&lt;=n and X2&lt;=n) &#123; f[i][j][k]=max(f[i][j][k],f[i-1][j][k]); f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k]); f[i][j][k]=max(f[i][j][k],f[i-1][j][k-1]); f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-1]); f[i][j][k]+=a[j][X1]+a[k][X2]; &#125; &#125; printf(&quot;%d&quot;,max(f[m+n-3][m][m-1],f[m+n-3][m-1][m])); return 0;&#125; 后记 当时想为什么不会交叉的时候考虑了挺久的,这种类型的网格DP还是得多学习一个,我啊,太naive了 我太弱了","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"网格DP","slug":"网格DP","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E6%A0%BCDP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"}]},{"title":"[LuoguP1005]矩阵取数游戏","slug":"luogup1005矩阵取数游戏","date":"2019-02-12T12:07:20.000Z","updated":"2019-02-12T12:07:20.000Z","comments":true,"path":"2019/02/12/luogup1005矩阵取数游戏/","permalink":"http://www.goldenpotato.cn/2019/02/12/luogup1005%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/","excerpt":"","text":"题面 传送门:https://www.luogu.org/problemnew/show/P1005 Solution 我们可以先考虑贪心 我们每一次都选左右两边尽可能小的数,方便大的放在后面 听起来挺OK的 实则并不OK 反例: 3 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 如果贪心的话,我们会优先把右边那一串2先选了,再去选3和1 但是正确答案显然是先把3和1选了,再去选那一串2 . 既然贪心不成,我们可以考虑一下DP 然后我们考虑这样一个状态: f[i][j][k] 表示第i时刻,第j行,左边选到了第k列 因为我们知道了当前时刻和左边选到的列数,右边选到的列数也可以推算出来: m-i+k-1 然后就可以写出来一个比较显然的转移方程: $f[i][j][k]=max(f[i-1][j][k-1]+2^i_num[j][k-1],f[i-1][j][k]+2^i_num[j][m-i+k]) $ 也就是第i时刻是选最左边的还是选右边的 . 这样子我们就可以得到 100分 60分 为什么会变成这样的呢? 原因很简单,我们仔细看一下数据范围:80 也就是说数据大小至少会有2^80 显然longlong (Int64)是放不下的 这时候,我们就需要伟大的Int128 你当然可以用stl的int128(虽然考试中不能用) 我们这里选用手写一个高精度类 我们只需要高精乘低精,高精加高精,高精比较大小 再加上若干时间的调试高精 然后就OjbK了 #Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Luogu P1005 矩阵取数游戏//DP+高精//Apr,27th,2018#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct Int128&#123; int a[50],len; Int128() &#123; memset(a,0,sizeof a); len=0; &#125; void Insert() &#123; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c))&#123;a[++len]=c-&#x27;0&#x27;;c=getchar();&#125; int tot=len/2; for(int i=len;i&gt;tot;i--)swap(a[i],a[len-i+1]); &#125; void Print() &#123; for(int i=len;i&gt;=1;i--) printf(&quot;%d&quot;,a[i]); &#125; friend Int128 operator * (Int128 a,int b) &#123; Int128 ans=Int128(); ans.len=a.len; for(int i=1;i&lt;=ans.len;i++) &#123; ans.a[i]+=a.a[i]*b; ans.a[i+1]+=ans.a[i]/10; ans.a[i]%=10; if(i==ans.len and ans.a[i+1]!=0) ans.len++; &#125; return ans; &#125; friend Int128 operator + (Int128 a,Int128 b) &#123; Int128 ans=Int128(); ans.len=max(a.len,b.len); for(int i=1;i&lt;=ans.len;i++) &#123; ans.a[i]+=a.a[i]+b.a[i]; ans.a[i+1]+=ans.a[i]/10; ans.a[i]%=10; if(i==ans.len and ans.a[i+1]!=0) ans.len++; &#125; return ans; &#125; friend bool operator &lt; (Int128 a,Int128 b) &#123; if(a.len&lt;b.len) return true; if(a.len&gt;b.len) return false; for(int i=a.len;i&gt;=1;i--) if(a.a[i]&gt;b.a[i]) return false; else if(a.a[i]&lt;b.a[i]) return true; return false; &#125;&#125;;const int N=80+10;Int128 f[2][N][N],POW[N];int a[N][N];int n,m;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); POW[1].len=1,POW[1].a[1]=2; for(int i=2;i&lt;=m;i++) POW[i]=POW[i-1]*2; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=i+1;k++) &#123; if(k&gt;1) f[i%2][j][k]=f[(i-1)%2][j][k-1]+POW[i]*a[j][k-1]; if(m-i+k-1&lt;m) f[i%2][j][k]=max(f[i%2][j][k],f[(i-1)%2][j][k]+POW[i]*a[j][m-i+k]); //f[i%2][j][k].Print(); //cout&lt;&lt;endl; &#125; Int128 ans=Int128(); for(int i=1;i&lt;=n;i++) &#123; Int128 t_ans=Int128(); for(int j=1;j&lt;=m;j++) t_ans=max(t_ans,f[m%2][i][j]); ans=ans+t_ans; &#125; ans.Print(); return 0;&#125;","categories":[{"name":"背包DP","slug":"背包DP","permalink":"http://www.goldenpotato.cn/categories/%E8%83%8C%E5%8C%85DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"高精度","slug":"高精度","permalink":"http://www.goldenpotato.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"GXOI2018 滚粗记","slug":"gxoi2018-滚粗记","date":"2019-02-12T12:00:52.000Z","updated":"2019-02-12T12:00:52.000Z","comments":true,"path":"2019/02/12/gxoi2018-滚粗记/","permalink":"http://www.goldenpotato.cn/2019/02/12/gxoi2018-%E6%BB%9A%E7%B2%97%E8%AE%B0/","excerpt":"","text":"今天考了一次蜜汁省选,滚粗了.想了想,还是写点什么记录一下 8:10 折腾一番总算拿到题目和样例了,一打开dpf,立马感觉到了不对劲. 题目一股浓浓的劣质模拟题的画风,先不说题目质量,单是排版质量都被好一点的模拟赛甩几条街,更不要说正式比赛了 再仔细看了一眼题目名字,一股浓浓的坑爹感扑面而来. T1叫做序列计数什么的,看起来挺高级 T2叫评分,估计又是一道SB模拟题 T3就叫DIV,怕不是高精度除法 T4叫合唱队形???原题???合唱队形为啥会出在省选中??? 8:15 折腾了一番后开始开T1 看到题面后的第一眼:哇,那么高深,怕不是又是一道数论题,不可做不可做 结果仔细一看题面: 求 C i n (n:8~28) … 这不是大水题吗??? 为啥会在省选中出这种蜜汁题目… 也许是送分题,算了 然后花20分钟敲了个质因数分解约分一下就完事了,测了一下样例,没问题,直接下一题 upd:(2018,Sep,14th) 其实质因数分解可以直接递推的，当时真的是too young ，too simple 8:35 开T2 一看题面… 等等… 再等一下… 这题面似曾相识… 这不是神TM的 GXOI 2017 T1原题吗??? 一个字都不带改的 … 一道很水的模拟题 直接根据题目意思算一下分数,排个序就完事了 敲过样例,检查了一遍数据范围,很轻松,20分钟,直接下一题 8:55 那么快就到T3了 看到题面,果然,还真是高精度除法 肛道理,我是第一次写高精度除高精度的题目 拿出草稿纸yy了一下,应该直接模拟竖式计算就好了,然后就开写了 实际上写起来遇上了一点麻烦 写两句话,发现要写高精度比较两个数字大小 又写两句,发现要写高精度乘低精度的乘法 再写两句,发现要写高精度减法 最后发现我基本上把整个高精度模板类全部打了一遍(除了高精度加法) 写完了发现过不了样例… 检查发现神TM高精度减法写错了 过完样例后写暴力上对拍 然后又发现过不了大数据(大概是15位的时候就错了)… 花半天时间检查,结果发现神TM高精度乘法进位时写的(n&gt;10) (这么SB的错误怎么过的几万组的小对拍) 折腾完之后,发现考试时间只有两个小时了… 果然考场上不要去碰没写过的东西,现在看起来正确无比233 11:00 总算到T4了,估计很多dalao早就写完AK了吧,估计只有我这个蒟蒻写到现在才到T4 这题就是合唱队形原题,只是加了一个求方案数 换汤不换药,直接扫一遍算一下就好 花了30分钟拍完dp(可能我手速还是太慢了) 然后写暴力 结果神TM暴力写挂,花了半个小时来调暴力,弄完后已经12:00了 对拍很顺利,没有任何问题 12:00 总算把整份题目都搞完了 花了半个小时检查了一波数据范围,把T3T4对拍了十几万组数据,觉得稳得一匹 12:30分的时候突然发现最后一题有可能爆longlong,要上高精… 但已经没时间去弄那个东西了… 剩下半个小时也就检查一下文件名就过了,没做啥有实际意义的东西… 13:00 考试结束了. 好像大家都普遍认为这次考试连普及组的难度都达不到XD 和LX学长回训练教室收拾了一下东西(顺便颓了一下) 然后就上楼看成绩了 结果,我还没看到自己成绩,教练就直接跟我说:你只考得了200分,怎么回事? ??? 绝望地挤到前面看详细分数,最后一题炸了,只有10分… 怎么可能???我对拍过的啊 突然,身边的wzj对我说:你输出没错吧,题目要求输出出队人数,而不是留在队伍里的人数… 回到自己座位一看… 凉凉 我默认输出留在队伍里的人数了… 而样例数据正好留在队伍里的人数和出队人数一模一样 原本还以为自己联赛成绩正好在前6名,还有希望 结果希望被最后一题的一个小小的文字上的坑给覆灭了… 怎么说呢? 眼瞎看错题的确是自己的锅 知道原因后难受了挺久的 自己辛辛苦苦努力那么久,就被一道SB题目给毁了,还TM毁在输出上 无法接受 明年还有最后一次机会,悲剧不能再次上演 总结一下今年考试 很无语,没有任何意义,考了4道普及组难度都没到的题目,还有两道原题 我不是很懂为什么省选要出这种题目 没有任何意义和区分度 我是高一,就算被坑都还有一次机会 但是听说柳州那边的好几个高二都被这一次SB省选给毁了 他们AK都进不了队,AK的人太多了 我觉得拿别人的前途开这种玩笑实在是太过分了 不是想diss出题者了,心累 就这样,滚回去搞文化了","categories":[{"name":"游记/自闭记/滚粗记","slug":"游记-自闭记-滚粗记","permalink":"http://www.goldenpotato.cn/categories/%E6%B8%B8%E8%AE%B0-%E8%87%AA%E9%97%AD%E8%AE%B0-%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}],"tags":[{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/tags/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}]},{"title":"[BZOJ4818] [SDOI2017] 序列计数","slug":"bzoj4818-sdoi2017-序列计数","date":"2019-02-12T10:46:00.000Z","updated":"2019-02-12T10:46:00.000Z","comments":true,"path":"2019/02/12/bzoj4818-sdoi2017-序列计数/","permalink":"http://www.goldenpotato.cn/2019/02/12/bzoj4818-sdoi2017-%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/","excerpt":"","text":"标签（空格分隔）： 题面: 传送门:BZOJ Solution 看到这道题,我们不妨先考虑一下20分怎么搞 想到暴力,本蒟蒻第一反应就是dfs,想法也很简单: 枚举n个数中的每一个数,枚举完每一种情况都判断一下是否满足要求 复杂度$O(n^m)$ 显然,这样的复杂度一分都得不到,但是可以作为对拍用的暴力程序 既然dfs行不通了,那我们换个想法吧,考虑一下用dp来搞这个问题 设$f[i][j]$表示选到第i个数,前i个数的总和%p为j 转移也很好写 我们枚举一下上一个数字是啥就好 $\\large f[i][j]= \\sum_{k=1}^m f[i-1][((j-k)\\%p+p)\\%p]$ $i:[1,n] j:[0,p-1] $ 注意一下: j-k有可能是负数,所以要用负数取模的方法 初始化 $f[0][0]=1$ (没有数字时,仅有总和为0的情况有一种可行方法) 题目要求的有质数用一个简单的容斥就可以了 我们再做一个没有质数的dp,转移方程跟上面一样,仅需要保证 k 不为质数就行 最后将两者的i为n,j为0的状态相减就是最后答案了. 时间复杂度 $O(n_p_m)$,20分 接下来,我们可以考虑一个很妙的优化 我们发现上面的转移方程 $\\large f[i][j]= \\sum_{k=1}^m f[i-1][((j-k)%p+p)%p]$ $i:[1,n]\\ \\ \\ j:[0,p-1] $ j是从$0-p-1$的,而k是从$1-m$的 这说明了,f[i-1][j]中的某些项是会重复计算到下一个状态的 这样子,我们可以考虑做一个预处理,减少重复计算造成的时间的浪费 考虑这样做: 我们通过一个O(m)的预处理,计算出每一个从[0,p-1]的数可能从多少个[1,m]中的数%p计算而得 用一个tot[k]存储下来,tot[k]的意义为:1~m的数%p为k的有多少个 那么这样子,我们的转移方程可优化成这样子 $\\large f[i][j]= \\sum_{k=0}^{p-1} f[i-1][((j-k)%p+p)%p]*tot[k] $ $i:[1,n]\\ \\ \\ j:[0,p-1]$ 因为 (j-k)%p = j%p - k%p; 所以说,每一个f[i-1][j%p - k%p]被算的次数仅与有多少个 K1%p=K2%p=K3%p=…有关 我们可以设K1%p=K2%p=K3%p=…=y 原式就可以变为f[i][j]=sigma f[i][j%p-y]_tot[y] 而tot[y]已在前面的预处理解决了 这样,时间复杂度就成功的降为了:O(n_p*p) 然而并没有什么卵用,因为出题者并没有设计这一档的分 我们再考虑一个优化 f[i][j]= sigma f[i-1][((j-k)%p+p)%p]*tot[k] k:[0,p-1] i:[1,n] j:[0,p-1] 原转移式是不是有一个特征?对,那就是式子是固定死的,这意味着我们可以用矩阵优化至O(m^3log n) 这种类型的转移矩阵我称为&quot;一层层&quot;的转移,可以考虑这样列转移矩阵 然后就OK啦 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//Luogu P3702 [SDOI2017]序列计数//Apr,11th,2018//矩阵加速DP#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int P=100+10;const int M=20000000+100;const int poi=20170408;struct MAT&#123; int x,y; long long a[P][P]; MAT (int tx,int ty) &#123; x=tx,y=ty; memset(a,0,sizeof a); &#125; friend MAT operator * (MAT A,MAT B) &#123; MAT ans=MAT(B.x,A.y); for(int i=1;i&lt;=ans.y;i++) for(int j=1;j&lt;=ans.x;j++) for(int k=1;k&lt;=A.x;k++) &#123; ans.a[i][j]+=A.a[i][k]*B.a[k][j]; if(ans.a[i][j]&gt;=poi) ans.a[i][j]%=poi; &#125; return ans; &#125;&#125;;MAT FastPow(MAT a,int b)&#123; if(b==1) return a; MAT ans=FastPow(a,b/2); ans=ans*ans; if(b%2==1) ans=ans*a; return ans;&#125;int n,m,p,tot[P];bool IsPrime[M];int prime[M],p_tot;void GetPrime()&#123; memset(IsPrime,1,sizeof IsPrime); IsPrime[0]=IsPrime[1]=0; for(int i=2;i&lt;=m;i++) &#123; if(IsPrime[i]==true) prime[++p_tot]=i; for(int j=1;j&lt;=p_tot and prime[j]*i&lt;=m;j++) &#123; IsPrime[prime[j]*i]=false; if(i%prime[j]==0) break; &#125; &#125;&#125;int main()&#123; n=read(),m=read(),p=read(); for(int i=1;i&lt;=m;i++) tot[i%p]++; GetPrime(); MAT A=MAT(p,p); for(int i=1;i&lt;=p;i++) for(int j=1;j&lt;=p;j++) A.a[i][j]=tot[((i-j)%p+p)%p]; MAT B=MAT(1,p); for(int i=1;i&lt;=p;i++) B.a[i][1]=tot[i-1]; long long ans=(FastPow(A,n-1)*B).a[1][1]; memset(tot,0,sizeof tot); for(int i=1;i&lt;=m;i++) if(IsPrime[i]==false) tot[i%p]++; for(int i=1;i&lt;=p;i++) for(int j=1;j&lt;=p;j++) A.a[i][j]=tot[((i-j)%p+p)%p]; for(int i=1;i&lt;=p;i++) B.a[i][1]=tot[i-1]; ans-=(FastPow(A,n-1)*B).a[1][1]; printf(&quot;%lld&quot;,(ans%poi+poi)%poi); return 0;&#125;","categories":[{"name":"背包DP","slug":"背包DP","permalink":"http://www.goldenpotato.cn/categories/%E8%83%8C%E5%8C%85DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://www.goldenpotato.cn/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"[Luogu P2891/POJ 3281/USACO07OPEN ]吃饭Dining","slug":"luogu-p2891-poj-3281-usaco07open-吃饭dining","date":"2019-02-12T10:19:16.000Z","updated":"2019-02-12T10:19:16.000Z","comments":true,"path":"2019/02/12/luogu-p2891-poj-3281-usaco07open-吃饭dining/","permalink":"http://www.goldenpotato.cn/2019/02/12/luogu-p2891-poj-3281-usaco07open-%E5%90%83%E9%A5%ADdining/","excerpt":"","text":"传送门：洛谷 Solution 网络流 先引用一句真理:网络流最重要的就是建模 今天这道题让我深有体会 首先,观察数据范围,n=100,一般这种100-1000的图论题,很有可能是网络流. 那就直接从网络流的角度入手 考虑这样建模 建模要点如下: 1.建权值为1的边,保证每个食物和水仅用一次 2.没了 对以上的图求一个最大流,那不就是我们想要的最大的匹配数吗? 看起来是不是很OjbK? . 其实不然,这样子一头牛有可能脚踏N条食物和水,但是题目要求一头牛只能吃喝一次 反例如下: 所以说,我们要对一头牛吃的东西做一个限制,保证其只流过1 怎么限制呢? 直接把一头牛拆成两头牛,中间连一条边就OK了嘛 如下图: 接下来就可以考虑如何给点编号了 我的编号方法很直接,很暴力 源点:1 食物: 2 ~ 2+f-1 牛 2+f ~ 2+f+2n -1 水: 2+f+2n ~ 2+f+2n+d 汇点:1000 如下图所示 按照以上方法,每种物品对应的点为: 食物i : 1+i 牛i : 1+f+i 牛i的右边的分点: 1+f+n+i 水i: 1+f+2*n+i 然后dinic直接求一波最大流就可以带走啦 DINIC教程传送门: http://www.cnblogs.com/SYCstudio/p/7260613.html (个人感觉写得很清楚) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//Luogu P2891 [USACO07OPEN]吃饭Dining//Apr,2ed,2018//Dinic求最大流#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=100+10;const int M=N*10;const int inf=0x3f3f3f3f;struct line&#123; int t,rev,w;&#125;;vector &lt;line&gt; e[M];inline void AddLine(int s,int t)&#123; line temp; temp.t=t,temp.rev=e[t].size(),temp.w=1; e[s].push_back(temp); temp.t=s,temp.rev=e[s].size()-1,temp.w=0; e[t].push_back(temp);&#125;int n,f,d;int dl[M],head,tail,depth[M];bool visited[M];bool bfs()&#123; memset(visited,0,sizeof visited); dl[1]=1,depth[1]=1; visited[1]=true; head=1,tail=2; while(head&lt;tail) &#123; int now=dl[head],size=e[now].size(); for(int i=0;i&lt;size;i++) if(visited[e[now][i].t]==false and e[now][i].w&gt;0) &#123; visited[e[now][i].t]=true; dl[tail++]=e[now][i].t; depth[e[now][i].t]=depth[now]+1; &#125; head++; &#125; return visited[1000];&#125;int dfs(int now,int f)&#123; if(now==1000) return f; int size=e[now].size(),ans=0; for(int i=0;i&lt;size;i++) if(depth[e[now][i].t]==depth[now]+1 and e[now][i].w&gt;0) &#123; int t_ans=dfs(e[now][i].t,min(f,e[now][i].w)); e[now][i].w-=t_ans; e[e[now][i].t][e[now][i].rev].w+=t_ans; f-=t_ans,ans+=t_ans; if(f==0) break; &#125; return ans;&#125;int Dinic()&#123; int ans=0; while(bfs()) ans+=dfs(1,inf); return ans;&#125;int main()&#123; n=read(),f=read(),d=read(); for(int i=1;i&lt;=1000;i++) e[i].reserve(16); for(int i=1;i&lt;=f;i++) AddLine(1,1+i); for(int i=1;i&lt;=d;i++) AddLine(1+f+2*n+i,1000); for(int i=1;i&lt;=n;i++) &#123; int F=read(),D=read(),temp; for(int j=1;j&lt;=F;j++) &#123; temp=read(); AddLine(1+temp,1+f+i); &#125; for(int j=1;j&lt;=D;j++) &#123; temp=read(); AddLine(1+f+n+i,1+f+2*n+temp); &#125; &#125; for(int i=1;i&lt;=n;i++) AddLine(1+f+i,1+f+n+i); printf(&quot;%d&quot;,Dinic()); return 0;&#125;C++ 后记 写的时候发现自己真的有点生疏了,这种比较靠记忆的算法还是久不久搞一下来恢复记忆为妙 网络流的时间复杂度真玄学","categories":[{"name":"网络最大流","slug":"网络最大流","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"网络流","slug":"网络流","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Dicnic","slug":"Dicnic","permalink":"http://www.goldenpotato.cn/tags/Dicnic/"},{"name":"OI","slug":"OI","permalink":"http://www.goldenpotato.cn/tags/OI/"},{"name":"网络最大流","slug":"网络最大流","permalink":"http://www.goldenpotato.cn/tags/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"}]},{"title":"[POJ1009]消失之物","slug":"poj1009-消失之物","date":"2019-02-12T08:57:58.000Z","updated":"2019-02-12T08:57:58.000Z","comments":true,"path":"2019/02/12/poj1009-消失之物/","permalink":"http://www.goldenpotato.cn/2019/02/12/poj1009-%E6%B6%88%E5%A4%B1%E4%B9%8B%E7%89%A9/","excerpt":"","text":"题面: 传送门:POJ Solution DP+DP 首先,我们可以很轻松地求出所有物品都要的情况下的选择方案数,一个简单的满背包DP就好 即:$f[i][j]$表示前i个物品装满容量为j的背包的方案数. 转移也很简单 $f[i][j]=f[i-1][j]+f[i-1][j-w[i]] (i:1~n,j:1~m)$ (即选和不选的问题) 初始化 $f[i][0]=1 (i:[0~n])$ (如果背包容量为0,无论如何都有且只有一种方案将其装满) 接下来,考虑用另一个dp来求解在某一物品不放下的方案数 设 $g[i][j]$ 表示第i个物品不放入背包,装满容量为j的背包的方案数 转移为: $g[i][j] = f[n][j] ( j &lt; w[i]) $ (即当背包容量小于所不放物品的大小时,那么其方案数必然为f[n][j],因为f[n][j]中的所有方案肯定取不到第i个) $= f[n][j] - g[i][j-w[i]]$ i:1-nj:1-m 下面那个转移意思即是: 所有的方案总数 减去 包括第i项物品的方案数 因为$g[i][j-w[i]]$中的每一种情况再装入$w[i]$即可达到$g[i][j]$这个状态,而$g[i][j]$的定义是不装入i的方案数,所以说包括第i项物品的方案能且仅能从$g[i][j-w[i]]$转移过来 初始化: $g[i][0]=1$ (i:[0~n])(背包容量为0时方案有且仅有啥都不要) 这样就可以口头AC了 但是,还有一个要注意的小地方 在%P的意义下, $f[n][j]-g[i][j-w[i]]$有可能为负数 负数取模的方法为 : $(x\\ mod\\ P + P)mod\\ P$ 然后就OK啦 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Openjudge 1009:消失之物//Apr,2ed,2018//DP+DP#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long read()&#123; long long x=0,f=1; char c=getchar(); while(!isdigit(c))&#123;if(c==&#x27;-&#x27;) f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=x*10+c-&#x27;0&#x27;;c=getchar();&#125; return x*f;&#125;const int N=2000+100;const int M=2000+100;const int P=10;char f[N][M],g[M];int w[N],n,m;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); f[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) &#123; f[i][j]=f[i-1][j]; if(j-w[i]&gt;=0) f[i][j]+=f[i-1][j-w[i]]; if(f[i][j]&gt;=P) f[i][j]%=P; &#125; g[0]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; if(j&lt;w[i]) printf(&quot;%d&quot;,g[j]=f[n][j]); else printf(&quot;%d&quot;,g[j]=(f[n][j]-g[j-w[i]]+P)%P); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 后记 这种DP+DP的题目还是第一次写,写起来有一点点不熟练 看来我还是需要多学习一个","categories":[{"name":"背包DP","slug":"背包DP","permalink":"http://www.goldenpotato.cn/categories/%E8%83%8C%E5%8C%85DP/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP+DP","slug":"DP-DP","permalink":"http://www.goldenpotato.cn/categories/DP-DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"OI","slug":"OI","permalink":"http://www.goldenpotato.cn/tags/OI/"},{"name":"POJ","slug":"POJ","permalink":"http://www.goldenpotato.cn/tags/POJ/"}]},{"title":"WC2019 自闭记","slug":"wc2019-自闭记","date":"2019-02-11T12:23:00.000Z","updated":"2019-02-11T12:23:00.000Z","comments":true,"path":"2019/02/11/wc2019-自闭记/","permalink":"http://www.goldenpotato.cn/2019/02/11/wc2019-%E8%87%AA%E9%97%AD%E8%AE%B0/","excerpt":"","text":"不咕了 Day 1 2019/1/24 辣么快就到冬令营了，还沉迷于被柿子吊打的状态的菜鸡一时半会还反应不过来。我们学校这次分头去的冬令营，差点上不了车。这次做的动车居然直达广州，强啊。 然鹅还是到太晚，没饭吃了。路上花了15大洋买了个只有黄油味的黄油面包吃。 而且还错过了精彩纷呈的 CC冬令营。错过一个亿 比赛当天将采用传统题+提交答案+交互题配置，种类齐全 exciting! 这个睡眠时间真的充足…我平时十点半连教室都没出，这里居然十点半熄灯。生物钟硬生生向前题前两个小时，然后当然是理所当然的睡不着啦。 Day2 2019/1/25 第一天上课啦！ 然鹅第一课堂：松松松的评测系统剖析… emmmmmmm，迅速地与南二的dalao们达成共识：去第二课堂听生成函数wzj dalao tql 这次我应该不会在第二课堂掉线吧 一个半小时后：我是谁，我在哪，我在听什么，生成函数，啥？ 果然冬眠营还是你冬眠营。 下午是骚话王李建老师的字符串算法。 我本来打算半个小时讲完课件然后跟老师交流的，没想到你们这次人这么多 一年过去了，李建还是李建，真的牛皮。 然后他花了两个小时骚话，5分钟SA，然后我又掉线了。 我是谁，我在那，我在听什么，后缀数组，蛤？. 今天下午只学到了如何当一个合格的OI教练 晚上的试机当然是咕掉啦~ 艹啊，这SB生成函数模板题表面生成函数，实考高精度，卡完FFT的精度卡NTT的常数，卡你马啊 Day3 2019/1/26 第二课堂的内容没啥意思，蒟蒻做出了一个大胆举动：去第一课堂碎觉！ 然后还真的光速掉线了，中间试图重连几次都失败了. 我是谁，我在哪，数学，蛤？ 下午是IOI趣题神题选讲 前几题倒是挺有趣的，但是到后面我还是掉线了（咋辣么神啊） 我是谁，我在哪，IOI，蛤？ 晚上是神仙营员讨论。 蛤？析合树，啥？. lbc:NOIp2019：安排上了 光速自闭，不说了，太惨了。 Day 4 早上想来想去还是去第一课堂碎觉，第二课堂的FFT太基础了，实在提不起兴趣。 模拟费用流…应该听得懂(吧 听得懂个鬼！为啥还有模拟费用流这种操作啊。自闭了 下午跑去听分块和莫队了。（听说有云南省选（大雾）,exciting!） 诶，还别说，这节课是整个冬令营我唯一全程在线的一节课。 老师好棒啊ヾ(◍°∇°◍)ﾉﾞ非常照顾我等蒟蒻的感受，点赞~ 晚上是试机赛。 刚道理，这是本菜鸡第一次写提交答案题。 一看题面…emmmmmm，鬼畜题，不可做。 然后猛然发现我可以直接生成一个答案，丢给交互库检测不就好了嘛w。 然后就敲敲敲敲… 然鹅我的假爬山只能爬出30多分，广二xfz dalao的爬山爬出了50多分，tql。难道我学了假爬山? Day 5 今天只有第一课堂了自闭不可避. 嗯好了，果然自闭了，告辞。 群里的老哥都好fake啊，嘴巴上说着自闭，身体上却听得很诚实。 晚上的神仙打架咕掉了，不可听，不可听.jpg 结果lbc说讲指令集完了，血亏一个亿, 题答题：安排上了 结果lbc半个小时后回来了，听他说后面神仙打架，自闭了。还好没去233。 总算调出来DAY1的生成函数鬼畜题了，不容易。 明天就要考试了，要加油呢~ Day 6 Part1 考试。 考场外等半天进不去，不愧是咕咕f。群里都有老哥开始商量DAY2了233 8:13 总算开考啦~ 我怎么进不去桌面啊喂，我不愧是星际玩家，密码都能看错。然后我连续打了5次密码，一直都进不去，举手提问老师后猛然发现选错账号了。我是SB 8:22 折腾了一番总算进入桌面啦~ 打开主文件夹：诶？这里有个选手须知，算了，我们开题面再去开那个须知吧(flag*1 然后我开完题面之后就忘记有选手须知了。我是金鱼吗 这种鬼畜比赛，一般来说题答题和交互题都是毒瘤题，传统题一定最好骗分，OK，先把传统的暴力打了。 5min later：蛤？这啥题啊，我咋连题都读不懂。 然后前后反复读了5遍题，总算读懂了$op=0$的题目大意。 那这个显然很好搞嘛…我直接找有多少个连通块不就搞定啦？ 然后当然是写写写写写啦。 调试非常顺利，一遍过大样例，稳。 9:00 折腾完第一题的大暴力，我决定先往后看一下，神仙比赛，靠苟，不靠肛。 好了，我读不懂T2。好了，我读懂了T3。 根据上年冬令营的经验，交互题会送很多分。然后我迅速地与自己达成了共识：先去骗T3的分。 emmmm，所以说，这个在相等的情况下以某种方式返回时啥意思…待我看看grader… 啊…smg…怎么是个随机函数。。。。 那咋搞啊… 30 min later woc，n=5！！！我又漏看数据范围了。那我们应该可以这样做：我们暴力枚举所有的情况，然后对于不同的数去暴力询问一下，看一下是否满足我们目前了解的信息，如果满足的话应该就是解了。 然后冷静查错了5min，emmm，应该没问题。 然后就是写写写写写啦~ 还别说，交互题难写得要命，被gdb惯坏的我已经不会输出变量来调试了… 东错一个，西锅一个，磕磕绊绊60min后总算过了样例。 然后自己手造了5组数据，一测，wa。 检查后猛然发现，我这个做法有一定的随机性，如果我询问的两个数原本正好相等，那么返回的值是不稳定的。对于这种问题，解决的方法只有一个：多问几遍。 然鹅问太多会导致询问次数超标。经过我玄学调参后发现，问3次刚刚好。 然鹅这破写法还是有一定的概率wa，根据我手玩评测的情况表明，我这种搞法的正确率只有$\\frac{19}{20}$。一看时间：woc，已经11点了，这不星啊，得赶紧开T2。然后这题就放那了，一切随缘。 11:10 我得快点读懂第二题啊… 第一遍读题：emmmm，我好像看懂了题目大概要问什么，问题是这个checker的使用说明啥意思啊，啥叫“连边关系描述文件”啊。 第二遍读题：emmmm，我没有理解错题意啊，问题是我还是不知道什么叫连边关系描述文件啊。 第三遍读题：emmmm，好像连边关系描述文件指的就是我们的computer.in，那么问题来了：后面那个数据文件又是啥意思啊。 第四遍读题：emmmm，还是不懂。 好吧，我举手问老师吧。老师：自己好好看题。 这就很shit了。 第五遍读题：emmmm，难道说这个输入文件指的是我们要从终端输入的数据？待我测试一发：段错误 emmmm，我难道写爆了什么地方？ 一顿修改参数后：段错误*15 玩你马啊… 第六-十遍读题：我到底漏了什么啊啊啊啊啊，为啥不能“编译”啊。 放弃治疗，举手提问。老师：你看了选手须知吗？我：蛤？选手提醒里不是只有对T3的提醒吗？老师：我说的是主目录下的那个。我：蛤？主目录还有选手须知？切出去一看：woc，我刚刚好像忘记看了。emmmmmm，我是SB。 然后选手目录下大大的写着这句话： 若提示段错误，可尝试输入指令xxxx xxx 来处理。 艹啊！ 然后我总算能编译运行了，太棒了 结果这一顿折腾下来，时间已经不知不觉地过去了一个小时，现在距离考试结束只有一个小时的时间了。 12:10 不行，我不能放弃，放弃了回家要被打死。 赶紧看数据点： subtask1：输入输出。…好SB的问题啊，还好我没有死磕T3，要不然我就凉了(事实上，我已经在T3上浪费了2个半小时 光速水完subtask1，开subtask2： woc?两个int计算fib的第k项？ 这能搞？ 那一定是一些玄学数学方法把K强行融入到哪两个int里面去再一顿操作来解决吧。 emmmm，想了半个钟，不会，告辞。 subtask3：从1输入n个数，在第n的节点按原顺序输出。 emmmm,我不直接找个最短路不就完事了吗？ 爆写迪杰斯特拉，15min敲完，15min码完，一发过样例，稳。 12:50 现在只剩半个钟了，前面各种失误浪费了成吨的时间，现在好像已经打了99分了，理论上Cu稳了，我是应该检查一波还是继续rushT2冲Ag呢？ 既然T1过了大样例，T3也过了手测，那我还是继续rushT2吧。 T2的fib我应该是颓不出来了，但是后面那两个…emmmmmm 对于第一个，我们好像可以暴力以每个点做到50~100的任意最短路，然后再打个暴力程序来输出代码？ 好像可行。 不幸的是，我并不能码完。 最后检查了一下文件名和输入输出含恨离场。 中午当然是回宿舍颓啊。 wzj dalao这次看起来考得不是很好鸭…xfz dalao考得好像也一般，fxh忘记把文件丢到文件夹里面去了，tcl。好像我们这帮人考得都挺炸的？ 喜闻乐见：咕咕f又咕咕咕了。 咕到4点总算出成绩了：怀着砰砰直跳的心打开dpf：T1：28：没问题，意料之中；T2：40：没问题，意料之中；T3：爆零？woc，$\\frac{1}{20}$的概率我都能撞到？然后听说群里的老哥说评测时的grader不随机…fxxk,那我那两个半小时好好去骗T2分不美滋滋吗？我写T3干什么鬼啊。 讲评全程自闭：什么鬼神仙题啊，T1T3鬼畜数学，T2中的第三第四个点是鬼畜网络流。告辞.jpg Day 6 Part2 文艺汇演当然要专门开来讲啊w。 一开始还以为文艺汇演会咕，失落了好一会：我们准备了半天的歌曲要被咕掉了。 但是在群里dalao们的大力推动下，文艺汇演得以重回WC舞台。在这里再次感谢群里的dalao们。 刚道理，第一次在全国性舞台唱歌，而且我还是弱省最菜的蒟蒻，好紧张鸭。 但是看起来反响还不错？那…太棒了.jpg 接近结尾的时候出了点小插曲，大家都挺不愉快的。感谢LCAdalao的紧急公关救场，让我们得以以《难玩今宵》收场了。 具体汇演视频还请在B站上搜WC2019,记得在《千里追月》那一p发弹幕喔w。 Day 7 社会活动去科技馆好评！ 模拟飞行有高级外设好棒啊，可惜是FSX的简单模式，气动过于魔法 下午是颁奖仪式&amp;闭幕式。 CCF要恰饭，没办法公益 选手教练该干嘛还干嘛 会跟教育部沟通——dzd GX这次有3个Ag，太棒了。%%%%%Maxwei_wzj。 本菜鸡？别提了，太惨了，差点打铁，卡线Cu。 心疼南二另外两位dalao被重测卡掉了T2的第二个点，惨遭-=20。 柳高tql，南三tql。 Day 8 &amp; 总结 Ag是不可能Ag的，这辈子都不可能Ag的。五个小时也不够，脑洞又赶不上毒瘤题，就是靠暴力这种东西，才能勉强维持的了Cu这样子。在冬令营里面的感觉，比家里面颓感觉好多了！在家里面还要被逼学，都没有dalao玩 ，来了冬令营里面个个都是人才。冬令营里的dalao个个都是鸽子，还会嘤嘤嘤，我超喜欢在里面！ 广州二中，我们七月再见！","categories":[{"name":"游记/自闭记/滚粗记","slug":"游记-自闭记-滚粗记","permalink":"http://www.goldenpotato.cn/categories/%E6%B8%B8%E8%AE%B0-%E8%87%AA%E9%97%AD%E8%AE%B0-%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"}],"tags":[{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/tags/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"},{"name":"OI","slug":"OI","permalink":"http://www.goldenpotato.cn/tags/OI/"},{"name":"游记","slug":"游记","permalink":"http://www.goldenpotato.cn/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"一些坑点","slug":"一些坑点","date":"2019-02-11T12:17:14.000Z","updated":"2019-02-11T12:17:14.000Z","comments":true,"path":"2019/02/11/一些坑点/","permalink":"http://www.goldenpotato.cn/2019/02/11/%E4%B8%80%E4%BA%9B%E5%9D%91%E7%82%B9/","excerpt":"","text":"填坑中 $\\color {blue} last update ： Jan,21st,2019$ 通用 $\\color {red} -1.仔细审题*2$ 0.永远要有想法，不要觉得复杂度不对空间就不开够。空间永远开到最大值（或者说是自己不MLE的极限），以免发生复杂度正确但是空间没有开够的惨痛教训（NOI.ac WHZZT 邀请赛R1） 1.在会爆int的题目中，一定要仔细检查是否有会爆int的中间变量写了int。 （from NNEZ_R2_T1） 2.使用-=时，把-=后面的东西用括号括起来，防止可能出现的负负为正等SB错误 (from Luogu P1270) 3.在需要mod一个数的题目中，要检查输出(printf)时有没有做计算,如果有计算，要括起来再mod一次(Luogu P2679) 4.使用迭代器时，不要在if中++或–，以免出现奇奇怪怪的顺序问题。 (Luogu P3626) 5.二分答案/二分时，不要瞎JB对左端点和右端点优化，直接取题面的最大值和最小值就好，防止因端点取错而爆炸（from NNEZ_R2_T3） DP 1.在初始化不是0（0作为极值的情况下），一定要讨论可以取得到的边界条件，否则会听取WA声一片。 (Luogu P1437) 2.一定要仔细检查答案应该取哪个状态。 ([HAOI2008]木棍分割) 数论 1.使用exgcd时，记得检查x，y变量前是否加上了&amp;。 （Luogu P1516） 2.计算lcm时，先除gcd再乘，以防乘爆 （Luogu P4777） 3.线性求欧拉函数和莫比乌斯函数时，要注意初始化phi[1]=1或miu[1]=1 4.写FFT时，记得加上对type的判断，若type=true，则x0=conj(x0); 计算几何 1,求凸包的时候要对x，y都排序，且要去重，在一条直线上也要弹栈（防止全部全在一条直线上的数据）。否则将会在用凸包求其他东西的时候出现奇奇怪怪的问题。 2.旋转卡壳一定要特判n==2的情况。 数据结构 1.并查集中在求需要父亲的地方，请直接调用函数，而不要相信你路径压缩过的fa[x]，直接调用的话有可能因为各种各样奇怪的原因导致你取到的不是最终父亲。(from Luogu P2170) 2.线段树pushdown的时候记得特判叶子节点的情况，否则会RE到飞起 （NOI2015 软件包管理器） 3.圆方树一定要开2倍空间（来存额外的方点） ([BeiJing2013]压力) 4.小心线段树的常数 (NNEZ noip2018R2 T1)","categories":[{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"OI","slug":"OI","permalink":"http://www.goldenpotato.cn/tags/OI/"},{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/tags/%E5%85%B6%E4%BB%96/"},{"name":"坑点","slug":"坑点","permalink":"http://www.goldenpotato.cn/tags/%E5%9D%91%E7%82%B9/"}]},{"title":"世界，您好！","slug":"hello-world-1","date":"2019-02-11T11:50:36.000Z","updated":"2019-02-11T11:50:36.000Z","comments":true,"path":"2019/02/11/hello-world-1/","permalink":"http://www.goldenpotato.cn/2019/02/11/hello-world-1/","excerpt":"","text":"欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://www.goldenpotato.cn/categories/uncategorized/"}],"tags":[]}],"categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://www.goldenpotato.cn/categories/uncategorized/"},{"name":"深度学习","slug":"深度学习","permalink":"http://www.goldenpotato.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"游记/自闭记/滚粗记","slug":"游记-自闭记-滚粗记","permalink":"http://www.goldenpotato.cn/categories/%E6%B8%B8%E8%AE%B0-%E8%87%AA%E9%97%AD%E8%AE%B0-%E6%BB%9A%E7%B2%97%E8%AE%B0/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/categories/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"边双/点双","slug":"边双-点双","permalink":"http://www.goldenpotato.cn/categories/%E8%BE%B9%E5%8F%8C-%E7%82%B9%E5%8F%8C/"},{"name":"圆方树","slug":"圆方树","permalink":"http://www.goldenpotato.cn/categories/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.goldenpotato.cn/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"缩点/强连通分量","slug":"缩点-强连通分量","permalink":"http://www.goldenpotato.cn/categories/%E7%BC%A9%E7%82%B9-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"虚树","slug":"虚树","permalink":"http://www.goldenpotato.cn/categories/%E8%99%9A%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://www.goldenpotato.cn/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"整体二分","slug":"整体二分","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"},{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%BD%A2DP/"},{"name":"状压DP","slug":"状压DP","permalink":"http://www.goldenpotato.cn/categories/%E7%8A%B6%E5%8E%8BDP/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://www.goldenpotato.cn/categories/CDQ%E5%88%86%E6%B2%BB/"},{"name":"并查集","slug":"并查集","permalink":"http://www.goldenpotato.cn/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"主席树","slug":"主席树","permalink":"http://www.goldenpotato.cn/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"分块","slug":"分块","permalink":"http://www.goldenpotato.cn/categories/%E5%88%86%E5%9D%97/"},{"name":"最短路径","slug":"最短路径","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"LCT","slug":"LCT","permalink":"http://www.goldenpotato.cn/categories/LCT/"},{"name":"模拟","slug":"模拟","permalink":"http://www.goldenpotato.cn/categories/%E6%A8%A1%E6%8B%9F/"},{"name":"NNEZ","slug":"NNEZ","permalink":"http://www.goldenpotato.cn/categories/NNEZ/"},{"name":"左偏树","slug":"左偏树","permalink":"http://www.goldenpotato.cn/categories/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"splay","slug":"splay","permalink":"http://www.goldenpotato.cn/categories/splay/"},{"name":"数位DP","slug":"数位DP","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E4%BD%8DDP/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"http://www.goldenpotato.cn/categories/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"倍增","slug":"倍增","permalink":"http://www.goldenpotato.cn/categories/%E5%80%8D%E5%A2%9E/"},{"name":"DAG DP","slug":"DAG-DP","permalink":"http://www.goldenpotato.cn/categories/DAG-DP/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"哈希","slug":"哈希","permalink":"http://www.goldenpotato.cn/categories/%E5%93%88%E5%B8%8C/"},{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/categories/%E6%95%B0%E5%AD%A6/"},{"name":"反演","slug":"反演","permalink":"http://www.goldenpotato.cn/categories/%E5%8F%8D%E6%BC%94/"},{"name":"卷积","slug":"卷积","permalink":"http://www.goldenpotato.cn/categories/%E5%8D%B7%E7%A7%AF/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://www.goldenpotato.cn/categories/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"http://www.goldenpotato.cn/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://www.goldenpotato.cn/categories/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"同余","slug":"同余","permalink":"http://www.goldenpotato.cn/categories/%E5%90%8C%E4%BD%99/"},{"name":"组合数学","slug":"组合数学","permalink":"http://www.goldenpotato.cn/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"容斥","slug":"容斥","permalink":"http://www.goldenpotato.cn/categories/%E5%AE%B9%E6%96%A5/"},{"name":"LUCAS","slug":"LUCAS","permalink":"http://www.goldenpotato.cn/categories/LUCAS/"},{"name":"树套树","slug":"树套树","permalink":"http://www.goldenpotato.cn/categories/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"点分治","slug":"点分治","permalink":"http://www.goldenpotato.cn/categories/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"堆","slug":"堆","permalink":"http://www.goldenpotato.cn/categories/%E5%A0%86/"},{"name":"set","slug":"set","permalink":"http://www.goldenpotato.cn/categories/set/"},{"name":"贪心","slug":"贪心","permalink":"http://www.goldenpotato.cn/categories/%E8%B4%AA%E5%BF%83/"},{"name":"背包DP","slug":"背包DP","permalink":"http://www.goldenpotato.cn/categories/%E8%83%8C%E5%8C%85DP/"},{"name":"最小割","slug":"最小割","permalink":"http://www.goldenpotato.cn/categories/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"网络流","slug":"网络流","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"位运算","slug":"位运算","permalink":"http://www.goldenpotato.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二分/二分答案","slug":"二分-二分答案","permalink":"http://www.goldenpotato.cn/categories/%E4%BA%8C%E5%88%86-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"网格DP","slug":"网格DP","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E6%A0%BCDP/"},{"name":"网络最大流","slug":"网络最大流","permalink":"http://www.goldenpotato.cn/categories/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"DP+DP","slug":"DP-DP","permalink":"http://www.goldenpotato.cn/categories/DP-DP/"}],"tags":[{"name":"hpc","slug":"hpc","permalink":"http://www.goldenpotato.cn/tags/hpc/"},{"name":"HPC","slug":"HPC","permalink":"http://www.goldenpotato.cn/tags/HPC/"},{"name":"生涯纪录","slug":"生涯纪录","permalink":"http://www.goldenpotato.cn/tags/%E7%94%9F%E6%B6%AF%E7%BA%AA%E5%BD%95/"},{"name":"字符串","slug":"字符串","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.goldenpotato.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"图论","slug":"图论","permalink":"http://www.goldenpotato.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DP","slug":"DP","permalink":"http://www.goldenpotato.cn/tags/DP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数学","slug":"数学","permalink":"http://www.goldenpotato.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"颓废","slug":"颓废","permalink":"http://www.goldenpotato.cn/tags/%E9%A2%93%E5%BA%9F/"},{"name":"模拟","slug":"模拟","permalink":"http://www.goldenpotato.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"floyd","slug":"floyd","permalink":"http://www.goldenpotato.cn/tags/floyd/"},{"name":"位运算","slug":"位运算","permalink":"http://www.goldenpotato.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"妙题","slug":"妙题","permalink":"http://www.goldenpotato.cn/tags/%E5%A6%99%E9%A2%98/"},{"name":"二分/二分答案","slug":"二分-二分答案","permalink":"http://www.goldenpotato.cn/tags/%E4%BA%8C%E5%88%86-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"最短路","slug":"最短路","permalink":"http://www.goldenpotato.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"堆","slug":"堆","permalink":"http://www.goldenpotato.cn/tags/%E5%A0%86/"},{"name":"高精度","slug":"高精度","permalink":"http://www.goldenpotato.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://www.goldenpotato.cn/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"Dicnic","slug":"Dicnic","permalink":"http://www.goldenpotato.cn/tags/Dicnic/"},{"name":"OI","slug":"OI","permalink":"http://www.goldenpotato.cn/tags/OI/"},{"name":"网络最大流","slug":"网络最大流","permalink":"http://www.goldenpotato.cn/tags/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"POJ","slug":"POJ","permalink":"http://www.goldenpotato.cn/tags/POJ/"},{"name":"游记","slug":"游记","permalink":"http://www.goldenpotato.cn/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"其他","slug":"其他","permalink":"http://www.goldenpotato.cn/tags/%E5%85%B6%E4%BB%96/"},{"name":"坑点","slug":"坑点","permalink":"http://www.goldenpotato.cn/tags/%E5%9D%91%E7%82%B9/"}]}