<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.4.4" created="2021-03-23 04:51" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>GoldenPotato137的小屋</title>
	<link>https://www.goldenpotato.cn</link>
	<description>蒟蒻XMD的OI博客</description>
	<pubDate>Tue, 23 Mar 2021 04:51:15 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>https://www.goldenpotato.cn</wp:base_site_url>
	<wp:base_blog_url>https://www.goldenpotato.cn</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[GoldenPotato137]]></wp:author_login><wp:author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:author_email><wp:author_display_name><![CDATA[GoldenPotato137]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

				
	
<image>
	<url>https://www.goldenpotato.cn/wp-content/uploads/2019/02/cropped-68985613_p0_master1200-1-32x32.jpg</url>
	<title>GoldenPotato137的小屋</title>
	<link>https://www.goldenpotato.cn</link>
	<width>32</width>
	<height>32</height>
</image> 

		<item>
		<title>世界，您好！</title>
		<link>https://www.goldenpotato.cn/uncategorized/hello-world/</link>
		<pubDate>Mon, 11 Feb 2019 11:50:36 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date><![CDATA[2019-02-11 19:50:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-11 11:50:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hello-world]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[580]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>1</wp:comment_id>
			<wp:comment_author><![CDATA[一位WordPress评论者]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wapuu@wordpress.example]]></wp:comment_author_email>
			<wp:comment_author_url>https://wordpress.org/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-11 19:50:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-11 11:50:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[嗨，这是一条评论。
要开始审核、编辑及删除评论，请访问仪表盘的“评论”页面。
评论者头像来自<a href="https://gravatar.com">Gravatar</a>。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>一些坑点</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e4%b8%80%e4%ba%9b%e5%9d%91%e7%82%b9/</link>
		<pubDate>Mon, 11 Feb 2019 12:17:14 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=12</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>填坑中</strong>
$\color {blue} last update ： Jan,21st,2019$

<hr />

<h1>通用</h1>

$\color {red} -1.仔细审题*2$

0.永远要有想法，不要觉得复杂度不对空间就不开够。空间永远开到最大值（或者说是自己不MLE的极限），以免发生复杂度正确但是空间没有开够的惨痛教训（NOI.ac WHZZT 邀请赛R1）

1.在会爆int的题目中，一定要仔细检查是否有会爆int的中间变量写了int。 （from NNEZ_R2_T1）

2.使用-=时，把-=后面的东西用括号括起来，防止可能出现的负负为正等SB错误 (from Luogu P1270)

3.在需要mod一个数的题目中，要检查输出(printf)时有没有做计算,如果有计算，要括起来再mod一次(Luogu P2679)

4.使用迭代器时，不要在if中++或--，以免出现奇奇怪怪的顺序问题。 (Luogu P3626)

5.二分答案/二分时，不要瞎JB对左端点和右端点优化，直接取题面的最大值和最小值就好，防止因端点取错而爆炸（from NNEZ_R2_T3）

<hr />

<h1>DP</h1>

1.在初始化不是0（0作为极值的情况下），一定要讨论可以取得到的边界条件，否则会听取WA声一片。 (Luogu P1437)

2.一定要仔细检查答案应该取哪个状态。 ([HAOI2008]木棍分割)

<hr />

<h1>数论</h1>

1.使用exgcd时，记得检查x，y变量前是否加上了&amp;。 （Luogu P1516）

2.计算lcm时，先除gcd再乘，以防乘爆 （Luogu P4777）

3.线性求欧拉函数和莫比乌斯函数时，要注意初始化phi[1]=1或miu[1]=1

4.写FFT时，记得加上对type的判断，若type=true，则x0=conj(x0);

<hr />

<h1>计算几何</h1>

1,求凸包的时候要对x，y都排序，且要去重，在一条直线上也要弹栈（防止全部全在一条直线上的数据）。否则将会在用凸包求其他东西的时候出现奇奇怪怪的问题。

2.旋转卡壳一定要特判n==2的情况。

<hr />

<h1>数据结构</h1>

1.并查集中在求需要父亲的地方，请直接调用函数，而不要相信你路径压缩过的fa[x]，直接调用的话有可能因为各种各样奇怪的原因导致你取到的不是最终父亲。(from Luogu P2170)

2.线段树pushdown的时候记得特判叶子节点的情况，否则会RE到飞起 （NOI2015 软件包管理器）

3.圆方树一定要开2倍空间（来存额外的方点） ([BeiJing2013]压力)

4.小心线段树的常数 (NNEZ noip2018R2 T1)]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>12</wp:post_id>
		<wp:post_date><![CDATA[2019-02-11 12:17:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-11 12:17:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e4%ba%9b%e5%9d%91%e7%82%b9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="oi"><![CDATA[OI]]></category>
		<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="post_tag" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="post_tag" nicename="%e5%9d%91%e7%82%b9"><![CDATA[坑点]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[470]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>WC2019 自闭记</title>
		<link>https://www.goldenpotato.cn/%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95/wc2019-%e8%87%aa%e9%97%ad%e8%ae%b0/</link>
		<pubDate>Mon, 11 Feb 2019 12:23:00 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=14</guid>
		<description></description>
		<content:encoded><![CDATA[<del>不咕了</del>

<h2>Day 1</h2>

2019/1/24
辣么快就到冬令营了，还沉迷于<del>被柿子吊打</del>的状态的菜鸡一时半会还反应不过来。我们学校这次分头去的冬令营，<del>差点上不了车</del>。这次做的动车居然直达广州，强啊。

然鹅还是到太晚，没饭吃了。路上花了15大洋买了个<del>只有黄油味</del>的黄油面包吃。

而且还错过了<del>精彩纷呈</del>的 <del>CC</del>冬令营。<del>错过一个亿</del>

<blockquote>
  比赛当天将采用传统题+提交答案+交互题配置，种类齐全
</blockquote>

exciting!

这个睡眠时间真的充足......我平时十点半连教室都没出，这里居然十点半熄灯。<del>生物钟硬生生向前题前两个小时</del>，然后当然是理所当然的睡不着啦。

<hr />

<h2>Day2</h2>

2019/1/25

第一天上课啦！
然鹅第一课堂：松松松的评测系统剖析........
emmmmmmm，迅速地与南二的dalao们达成共识：去第二课堂听生成函数<del>wzj dalao tql</del>
<img src="https://s2.ax1x.com/2019/01/27/kKamy8.png" alt="kKamy8.png" />

<blockquote>
  这次我应该不会在第二课堂掉线吧
</blockquote>

一个半小时后：我是谁，我在哪，我在听什么，生成函数，啥？
<del>果然冬眠营还是你冬眠营。</del>

下午是<del>骚话王</del>李建老师的字符串算法。

<blockquote>
  我本来打算半个小时讲完课件然后跟老师交流的，没想到你们这次人这么多
</blockquote>

一年过去了，李建还是李建，真的牛皮。

然后他花了两个小时骚话，5分钟SA，然后我又掉线了。
<del>我是谁，我在那，我在听什么，后缀数组，蛤？</del>.
<del>今天下午只学到了如何当一个合格的OI教练</del>

晚上的试机当然是咕掉啦~
<del>艹啊</del>，这SB生成函数模板题表面生成函数，实考高精度，卡完FFT的精度卡NTT的常数，<del>卡你马啊</del>

<hr />

<h2>Day3</h2>

2019/1/26
第二课堂的内容没啥意思，蒟蒻做出了一个大胆举动：去第一课堂碎觉！

<del>然后还真的光速掉线了，中间试图重连几次都失败了</del>.
<del>我是谁，我在哪，数学，蛤？</del>

下午是IOI趣题<del>神题</del>选讲
前几题倒是挺有趣的，但是到后面我还是掉线了（咋辣么神啊）
<del>我是谁，我在哪，IOI，蛤？</del>

晚上是神仙营员讨论。
<del>蛤？析合树，啥？</del>. lbc:<del>NOIp2019：安排上了</del>
光速自闭，不说了，太惨了。

<hr />

<h2>Day 4</h2>

早上想来想去还是去第一课堂碎觉，第二课堂的FFT太基础了，实在提不起兴趣。
模拟费用流.......应该听得懂(吧
听得懂个鬼！为啥还有模拟费用流这种操作啊。自闭了

下午跑去听分块和莫队了。（听说有云南省选（大雾）,exciting!）
诶，还别说，这节课是整个冬令营我唯一全程在线的一节课。
老师好棒啊ヾ(◍°∇°◍)ﾉﾞ非常照顾我等蒟蒻的感受，点赞~

晚上是试机赛。
刚道理，这是本菜鸡第一次写提交答案题。
一看题面.......emmmmmm，鬼畜题，不可做。
然后猛然发现我可以直接生成一个答案，丢给交互库检测不就好了嘛w。
然后就敲敲敲敲......
然鹅我的假爬山只能爬出30多分，广二xfz dalao的爬山爬出了50多分，tql。<del>难道我学了假爬山?</del>

<hr />

<h2>Day 5</h2>

今天只有第一课堂了<del>自闭不可避</del>.
嗯好了，果然自闭了，告辞。

群里的老哥都好fake啊，嘴巴上说着自闭，身体上却听得很诚实。

晚上的神仙打架咕掉了，不可听，不可听.jpg
结果lbc说讲指令集<del>完了，血亏一个亿</del>, <del>题答题：安排上了</del>
结果lbc半个小时后回来了，听他说后面神仙打架，自闭了。还好没去233。
<del>总算调出来DAY1的生成函数鬼畜题了，不容易</del>。

明天就要考试了，要加油呢~

<hr />

<h2>Day 6 Part1</h2>

考试。

<del>考场外等半天进不去，不愧是咕咕f。群里都有老哥开始商量DAY2了233</del>

<strong>8:13</strong>
总算开考啦~
我怎么进不去桌面啊喂，我不愧是星际玩家，密码都能看错。然后我连续打了5次密码，一直都进不去，举手提问老师后猛然发现选错账号了。<del>我是SB</del>

<strong>8:22</strong>
折腾了一番总算进入桌面啦~
打开主文件夹：诶？这里有个选手须知，算了，我们开题面再去开那个须知吧(flag*1
然后我开完题面之后就忘记有选手须知了。<del>我是金鱼吗</del>

<blockquote>
  这种鬼畜比赛，一般来说题答题和交互题都是毒瘤题，传统题一定最好骗分，OK，先把传统的暴力打了。
</blockquote>

5min later：蛤？这啥题啊，我咋连题都读不懂。
然后前后反复读了5遍题，总算读懂了$op=0$的题目大意。
那这个显然很好搞嘛......我直接找有多少个连通块不就搞定啦？

然后当然是写写写写写啦。
调试非常顺利，一遍过<del>大</del>样例，稳。

<strong>9:00</strong>
折腾完第一题的大暴力，我决定先往后看一下，神仙比赛，靠苟，不靠肛。

好了，我读不懂T2。好了，我读懂了T3。
根据上年冬令营的经验，交互题会送很多分。然后我迅速地与自己达成了共识：先去骗T3的分。

emmmm，所以说，这个在相等的情况下以某种方式返回时啥意思.....待我看看grader....
啊.....smg....怎么是个随机函数。。。。

那咋搞啊.....
30 min later
woc，n=5！！！我又漏看数据范围了。那我们应该可以这样做：我们暴力枚举所有的情况，然后对于不同的数去暴力询问一下，看一下是否满足我们目前了解的信息，如果满足的话应该就是解了。
然后冷静查错了5min，emmm，应该没问题。

然后就是写写写写写啦~
还别说，交互题难写得要命，被gdb惯坏的我已经不会输出变量来调试了....
东错一个，西锅一个，磕磕绊绊60min后总算过了样例。

然后自己手造了5组数据，一测，wa。
检查后猛然发现，我这个做法有一定的随机性，如果我询问的两个数原本正好相等，那么返回的值是不稳定的。对于这种问题，解决的方法只有一个：多问几遍。
然鹅问太多会导致询问次数超标。经过我玄学调参后发现，问3次刚刚好。

然鹅这破写法还是有一定的概率wa，根据我手玩评测的情况表明，我这种搞法的正确率只有$\frac{19}{20}$。一看时间：woc，已经11点了，这不星啊，得赶紧开T2。然后这题就放那了，一切随缘。

<strong>11:10</strong>
我得快点读懂第二题啊......
第一遍读题：emmmm，我好像看懂了题目大概要问什么，问题是这个checker的使用说明啥意思啊，啥叫“连边关系描述文件”啊。
第二遍读题：emmmm，我没有理解错题意啊，问题是我还是不知道什么叫连边关系描述文件啊。
第三遍读题：emmmm，好像连边关系描述文件指的就是我们的computer.in，那么问题来了：后面那个数据文件又是啥意思啊。
第四遍读题：emmmm，还是不懂。
好吧，我举手问老师吧。老师：自己好好看题。
这就很shit了。
第五遍读题：emmmm，难道说这个输入文件指的是我们要从终端输入的数据？待我测试一发：段错误

emmmm，我难道写爆了什么地方？
一顿修改参数后：段错误*15
玩你马啊......
第六-十遍读题：我到底漏了什么啊啊啊啊啊，为啥不能“编译”啊。
放弃治疗，举手提问。老师：你看了选手须知吗？我：蛤？选手提醒里不是只有对T3的提醒吗？老师：我说的是主目录下的那个。我：蛤？主目录还有选手须知？切出去一看：woc，我刚刚好像忘记看了。emmmmmm，我是SB。
然后选手目录下大大的写着这句话：

<blockquote>
  若提示段错误，可尝试输入指令xxxx xxx 来处理。
</blockquote>

艹啊！
然后我总算能编译运行了，<del>太棒了</del>
结果这一顿折腾下来，时间已经不知不觉地过去了一个小时，现在距离考试结束只有一个小时的时间了。

<strong>12:10</strong>
不行，我不能放弃，<del>放弃了回家要被打死</del>。
赶紧看数据点：
subtask1：输入输出。........好SB的问题啊，还好我没有死磕T3，要不然我就凉了<del>(事实上，我已经在T3上浪费了2个半小时</del>
光速水完subtask1，开subtask2：
woc?两个int计算fib的第k项？
这能搞？
那一定是一些玄学数学方法把K强行融入到哪两个int里面去再一顿操作来解决吧。
emmmm，想了半个钟，不会，告辞。
subtask3：从1输入n个数，在第n的节点按原顺序输出。
emmmm,我不直接找个最短路不就完事了吗？
爆写迪杰斯特拉，15min敲完，15min码完，一发过样例，稳。

<strong>12:50</strong>
现在只剩半个钟了，前面各种失误浪费了成吨的时间，现在好像已经打了99分了，理论上Cu稳了，我是应该检查一波还是继续rushT2冲Ag呢？
既然T1过了大样例，T3也过了手测，那我还是继续rushT2吧。
T2的fib我应该是颓不出来了，但是后面那两个......emmmmmm
对于第一个，我们好像可以暴力以每个点做到50~100的任意最短路，然后再打个暴力程序来输出代码？
好像可行。

不幸的是，我并不能码完。
最后检查了一下文件名和输入输出含恨离场。

中午当然是回宿舍颓啊。
wzj dalao这次看起来考得不是很好鸭.....xfz dalao考得好像也一般，fxh忘记把文件丢到文件夹里面去了，tcl。好像我们这帮人考得都挺炸的？

喜闻乐见：咕咕f又咕咕咕了。
咕到4点总算出成绩了：怀着砰砰直跳的心打开dpf：T1：28：没问题，意料之中；T2：40：没问题，意料之中；T3：爆零？woc，$\frac{1}{20}$的概率我都能撞到？然后听说群里的老哥说评测时的grader不随机.......fxxk,那我那两个半小时好好去骗T2分不美滋滋吗？我写T3干什么鬼啊。

讲评全程自闭：什么鬼神仙题啊，T1T3鬼畜数学，T2中的第三第四个点是鬼畜网络流。告辞.jpg

<hr />

<h2>Day 6 Part2</h2>

文艺汇演当然要专门开来讲啊w。

一开始还以为文艺汇演会咕，失落了好一会：我们准备了半天的歌曲要被咕掉了。
但是在群里dalao们的大力推动下，文艺汇演得以重回WC舞台。在这里再次感谢群里的dalao们。

刚道理，第一次在全国性舞台唱歌，而且我还是弱省最菜的蒟蒻，好紧张鸭。
但是看起来反响还不错？那......太棒了.jpg

接近结尾的时候出了点小插曲，大家都挺不愉快的。感谢LCAdalao的紧急公关救场，让我们得以以《难玩今宵》收场了。

具体汇演视频还请在B站上搜WC2019,记得在《千里追月》那一p发弹幕喔w。

<hr />

<h2>Day 7</h2>

社会活动去科技馆好评！

模拟飞行有高级外设好棒啊，<del>可惜是FSX的简单模式，气动过于魔法</del>

下午是颁奖仪式&amp;闭幕式。

<blockquote>
  CCF要恰饭，没办法公益
  选手教练该干嘛还干嘛
  会跟教育部沟通——dzd
</blockquote>

GX这次有3个Ag，太棒了。%%%%%Maxwei_wzj。
本菜鸡？别提了，太惨了，差点打铁，卡线Cu。
心疼南二另外两位dalao被重测卡掉了T2的第二个点，惨遭-=20。
柳高tql，南三tql。

<hr />

<h2>Day 8 &amp; 总结</h2>

Ag是不可能Ag的，这辈子都不可能Ag的。五个小时也不够，脑洞又赶不上毒瘤题，就是靠暴力这种东西，才能勉强维持的了Cu这样子。在冬令营里面的感觉，比家里面颓感觉好多了！在家里面还要被逼学，都没有dalao玩 ，来了冬令营里面个个都是人才。冬令营里的dalao个个都是鸽子，还会嘤嘤嘤，我超喜欢在里面！

广州二中，我们七月再见！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>14</wp:post_id>
		<wp:post_date><![CDATA[2019-02-11 12:23:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-11 12:23:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[wc2019-%e8%87%aa%e9%97%ad%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="oi"><![CDATA[OI]]></category>
		<category domain="post_tag" nicename="%e6%b8%b8%e8%ae%b0"><![CDATA[游记]]></category>
		<category domain="category" nicename="%e6%b8%b8%e8%ae%b0-%e8%87%aa%e9%97%ad%e8%ae%b0-%e6%bb%9a%e7%b2%97%e8%ae%b0"><![CDATA[游记/自闭记/滚粗记]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2518]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[lizbaka]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[116.252.221.146]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-20 11:35:34]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-20 11:35:34]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[tql %%%%%%%%%]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[lizbaka]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[116.252.221.146]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-20 11:35:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-20 11:35:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[tql %%%%%%%%%%%]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-20 11:37:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-20 11:37:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您假假]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>6</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>24</wp:comment_id>
			<wp:comment_author><![CDATA[GKxx]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2863746329@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[121.231.141.111]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-05 15:20:31]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-05 15:20:31]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[tql%%%%%%%]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>25</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-05 15:31:09]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-05 15:31:09]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您强%%%%]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>67</wp:comment_id>
			<wp:comment_author><![CDATA[Xing_Ling]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[965579261@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[118.122.142.210]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-08-23 09:09:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-08-23 09:09:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[两个int计算fib的第k项是个什么鬼东西？？ORZ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>68</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[58.213.133.130]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-08-23 12:52:19]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-08-23 12:52:19]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你看嘛...一个运算节点能存两个变量，那个部分分又只给一个节点，那不就是两个int求fib的第K项嘛 |´・ω・)ノ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>67</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[POJ1009]消失之物</title>
		<link>https://www.goldenpotato.cn/uncategorized/poj1009-%e6%b6%88%e5%a4%b1%e4%b9%8b%e7%89%a9/</link>
		<pubDate>Tue, 12 Feb 2019 08:57:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=80</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面:</h1>

传送门:<a href="http://poj.openjudge.cn/practice/1009/">POJ</a>

<hr />

<h1>Solution</h1>

DP+DP

首先,我们可以很轻松地求出所有物品都要的情况下的选择方案数,一个简单的满背包DP就好

即:$f[i][j]$表示前i个物品装满容量为j的背包的方案数.

转移也很简单 $f[i][j]=f[i-1][j]+f[i-1][j-w[i]] (i:1~n,j:1~m)$ (即选和不选的问题)

初始化 $f[i][0]=1 (i:[0~n])$ (如果背包容量为0,无论如何都有且只有一种方案将其装满)

接下来,考虑用另一个dp来求解在某一物品不放下的方案数

设 $g[i][j]$ 表示第i个物品不放入背包,装满容量为j的背包的方案数

转移为:

$g[i][j] =  f[n][j] ( j &lt; w[i]) $ (即当背包容量小于所不放物品的大小时,那么其方案数必然为f[n][j],因为f[n][j]中的所有方案肯定取不到第i个)

　　  $= f[n][j]  -  g[i][j-w[i]]$ i:1-nj:1-m

下面那个转移意思即是:

所有的方案总数 减去 包括第i项物品的方案数

因为$g[i][j-w[i]]$中的每一种情况再装入$w[i]$即可达到$g[i][j]$这个状态,而$g[i][j]$的定义是不装入i的方案数,所以说包括第i项物品的方案能且仅能从$g[i][j-w[i]]$转移过来

初始化:

$g[i][0]=1$ (i:[0~n])(背包容量为0时方案有且仅有啥都不要)

这样就可以口头AC了

但是,还有一个要注意的小地方

在%P的意义下, $f[n][j]-g[i][j-w[i]]$有可能为负数

负数取模的方法为 :  $(x\ mod\ P + P)mod\ P$

然后就OK啦

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Openjudge 1009:消失之物
//Apr,2ed,2018
//DP+DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2000+100;
const int M=2000+100;
const int P=10;
char f[N][M],g[M];
int w[N],n,m;
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        w[i]=read();

    f[0][0]=1;
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;=m;j++)
        {
            f[i][j]=f[i-1][j];
            if(j-w[i]&gt;=0)
                f[i][j]+=f[i-1][j-w[i]];
            if(f[i][j]&gt;=P) f[i][j]%=P;
        }

    g[0]=1;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            if(j&lt;w[i])
                printf("%d",g[j]=f[n][j]);
            else
                printf("%d",g[j]=(f[n][j]-g[j-w[i]]+P)%P);
        }
        printf("\n");
    }
    return 0;
}

</code></pre>

<hr />

<h1>后记</h1>

这种DP+DP的题目还是第一次写,写起来有一点点不熟练

看来我还是需要多学习一个]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>80</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 08:57:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 08:57:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj1009-%e6%b6%88%e5%a4%b1%e4%b9%8b%e7%89%a9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="dpdp"><![CDATA[DP+DP]]></category>
		<category domain="post_tag" nicename="oi"><![CDATA[OI]]></category>
		<category domain="post_tag" nicename="poj"><![CDATA[POJ]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<category domain="category" nicename="%e8%83%8c%e5%8c%85dp"><![CDATA[背包DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[[POJ1009] 消失之物解题报告]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[[POJ1009] 消失之物]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_visits_count]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1014]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[WarmSnow]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[zhang_xiang_zhou@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[60.18.187.226]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-14 03:38:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-14 03:38:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[EEEEEeeeee]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.140.219.218]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-14 05:48:01]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-14 05:48:01]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[诶？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>10</wp:comment_id>
			<wp:comment_author><![CDATA[WarmSnow]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[zhang_xiang_zhou@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.83.231.121]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-01 23:11:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-01 23:11:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Good !]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P2891/POJ 3281/USACO07OPEN ]吃饭Dining</title>
		<link>https://www.goldenpotato.cn/%e7%bd%91%e7%bb%9c%e6%b5%81/luogu-p2891-poj-3281-usaco07open-%e5%90%83%e9%a5%addining/</link>
		<pubDate>Tue, 12 Feb 2019 10:19:16 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=86</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>传送门：<a href="https://www.luogu.org/problemnew/show/P2891">洛谷</a></strong>

<hr />

<h1>Solution</h1>

网络流

先引用一句真理:网络流最重要的就是建模
今天这道题让我深有体会

首先,观察数据范围,n=100,一般这种100-1000的图论题,很有可能是网络流.

那就直接从网络流的角度入手

考虑这样建模
<img src="https://s2.ax1x.com/2019/02/12/kwklcV.png" alt="kwklcV.png" />

建模要点如下:

1.建权值为1的边,保证每个食物和水仅用一次

2.没了

对以上的图求一个最大流,那不就是我们想要的最大的匹配数吗?

看起来是不是很OjbK?

.

其实不然,这样子一头牛有可能脚踏N条食物和水,但是题目要求一头牛只能吃喝一次

反例如下:

<a href="https://imgchr.com/i/kwk0c6"><img src="https://s2.ax1x.com/2019/02/12/kwk0c6.png" alt="kwk0c6.png" /></a>

所以说,我们要对一头牛吃的东西做一个限制,保证其只流过1

怎么限制呢?

直接把一头牛拆成两头牛,中间连一条边就OK了嘛

如下图:
<img src="https://s2.ax1x.com/2019/02/12/kwkrnO.png" alt="kwkrnO.png" />

接下来就可以考虑如何给点编号了

我的编号方法很直接,很暴力

源点:1

食物: 2 ~  2+f-1

牛   2+f ~ 2+f+2n -1

水: 2+f+2n ~ 2+f+2n+d

汇点:1000

如下图所示

按照以上方法,每种物品对应的点为:

食物i : 1+i

牛i : 1+f+i

牛i的右边的分点:  1+f+n+i

水i: 1+f+2*n+i

然后dinic直接求一波最大流就可以带走啦

DINIC教程传送门: http://www.cnblogs.com/SYCstudio/p/7260613.html (个人感觉写得很清楚)

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P2891 [USACO07OPEN]吃饭Dining
//Apr,2ed,2018
//Dinic求最大流
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100+10;
const int M=N*10;
const int inf=0x3f3f3f3f;
struct line
{
    int t,rev,w;
};
vector &lt;line&gt; e[M];
inline void AddLine(int s,int t)
{
    line temp;
    temp.t=t,temp.rev=e[t].size(),temp.w=1;
    e[s].push_back(temp);
    temp.t=s,temp.rev=e[s].size()-1,temp.w=0;
    e[t].push_back(temp);
}
int n,f,d;
int dl[M],head,tail,depth[M];
bool visited[M];
bool bfs()
{
    memset(visited,0,sizeof visited);
    dl[1]=1,depth[1]=1;
    visited[1]=true;
    head=1,tail=2;
    while(head&lt;tail)
    {
        int now=dl[head],size=e[now].size();
        for(int i=0;i&lt;size;i++)
            if(visited[e[now][i].t]==false and e[now][i].w&gt;0)
            {
                visited[e[now][i].t]=true;
                dl[tail++]=e[now][i].t;
                depth[e[now][i].t]=depth[now]+1;
            }
        head++;
    }
    return visited[1000];
}
int dfs(int now,int f)
{
    if(now==1000)
        return f;
    int size=e[now].size(),ans=0;
    for(int i=0;i&lt;size;i++)
        if(depth[e[now][i].t]==depth[now]+1 and e[now][i].w&gt;0)
        {
            int t_ans=dfs(e[now][i].t,min(f,e[now][i].w));
            e[now][i].w-=t_ans;
            e[e[now][i].t][e[now][i].rev].w+=t_ans;
            f-=t_ans,ans+=t_ans;
            if(f==0) break;
        }
    return ans;
}
int Dinic()
{
    int ans=0;
    while(bfs())
        ans+=dfs(1,inf);
    return ans;
}
int main()
{
    n=read(),f=read(),d=read();
    for(int i=1;i&lt;=1000;i++)
        e[i].reserve(16);
    for(int i=1;i&lt;=f;i++)
        AddLine(1,1+i);
    for(int i=1;i&lt;=d;i++)
        AddLine(1+f+2*n+i,1000);
    for(int i=1;i&lt;=n;i++)
    {
        int F=read(),D=read(),temp;
        for(int j=1;j&lt;=F;j++)
        {
            temp=read();
            AddLine(1+temp,1+f+i);
        }
        for(int j=1;j&lt;=D;j++)
        {
            temp=read();
            AddLine(1+f+n+i,1+f+2*n+temp);
        }
    }
    for(int i=1;i&lt;=n;i++)
        AddLine(1+f+i,1+f+n+i);

    printf("%d",Dinic());
    return 0;
}

C++
</code></pre>

<h1>后记</h1>

写的时候发现自己真的有点生疏了,这种比较靠记忆的算法还是久不久搞一下来恢复记忆为妙

网络流的时间复杂度真玄学]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>86</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 10:19:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 10:19:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2891-poj-3281-usaco07open-%e5%90%83%e9%a5%addining]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dicnic"><![CDATA[Dicnic]]></category>
		<category domain="post_tag" nicename="oi"><![CDATA[OI]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%9c%80%e5%a4%a7%e6%b5%81"><![CDATA[网络最大流]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e6%9c%80%e5%a4%a7%e6%b5%81"><![CDATA[网络最大流]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[44]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[Dining解题报告。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[411]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[BZOJ4818] [SDOI2017] 序列计数</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/%e8%83%8c%e5%8c%85dp/bzoj4818-sdoi2017-%e5%ba%8f%e5%88%97%e8%ae%a1%e6%95%b0/</link>
		<pubDate>Tue, 12 Feb 2019 10:46:00 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=90</guid>
		<description></description>
		<content:encoded><![CDATA[标签（空格分隔）：

<hr />

<h1>题面:</h1>

传送门:<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4818">BZOJ</a>

<hr />

<h1>Solution</h1>

看到这道题,我们不妨先考虑一下20分怎么搞
想到暴力,本蒟蒻第一反应就是dfs,想法也很简单:
枚举n个数中的每一个数,枚举完每一种情况都判断一下是否满足要求
复杂度$O(n^m)$
显然,这样的复杂度一分都得不到,但是可以作为对拍用的暴力程序

既然dfs行不通了,那我们换个想法吧,考虑一下用dp来搞这个问题
设$f[i][j]$表示选到第i个数,前i个数的总和%p为j

转移也很好写
我们枚举一下上一个数字是啥就好
$\large f[i][j]= \sum_{k=1}^m f[i-1][((j-k)\%p+p)\%p]$

$i:[1,n] j:[0,p-1] $

注意一下: j-k有可能是负数,所以要用负数取模的方法

初始化 $f[0][0]=1$ (没有数字时,仅有总和为0的情况有一种可行方法)

题目要求的有质数用一个简单的容斥就可以了

我们再做一个没有质数的dp,转移方程跟上面一样,仅需要保证 k 不为质数就行

最后将两者的i为n,j为0的状态相减就是最后答案了.

时间复杂度 $O(n<em>p</em>m)$,20分

接下来,我们可以考虑一个很妙的优化

我们发现上面的转移方程

$\large f[i][j]= \sum_{k=1}^m f[i-1][((j-k)%p+p)%p]$ 
$i:[1,n]\ \ \  j:[0,p-1] $
j是从$0-p-1$的,而k是从$1-m$的

这说明了,f[i-1][j]中的某些项是会重复计算到下一个状态的
这样子,我们可以考虑做一个预处理,减少重复计算造成的时间的浪费

考虑这样做:

我们通过一个O(m)的预处理,计算出每一个从[0,p-1]的数可能从多少个[1,m]中的数%p计算而得
用一个tot[k]存储下来,tot[k]的意义为:1~m的数%p为k的有多少个
那么这样子,我们的转移方程可优化成这样子
$\large f[i][j]= \sum_{k=0}^{p-1} f[i-1][((j-k)%p+p)%p]*tot[k] $
$i:[1,n]\ \ \  j:[0,p-1]$

因为 (j-k)%p = j%p - k%p;
所以说,每一个f[i-1][j%p - k%p]被算的次数仅与有多少个 K1%p=K2%p=K3%p=....有关
我们可以设K1%p=K2%p=K3%p=...=y
原式就可以变为f[i][j]=sigma f[i][j%p-y]<em>tot[y] 
而tot[y]已在前面的预处理解决了
这样,时间复杂度就成功的降为了:O(n</em>p*p)

然而并没有什么卵用,因为出题者并没有设计这一档的分

我们再考虑一个优化

f[i][j]= sigma f[i-1][((j-k)%p+p)%p]*tot[k]   k:[0,p-1]

i:[1,n] j:[0,p-1]

原转移式是不是有一个特征?对,那就是式子是固定死的,这意味着我们可以用矩阵优化至O(m^3log n)

这种类型的转移矩阵我称为"一层层"的转移,可以考虑这样列转移矩阵
<a href="https://imgchr.com/i/kwANqS"><img src="https://s2.ax1x.com/2019/02/12/kwANqS.md.png" alt="kwANqS.md.png" /></a>
然后就OK啦

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P3702 [SDOI2017]序列计数
//Apr,11th,2018
//矩阵加速DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int P=100+10;
const int M=20000000+100;
const int poi=20170408;
struct MAT
{
    int x,y;
    long long a[P][P];
    MAT (int tx,int ty)
    {
        x=tx,y=ty;
        memset(a,0,sizeof a);
    }
    friend MAT operator * (MAT A,MAT B)
    {
        MAT ans=MAT(B.x,A.y);
        for(int i=1;i&lt;=ans.y;i++)
            for(int j=1;j&lt;=ans.x;j++)
                for(int k=1;k&lt;=A.x;k++)
                {
                    ans.a[i][j]+=A.a[i][k]*B.a[k][j];
                    if(ans.a[i][j]&gt;=poi) ans.a[i][j]%=poi;
                }
        return ans;
    }
};
MAT FastPow(MAT a,int b)
{
    if(b==1) return a;
    MAT ans=FastPow(a,b/2);
    ans=ans*ans;
    if(b%2==1) ans=ans*a;
    return ans;
}
int n,m,p,tot[P];
bool IsPrime[M];
int prime[M],p_tot;
void GetPrime()
{
    memset(IsPrime,1,sizeof IsPrime);
    IsPrime[0]=IsPrime[1]=0;
    for(int i=2;i&lt;=m;i++)
    {
        if(IsPrime[i]==true) prime[++p_tot]=i;
        for(int j=1;j&lt;=p_tot and prime[j]*i&lt;=m;j++)
        {
            IsPrime[prime[j]*i]=false;
            if(i%prime[j]==0) break;
        }
    }
}
int main()
{
    n=read(),m=read(),p=read();

    for(int i=1;i&lt;=m;i++)
        tot[i%p]++;
    GetPrime();
    MAT A=MAT(p,p);
    for(int i=1;i&lt;=p;i++)
        for(int j=1;j&lt;=p;j++)
            A.a[i][j]=tot[((i-j)%p+p)%p];
    MAT B=MAT(1,p);
    for(int i=1;i&lt;=p;i++)
        B.a[i][1]=tot[i-1];
    long long ans=(FastPow(A,n-1)*B).a[1][1];

    memset(tot,0,sizeof tot);
    for(int i=1;i&lt;=m;i++)
        if(IsPrime[i]==false)
            tot[i%p]++;
    for(int i=1;i&lt;=p;i++)
        for(int j=1;j&lt;=p;j++)
            A.a[i][j]=tot[((i-j)%p+p)%p];
    for(int i=1;i&lt;=p;i++)
        B.a[i][1]=tot[i-1];
    ans-=(FastPow(A,n-1)*B).a[1][1];

    printf("%lld",(ans%poi+poi)%poi);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>90</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 10:46:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 10:46:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj4818-sdoi2017-%e5%ba%8f%e5%88%97%e8%ae%a1%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<category domain="category" nicename="%e8%83%8c%e5%8c%85dp"><![CDATA[背包DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[[BZOJ4818] [SDOI2017] 序列计数的解题报告。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[[BZOJ4818] [SDOI2017] 序列计数]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[413]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>GXOI2018 滚粗记</title>
		<link>https://www.goldenpotato.cn/%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95/gxoi2018-%e6%bb%9a%e7%b2%97%e8%ae%b0/</link>
		<pubDate>Tue, 12 Feb 2019 12:00:52 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=92</guid>
		<description></description>
		<content:encoded><![CDATA[今天考了一次蜜汁省选,滚粗了.想了想,还是写点什么记录一下

<hr />

<h3>8:10</h3>

折腾一番总算拿到题目和样例了,一打开dpf,立马感觉到了不对劲. 题目一股浓浓的劣质模拟题的画风,先不说题目质量,单是排版质量都被好一点的模拟赛甩几条街,更不要说正式比赛了

再仔细看了一眼题目名字,一股浓浓的坑爹感扑面而来.

T1叫做序列计数什么的,看起来挺高级
T2叫评分,估计又是一道SB模拟题
T3就叫DIV,怕不是高精度除法
T4叫合唱队形?????原题????合唱队形为啥会出在省选中??????

<h3>8:15</h3>

折腾了一番后开始开T1

看到题面后的第一眼:哇,那么高深,怕不是又是一道数论题,不可做不可做

结果仔细一看题面: 求 C i n (n:8~28)

.........

这不是大水题吗????

为啥会在省选中出这种蜜汁题目.........

也许是送分题,算了

然后花20分钟敲了个质因数分解约分一下就完事了,测了一下样例,没问题,直接下一题

upd:(2018,Sep,14th) 其实质因数分解可以直接递推的，当时真的是too young ，too simple

<h3>8:35</h3>

开T2

一看题面..........
等等.....
再等一下..........

这题面似曾相识..........

这不是神TM的 GXOI 2017 T1原题吗?????

一个字都不带改的

..........

一道很水的模拟题
直接根据题目意思算一下分数,排个序就完事了

敲过样例,检查了一遍数据范围,很轻松,20分钟,直接下一题

<h3>8:55</h3>

那么快就到T3了

看到题面,果然,还真是高精度除法

肛道理,我是第一次写高精度除高精度的题目

拿出草稿纸yy了一下,应该直接模拟竖式计算就好了,然后就开写了

实际上写起来遇上了一点麻烦

写两句话,发现要写高精度比较两个数字大小
又写两句,发现要写高精度乘低精度的乘法
再写两句,发现要写高精度减法
最后发现我基本上把整个高精度模板类全部打了一遍(除了高精度加法)

写完了发现过不了样例.....
检查发现神TM高精度减法写错了

过完样例后写暴力上对拍

然后又发现过不了大数据(大概是15位的时候就错了)........

花半天时间检查,结果发现神TM高精度乘法进位时写的(n>10) (这么SB的错误怎么过的几万组的小对拍)

折腾完之后,发现考试时间只有两个小时了.......

果然考场上不要去碰没写过的东西,现在看起来正确无比233

<h3>11:00</h3>

总算到T4了,估计很多dalao早就写完AK了吧,估计只有我这个蒟蒻写到现在才到T4

这题就是合唱队形原题,只是加了一个求方案数

换汤不换药,直接扫一遍算一下就好

花了30分钟拍完dp(可能我手速还是太慢了)

然后写暴力

结果神TM暴力写挂,花了半个小时来调暴力,弄完后已经12:00了

对拍很顺利,没有任何问题

<h3>12:00</h3>

总算把整份题目都搞完了

花了半个小时检查了一波数据范围,把T3T4对拍了十几万组数据,觉得稳得一匹

12:30分的时候突然发现最后一题有可能爆longlong,要上高精.....

但已经没时间去弄那个东西了....

剩下半个小时也就检查一下文件名就过了,没做啥有实际意义的东西......

<h3>13:00</h3>

考试结束了.

好像大家都普遍认为这次考试连普及组的难度都达不到XD

和LX学长回训练教室收拾了一下东西(顺便颓了一下)

然后就上楼看成绩了

结果,我还没看到自己成绩,教练就直接跟我说:你只考得了200分,怎么回事?

????????

绝望地挤到前面看详细分数,最后一题炸了,只有10分.......

怎么可能???我对拍过的啊

突然,身边的wzj对我说:你输出没错吧,题目要求输出出队人数,而不是留在队伍里的人数.............

回到自己座位一看....

凉凉

我默认输出留在队伍里的人数了......

而样例数据正好留在队伍里的人数和出队人数一模一样

原本还以为自己联赛成绩正好在前6名,还有希望

结果希望被最后一题的一个小小的文字上的坑给覆灭了.......

怎么说呢?

眼瞎看错题的确是自己的锅

知道原因后难受了挺久的

自己辛辛苦苦努力那么久,就被一道SB题目给毁了,还TM毁在输出上

无法接受

明年还有最后一次机会,悲剧不能再次上演

总结一下今年考试

很无语,没有任何意义,考了4道普及组难度都没到的题目,还有两道原题

我不是很懂为什么省选要出这种题目

没有任何意义和区分度

我是高一,就算被坑都还有一次机会

但是听说柳州那边的好几个高二都被这一次SB省选给毁了

他们AK都进不了队,AK的人太多了

我觉得拿别人的前途开这种玩笑实在是太过分了

不是想diss出题者了,心累

就这样,滚回去搞文化了]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>92</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 12:00:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 12:00:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[gxoi2018-%e6%bb%9a%e7%b2%97%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%b8%b8%e8%ae%b0-%e8%87%aa%e9%97%ad%e8%ae%b0-%e6%bb%9a%e7%b2%97%e8%ae%b0"><![CDATA[游记/自闭记/滚粗记]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[35]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[GXOI2018 滚粗记]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[GXOI2018 滚粗记]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[483]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[LuoguP1005]矩阵取数游戏</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/%e8%83%8c%e5%8c%85dp/luogup1005%e7%9f%a9%e9%98%b5%e5%8f%96%e6%95%b0%e6%b8%b8%e6%88%8f/</link>
		<pubDate>Tue, 12 Feb 2019 12:07:20 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=94</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:https://www.luogu.org/problemnew/show/P1005

<hr />

<h1>Solution</h1>

我们可以先考虑贪心

我们每一次都选左右两边尽可能小的数,方便大的放在后面

听起来挺OK的

实则并不OK

反例:

3 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

如果贪心的话,我们会优先把右边那一串2先选了,再去选3和1

但是正确答案显然是先把3和1选了,再去选那一串2

.

既然贪心不成,我们可以考虑一下DP

然后我们考虑这样一个状态:

f[i][j][k] 表示第i时刻,第j行,左边选到了第k列

因为我们知道了当前时刻和左边选到的列数,右边选到的列数也可以推算出来: m-i+k-1

然后就可以写出来一个比较显然的转移方程:

$f[i][j][k]=max(f[i-1][j][k-1]+2^i<em>num[j][k-1],f[i-1][j][k]+2^i</em>num[j][m-i+k]) $

也就是第i时刻是选最左边的还是选右边的

.

这样子我们就可以得到 <del>100分</del> 60分

为什么会变成这样的呢?

原因很简单,我们仔细看一下数据范围:80

也就是说数据大小至少会有2^80

显然longlong (Int64)是放不下的

<del>这时候,我们就需要伟大的Int128</del>

你当然可以用stl的int128(虽然考试中不能用)

我们这里选用手写一个高精度类

我们只需要高精乘低精,高精加高精,高精比较大小
再加上若干时间的调试高精

然后就OjbK了

<hr />

#Code

<pre><code class="language-cpp ">//Luogu P1005 矩阵取数游戏
//DP+高精
//Apr,27th,2018
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
struct Int128
{
    int a[50],len;
    Int128()
    {
        memset(a,0,sizeof a);
        len=0;
    }
    void Insert()
    {
        char c=getchar();
        while(!isdigit(c)) c=getchar();
        while(isdigit(c)){a[++len]=c-'0';c=getchar();}
        int tot=len/2;
        for(int i=len;i&gt;tot;i--)swap(a[i],a[len-i+1]);
    }
    void Print()
    {
        for(int i=len;i&gt;=1;i--)
            printf("%d",a[i]);
    }
    friend Int128 operator * (Int128 a,int b)
    {
        Int128 ans=Int128();
        ans.len=a.len;
        for(int i=1;i&lt;=ans.len;i++)
        {
            ans.a[i]+=a.a[i]*b;
            ans.a[i+1]+=ans.a[i]/10;
            ans.a[i]%=10;
            if(i==ans.len and ans.a[i+1]!=0)
                ans.len++;
        }
        return ans;
    }
    friend Int128 operator + (Int128 a,Int128 b)
    {
        Int128 ans=Int128();
        ans.len=max(a.len,b.len);
        for(int i=1;i&lt;=ans.len;i++)
        {
            ans.a[i]+=a.a[i]+b.a[i];
            ans.a[i+1]+=ans.a[i]/10;
            ans.a[i]%=10;
            if(i==ans.len and ans.a[i+1]!=0)
                ans.len++;
        }
        return ans;
    }
    friend bool operator &lt; (Int128 a,Int128 b)
    {
        if(a.len&lt;b.len) return true;
        if(a.len&gt;b.len) return false;
        for(int i=a.len;i&gt;=1;i--)
            if(a.a[i]&gt;b.a[i])
                return false;
            else if(a.a[i]&lt;b.a[i])
                return true;
        return false;
    }
};
const int N=80+10;
Int128 f[2][N][N],POW[N];
int a[N][N];
int n,m;
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            scanf("%d",&amp;a[i][j]);

    POW[1].len=1,POW[1].a[1]=2;
    for(int i=2;i&lt;=m;i++)
        POW[i]=POW[i-1]*2;
    for(int i=1;i&lt;=m;i++)
        for(int j=1;j&lt;=n;j++)
            for(int k=1;k&lt;=i+1;k++)
            {
                if(k&gt;1)
                    f[i%2][j][k]=f[(i-1)%2][j][k-1]+POW[i]*a[j][k-1];
                if(m-i+k-1&lt;m)
                    f[i%2][j][k]=max(f[i%2][j][k],f[(i-1)%2][j][k]+POW[i]*a[j][m-i+k]);
                //f[i%2][j][k].Print();
                //cout&lt;&lt;endl;
            }

    Int128 ans=Int128();
    for(int i=1;i&lt;=n;i++)
    {
        Int128 t_ans=Int128();
        for(int j=1;j&lt;=m;j++)
            t_ans=max(t_ans,f[m%2][i][j]);
        ans=ans+t_ans;
    }

    ans.Print();
    return 0;
}


</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>94</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 12:07:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 12:07:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogup1005%e7%9f%a9%e9%98%b5%e5%8f%96%e6%95%b0%e6%b8%b8%e6%88%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e8%83%8c%e5%8c%85dp"><![CDATA[背包DP]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%b2%be%e5%ba%a6"><![CDATA[高精度]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[34]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[[LuoguP1005]矩阵取数游戏解题报告]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[[LuoguP1005]矩阵取数游戏]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[775]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>53</wp:comment_id>
			<wp:comment_author><![CDATA[sss]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3333333333@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[121.9.250.58]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-05-27 13:46:58]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-05-27 13:46:58]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:huaji9:  o(////▽////)o]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P1006]传纸条</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p1006%e4%bc%a0%e7%ba%b8%e6%9d%a1/</link>
		<pubDate>Tue, 12 Feb 2019 15:52:12 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=96</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:<a href="https://www.luogu.org/problemnew/show/P1006">洛咕</a>

<hr />

<h1>Solution</h1>

挺显然但需要一定理解的网络(应该是那么叫吧)DP

首先有一个显然但重要的结论要发现:从左上走到右下再从右下走回左上=从左上走两次到右下

那么接下来可以考虑:

设f[i][j][k][l]为第一次走到了(i,j)第二次走到了(k,l) 在路径不交错为前提下的能取到的最大友好值

转移方程也挺好写的

考虑这种情况能从哪里转移过来就好(i,j)可以从(i-1,j)或(i,j-1)转移过来,(k,l)可以从(k-1,l)或(k-1,l-1)转移过来

排列组合一下,总共4种可能性,取个最大值再加上a[i][j]和a[k][l]就好

当然(i==k and j==l) 即两个点重合的情况直接continue,因为f 的意义是之前的不重合,当前的也不能重合

预处理整个f设为0就好

时间复杂度O(n^4) n=50,显然能过

接下来我们可以考虑一个优化

因为我们两次从左上到右下是一起走的

就有这么一个推论: i+j = k+l (画个图就好,挺好发现的)

既然这两个相等,也就意味着我们可以通过总和与i,k推算出j,l

然后我们的方程就可以优化成这样的:

f[i][j][k]的意思为:走了i步,第一次走到了第j行,第二次走到了第k行

它们的橫坐标分别为:i-j+2,i-k+2

转移同理

这样,时间复杂度就可以优化为O(n^3),相较之前的可以称为巨大的飞跃

然后就OjbK了

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1006 传纸条
//May,4th,2018
//网格DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50+5;
int f[2*N][N][N],a[N][N],n,m;
int main()
{
    m=read(),n=read();
    for(int i=1;i&lt;=m;i++)
        for(int j=1;j&lt;=n;j++)
            a[i][j]=read();

    int MAX=n+m;
    for(int i=1;i&lt;=MAX;i++)
        for(int j=1;j&lt;=m;j++)
            for(int k=1;k&lt;=m;k++)
            {
                int X1=i-j+2,Y1=j,X2=i-k+2,Y2=k;
                if((X1==X2 and Y1==Y2)==false and X1&gt;0 and X2&gt;0 and X1&lt;=n and X2&lt;=n)
                {
                    f[i][j][k]=max(f[i][j][k],f[i-1][j][k]);
                    f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k]);
                    f[i][j][k]=max(f[i][j][k],f[i-1][j][k-1]);
                    f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-1]);
                    f[i][j][k]+=a[j][X1]+a[k][X2];
                }
            }

    printf("%d",max(f[m+n-3][m][m-1],f[m+n-3][m-1][m]));
    return 0;
}
</code></pre>

<hr />

<h1>后记</h1>

当时想为什么不会交叉的时候考虑了挺久的,这种类型的网格DP还是得多学习一个,我啊,太naive了

我太弱了]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>96</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 15:52:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 15:52:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1006%e4%bc%a0%e7%ba%b8%e6%9d%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%bd%91%e6%a0%bcdp"><![CDATA[网格DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[[Luogu P1006]传纸条解题报告]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[[Luogu P1006]传纸条 ]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[486]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2278] [HNOI2003]操作系统</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p2278-hnoi2003%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f/</link>
		<pubDate>Tue, 12 Feb 2019 15:57:02 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=98</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:<a href="https://www.luogu.org/problemnew/show/P2278">洛咕</a>

<hr />

<h1>Solutiton</h1>

挺简单的一道模拟题,拿堆模拟一下题目意思就好

堆中有两个关键字,分别是优先级和到达时间

还要维护一下每个任务剩余时间(还有多久完成)

因为堆不能直接改.得在堆里记录编号然后映射出来

这里总结一下要注意的细节:

1.在下一个任务到达之前,尽可能把CPU内的任务完成了

2.注意读入

3.注意注释文件读写233(我因为这破事爆零一次)

<del>4.没了</del>

好像不需要记录到达时间,编号即为到达时间先后

<del>但懒得改了</del>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P2278 [HNOI2003]操作系统
//May,4th,2018
//堆+模拟
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
const int N=1000000;
int t[N];
struct op
{
    int a,no,at;
    friend bool operator &lt; (op A,op B)
    {
        if(A.a==B.a)
            return A.at &gt; B.at;
        return A.a &lt; B.a;
    }
};
priority_queue &lt;op,vector&lt;op&gt; &gt; d;
int main()
{
    //freopen("system.in","r",stdin);
    int no,at,T,a,t_now=0;
    while(scanf("%d%d%d%d",&amp;no,&amp;at,&amp;T,&amp;a)==4)
    {
        while(d.empty()==false)
        {
            op now=d.top();
            if(t[now.no]&lt;=at-t_now)
            {
                d.pop();
                t_now+=t[now.no];
                printf("%d %d\n",now.no,t_now);
            }
            else
            {
                t[now.no]-=at-t_now;
                break;
            }
        }
        op temp;
        temp.no=no,temp.a=a,temp.at=at,t[no]=T;
        d.push(temp);
        t_now=at;
    }

    while(d.empty()==false)
    {
        op now=d.top();
        d.pop();
        t_now+=t[now.no];
        printf("%d %d\n",now.no,t_now);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>98</wp:post_id>
		<wp:post_date><![CDATA[2019-02-12 15:57:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-12 15:57:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2278-hnoi2003%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="post_tag" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e6%8b%9f"><![CDATA[模拟]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[36]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[[Luogu P2278] [HNOI2003]操作系统解题报告。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[[Luogu P2278] [HNOI2003]操作系统]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[425]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4147] 玉蟾宫</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p4147-%e7%8e%89%e8%9f%be%e5%ae%ab/</link>
		<pubDate>Thu, 14 Feb 2019 07:50:24 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=105</guid>
		<description></description>
		<content:encoded><![CDATA[<hr />

<h1>题面</h1>
传送门:<a href="https://www.luogu.org/problemnew/show/P4147">洛谷</a>

<hr />

<h1>Solution</h1>
裸的求极大子矩阵

感谢wzj dalao的教学

首先,有一个很显然但很重要的结论,那就是求极大子矩阵肯定要贴着边或一个障碍点,否则就会浪费

根据这个定理,我们可以考虑一种做法

我们可以枚举每一个可放置的点

我们可以很轻松的得知它与它左边的障碍点(或边界)的距离,也可以得知它上面与下面能扩展到哪里(即无障碍点最多能到哪里)

那这个点能扩出的长方形的最大面积就是它左边的上面与下面能扩展出来的距离的最小值*它到左边障碍点的距离

然后取一个最大的面积就好

<hr />

<h1>Code</h1>
<pre><code class="language-cpp">//Luogu P4147 玉蟾宫
//May,9th,2018
//悬线法旋转90°求极大子矩阵
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1000+10;
const int inf=0x3f3f3f3f;
int up[N][N],down[N][N],a[N][N],n,m;
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    char c[2];
    memset(a,0x80,sizeof a);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            scanf("%s",c+1);
            if(c[1]=='F') 
                a[i][j]=0;
        }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            if(a[i][j]==0 and a[i-1][j]==0)
                up[i][j]=up[i-1][j]+1;
    for(int i=n;i&gt;=1;i--)
        for(int j=1;j&lt;=m;j++)
            if(a[i][j]==0 and a[i+1][j]==0)
                down[i][j]=down[i+1][j]+1;

    int ans=0,u=inf,d=inf,w=0;
    for(int i=1;i&lt;=n;i++)
    {
        u=d=inf;
        w=0;
        for(int j=1;j&lt;=m;j++)
            if(a[i][j]!=0)
            {
                u=d=inf;
                w=0;
            }
            else
            {
                u=min(u,up[i][j]);
                d=min(d,down[i][j]);
                ans=max(ans,(++w)*(u+d+1));
            }
    }
    printf("%d",ans*3);
    return 0;
}</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>105</wp:post_id>
		<wp:post_date><![CDATA[2019-02-14 07:50:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-14 07:50:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4147-%e7%8e%89%e8%9f%be%e5%ae%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%bd%91%e6%a0%bcdp"><![CDATA[网格DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_path]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_text]]></wp:meta_key>
		<wp:meta_value><![CDATA[# [Luogu P4147] 玉蟾宫 

---
# 题面
传送门:[洛谷](https://www.luogu.org/problemnew/show/P4147)





 
---
# Solution
裸的求极大子矩阵

感谢wzj dalao的教学

首先,有一个很显然但很重要的结论,那就是求极大子矩阵肯定要贴着边或一个障碍点,否则就会浪费

 

根据这个定理,我们可以考虑一种做法

我们可以枚举每一个可放置的点

我们可以很轻松的得知它与它左边的障碍点(或边界)的距离,也可以得知它上面与下面能扩展到哪里(即无障碍点最多能到哪里)

那这个点能扩出的长方形的最大面积就是它左边的上面与下面能扩展出来的距离的最小值*它到左边障碍点的距离

然后取一个最大的面积就好

 
---
# Code
```cpp
//Luogu P4147 玉蟾宫
//May,9th,2018
//悬线法旋转90°求极大子矩阵
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1000+10;
const int inf=0x3f3f3f3f;
int up[N][N],down[N][N],a[N][N],n,m;
int main()
{
    scanf("%d%d",&n,&m);
    char c[2];
    memset(a,0x80,sizeof a);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%s",c+1);
            if(c[1]=='F') 
                a[i][j]=0;
        }
    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]==0 and a[i-1][j]==0)
                up[i][j]=up[i-1][j]+1;
    for(int i=n;i>=1;i--)
        for(int j=1;j<=m;j++)
            if(a[i][j]==0 and a[i+1][j]==0)
                down[i][j]=down[i+1][j]+1;
    
    int ans=0,u=inf,d=inf,w=0;
    for(int i=1;i<=n;i++)
    {
        u=d=inf;
        w=0;
        for(int j=1;j<=m;j++)
            if(a[i][j]!=0)
            {
                u=d=inf;
                w=0;
            }
            else
            {
                u=min(u,up[i][j]);
                d=min(d,down[i][j]);
                ans=max(ans,(++w)*(u+d+1));
            }
    }
    printf("%d",ans*3);
    return 0;
}
```




]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_mode]]></wp:meta_key>
		<wp:meta_value><![CDATA[text]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_mytory_markdown_etag]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_visits_count]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[[Luogu P4147] 玉蟾宫的解题报告。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_aioseop_title]]></wp:meta_key>
		<wp:meta_value><![CDATA[[Luogu P4147] 玉蟾宫]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[425]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1462] 通往奥格瑞玛的道路</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/luogu-p1462-%e9%80%9a%e5%be%80%e5%a5%a5%e6%a0%bc%e7%91%9e%e7%8e%9b%e7%9a%84%e9%81%93%e8%b7%af-%e4%ba%8c%e5%88%86%e7%ad%94%e6%a1%88%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/</link>
		<pubDate>Thu, 14 Feb 2019 08:17:51 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=109</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:https://www.luogu.org/problemnew/show/P1462

<hr />

<h1>Solution</h1>

这道题如果去除掉经过城市的收费.那么就是裸的最短路

但是题目要求经过城市中最多的一次性收费的最小值,也就是说让经过的最大值尽可能小

那我们可以考虑二分这个最大值

一切收费大于我们二分的值的城市统统不走

在最短路那里改一下就好了

然后就OjbK了

时间复杂度 $O(n&#42;logn&#42;logb)$

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1462 通往奥格瑞玛的道路
//May,27th,2018
//最短路+二分答案
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=10000+100;
const int V_MAX=1000000000;
struct road
{
    int to,dis;
    friend bool operator  &lt; (road A,road B)
    {
        return A.dis &gt; B.dis;
    }
};
vector &lt;road&gt; e[N]; 
priority_queue &lt;road,vector&lt;road&gt; &gt; dl;
int dis[N],vis[N],n,m,b,v[N];
void dj(int lim)
{
    while(dl.empty()==false) dl.pop();
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    if(v[1]&gt;lim) return;
    road now;
    now.to=1,now.dis=0,dis[1]=0;
    dl.push(now);
    while(dl.empty()==false)
    {
        now=dl.top();
        dl.pop();
        if(vis[now.to]==true) continue;
        vis[now.to]=true;
        for(int i=0;i&lt;int(e[now.to].size());i++)
            if(dis[e[now.to][i].to] &gt; now.dis+e[now.to][i].dis and v[e[now.to][i].to]&lt;=lim)
            {
                dis[e[now.to][i].to]=now.dis+e[now.to][i].dis;
                road temp;
                temp.to=e[now.to][i].to,temp.dis=dis[e[now.to][i].to];
                dl.push(temp);
            }
    }
}
int main()
{
    n=read(),m=read(),b=read();
    for(int i=1;i&lt;=n;i++)
    {
        e[i].reserve(4);
        v[i]=read();
    }
    for(int i=1;i&lt;=m;i++)
    {
        int a=read(),b=read(),c=read();
        road temp;
        temp.dis=c,temp.to=b;
        e[a].push_back(temp);
        temp.to=a;
        e[b].push_back(temp);
    }

    int L=0,R=V_MAX,ans=0x3f3f3f3f;
    while(L&lt;=R)
    {
        int mid=(L+R)/2;
        dj(mid);
        if(dis[n]&lt;=b)
        {
            ans=min(ans,mid);
            R=mid-1;
        }
        else
            L=mid+1;
    }

    if(ans!=0x3f3f3f3f)
        printf("%d",ans);
    else
        printf("AFK");
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>109</wp:post_id>
		<wp:post_date><![CDATA[2019-02-14 08:17:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-14 08:17:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1462-%e9%80%9a%e5%be%80%e5%a5%a5%e6%a0%bc%e7%91%9e%e7%8e%9b%e7%9a%84%e9%81%93%e8%b7%af-%e4%ba%8c%e5%88%86%e7%ad%94%e6%a1%88%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e4%ba%8c%e5%88%86-%e4%ba%8c%e5%88%86%e7%ad%94%e6%a1%88"><![CDATA[二分/二分答案]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86-%e4%ba%8c%e5%88%86%e7%ad%94%e6%a1%88"><![CDATA[二分/二分答案]]></category>
		<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84"><![CDATA[最短路径]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_path]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_text]]></wp:meta_key>
		<wp:meta_value><![CDATA[# [Luogu P1462] 通往奥格瑞玛的道路

# 题面
传送门:https://www.luogu.org/problemnew/show/P1462


---
# Solution
这道题如果去除掉经过城市的收费.那么就是裸的最短路

但是题目要求经过城市中最多的一次性收费的最小值,也就是说让经过的最大值尽可能小

 

那我们可以考虑二分这个最大值

一切收费大于我们二分的值的城市统统不走

在最短路那里改一下就好了

然后就OjbK了

 

时间复杂度 $O(n*logn*log b)$

---
# Code
```cpp
//Luogu P1462 通往奥格瑞玛的道路
//May,27th,2018
//最短路+二分答案
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=10000+100;
const int V_MAX=1000000000;
struct road
{
    int to,dis;
    friend bool operator  < (road A,road B)
    {
        return A.dis > B.dis;
    }
};
vector <road> e[N]; 
priority_queue <road,vector<road> > dl;
int dis[N],vis[N],n,m,b,v[N];
void dj(int lim)
{
    while(dl.empty()==false) dl.pop();
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    if(v[1]>lim) return;
    road now;
    now.to=1,now.dis=0,dis[1]=0;
    dl.push(now);
    while(dl.empty()==false)
    {
        now=dl.top();
        dl.pop();
        if(vis[now.to]==true) continue;
        vis[now.to]=true;
        for(int i=0;i<int(e[now.to].size());i++)
            if(dis[e[now.to][i].to] > now.dis+e[now.to][i].dis and v[e[now.to][i].to]<=lim)
            {
                dis[e[now.to][i].to]=now.dis+e[now.to][i].dis;
                road temp;
                temp.to=e[now.to][i].to,temp.dis=dis[e[now.to][i].to];
                dl.push(temp);
            }
    }
}
int main()
{
    n=read(),m=read(),b=read();
    for(int i=1;i<=n;i++)
    {
        e[i].reserve(4);
        v[i]=read();
    }
    for(int i=1;i<=m;i++)
    {
        int a=read(),b=read(),c=read();
        road temp;
        temp.dis=c,temp.to=b;
        e[a].push_back(temp);
        temp.to=a;
        e[b].push_back(temp);
    }
    
    int L=0,R=V_MAX,ans=0x3f3f3f3f;
    while(L<=R)
    {
        int mid=(L+R)/2;
        dj(mid);
        if(dis[n]<=b)
        {
            ans=min(ans,mid);
            R=mid-1;
        }
        else
            L=mid+1;
    }
    
    if(ans!=0x3f3f3f3f)
        printf("%d",ans);
    else
        printf("AFK");
    return 0;
}
```

 

 

 

 

 



]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_mode]]></wp:meta_key>
		<wp:meta_value><![CDATA[text]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_mytory_markdown_etag]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[mytory_md_visits_count]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[472]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[P2114] [NOI2014]起床困难综合症</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/p2114-noi2014%e8%b5%b7%e5%ba%8a%e5%9b%b0%e9%9a%be%e7%bb%bc%e5%90%88%e7%97%87-%e4%bd%8d%e8%bf%90%e7%ae%97/</link>
		<pubDate>Fri, 15 Feb 2019 15:37:46 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=121</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:<a href="https://www.luogu.org/problemnew/show/P2114">洛谷</a>

<hr />

<h1>Solution</h1>

一道很有意思的位运算题.

要做这一题,我们首先得了解一个很重要的特点

位运算过程中每一位都不会进位

有了这个特点,我们可以考虑一个很妙的做法

我们可以把每一扇门的那个数转为2进制

就可以在$O(n)$的时间内找到这一位以1或0为初始数,过完所有门后的这位数的结果

显然,结果为1是对答案有贡献的

然后,我们从后往前,一位一位枚举看一下初始值是填1还是填0

然后就OjbK了

时间复杂度$O(logm\cdot n)$

<hr />

<h1>Solution</h1>

<pre><code class="language-cpp ">//Luogu P2114 [NOI2014]起床困难综合症
//May,26th,2018
//位运算拆分法
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+1000;
const int LEN=35;
struct OP
{
    int a[LEN],type;
}op[N];
long long n,m;
int Count(int x,int p)
{
    for(int i=1;i&lt;=n;i++)
    {
        if(op[i].type==1)
            x=x &amp; op[i].a[p];
        else if(op[i].type==2)
            x=x | op[i].a[p];
        else
            x=x ^ op[i].a[p];
    }
    return x;
}
int main()
{
    n=read(),m=read();
    char temp[5];
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",temp+1);
        if(temp[1]=='A') op[i].type=1;
        else if(temp[1]=='O') op[i].type=2;
        else op[i].type=3;
        int t_num=read();
        for(int j=0;t_num!=0;j++)
        {
            op[i].a[j]=t_num%2;
            t_num/=2;
        }
    }

    long long used=0,ans=0;
    for(int i=0;i&lt;=30;i++)
    {
        int temp=Count(0,i);
        if(temp==1)
        {
            ans+=(1&lt;&lt;i);
            continue;
        }
        temp=Count(1,i);
        if(temp==1 and used+(1&lt;&lt;i) &lt;=m)
        {
            ans+=(1&lt;&lt;i);
            used+=(1&lt;&lt;i);
        }
    }

    printf("%lld",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>121</wp:post_id>
		<wp:post_date><![CDATA[2019-02-15 15:37:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-15 15:37:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[p2114-noi2014%e8%b5%b7%e5%ba%8a%e5%9b%b0%e9%9a%be%e7%bb%bc%e5%90%88%e7%97%87-%e4%bd%8d%e8%bf%90%e7%ae%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="category" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e5%a6%99%e9%a2%98"><![CDATA[妙题]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[569]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1119] 灾后重建</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/luogu-p1119-%e7%81%be%e5%90%8e%e9%87%8d%e5%bb%ba/</link>
		<pubDate>Fri, 15 Feb 2019 15:42:30 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=124</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:<a href="https://www.luogu.org/problemnew/show/P1119">洛谷</a>

<hr />

<h1>Solution</h1>

这题的思想很巧妙.

首先,我们可以考虑一下最暴力的做法,对每个时刻的所有点都求一遍单元最短路
因为最多只有200个时刻,时间复杂度为$O(n^3log(n+m)))$ (堆优化的迪杰斯特拉)
显然对于$n=200$,并过不了

我们可有进一步分析
这一题,我们堆优化的迪杰斯特拉慢在每加入一个点,我们每一次都得对全图彻彻底底做一轮松弛
那换个角度考虑,如果我只松弛经过新加入的点的点对呢?
没错,就得用Floyd了.
因为Floyd本质就是一个DP,给了我们极大的魔改的空间
考虑到Floyd最外层循环就是枚举加入的点,我们就可以只枚举里面那两层枚举点对的循环.
也就是说我们只用考虑它有可能松弛到的点.
当然,在此之前,我们得先把这个点有关的边先连回去
然后先用两层循环(枚举中转点和起始点)来松弛终点为加入点的路径
接下来用刚刚说的两层循环来松弛经过新加入点路径就好

时间复杂度$O(n^3)$

然后就OjbK了

具体请看代码

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1119 灾后重建
//May,28th,2018
//巧妙的floyed松弛
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=200+10;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int n,m,T[N],dis[N][N],e[N][N];
int main()
{
    n=read(),m=read();
    memset(T,0x3f,sizeof T);
    memset(dis,0x3f,sizeof dis);
    memset(e,0x3f,sizeof e);
    for(int i=0;i&lt;n;i++)
        T[i]=read();
    for(int i=1;i&lt;=m;i++)
    {
        int a=read(),b=read(),temp=read();
        e[a][b]=e[b][a]=temp;
    }

    for(int i=0;i&lt;n;i++)
        e[i][i]=dis[i][i]=0;
    int Q=read(),to=0;
    for(int i=1;i&lt;=Q;i++)
    {
        int x=read(),y=read(),t=read();
        while(T[to]&lt;=t)
        {
            for(int j=0;T[j]&lt;=t;j++)
                dis[to][j]=dis[j][to]=min(dis[to][j],e[to][j]);
            for(int j=0;T[j]&lt;=t;j++)
                for(int k=0;T[k]&lt;=t;k++)
                    dis[to][k]=dis[k][to]=min(dis[k][to],dis[k][j]+dis[j][to]);
            for(int j=0;T[j]&lt;=t;j++)
                for(int k=0;T[k]&lt;=t;k++)
                    dis[j][k]=min(dis[j][k],dis[j][to]+dis[to][k]);
            to++;
        }
        if(dis[x][y]==0x3f3f3f3f)
            printf("-1\n");
        else
            printf("%d\n",dis[x][y]);
    }
    return 0;
}

//正解(c++)
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>124</wp:post_id>
		<wp:post_date><![CDATA[2019-02-15 15:42:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-15 15:42:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1119-%e7%81%be%e5%90%8e%e9%87%8d%e5%bb%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="floyd"><![CDATA[floyd]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84"><![CDATA[最短路径]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[438]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1345] [USACO5.4]奶牛的电信Telecowmunication</title>
		<link>https://www.goldenpotato.cn/%e7%bd%91%e7%bb%9c%e6%b5%81/luogu-p1345-usaco5-4%e5%a5%b6%e7%89%9b%e7%9a%84%e7%94%b5%e4%bf%a1telecowmunication/</link>
		<pubDate>Fri, 15 Feb 2019 15:48:11 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=126</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:<a href="https://www.luogu.org/problemnew/show/P1345">洛谷</a>

<hr />

<h1>Solution</h1>

这道题,需要一个小技巧了解决。

我相信很多像我这样接蒟蒻，看到这道题，不禁兴奋起来：“这道题是裸的割边，我会做！！！”
然后兴冲冲的打了个DINIC，交一发，80分。
所以说我们有时候还是太naive。

重新读题，会发现这题割的不是边，是点。<del>这样还能80分，数据真水</del>
所以说，我们需要一个割边转割点的小技巧。
我们可以考虑“拆点”，即把<strong>一个点拆成两个点，中间连一条边权为1的边</strong>。
<strong>前一个点作为“入点”，别的点连边连入这里。</strong>
<strong>后一个点作为“出点”，出去的边从这里出去。</strong>
这样，只要<strong>我们切断中间那条边，就可以等效于除去这个点</strong>
如图：
<img src="https://s2.ax1x.com/2019/02/15/krgVaj.png" alt="krgVaj.png" />
红色的边边权为1，黑色的边边权为inf。
<strong>原点和汇点的内部边权为inf，因为显然这两个点不能删除。</strong>

题面给的边删除没意义（因为我们要删点），所以也设为inf(事实上设为1也没问题，因为删除这条边的权值可以理解为删除了一个点)

至于怎么算割边，可以证明割边在数值上等于最大流（本蒟蒻不会证）
至于怎么求最大流........可以参考<a href="http://www.cnblogs.com/SYCstudio/p/7260613.html">这个博客</a>

最后记得<strong>双倍空间</strong>
然后就OjbK了

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1345 [USACO5.4]奶牛的电信Telecowmunication
//June,3rd,2018
//割边转割点
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=200+10;
const int inf=0x3f3f3f3f;
struct road
{
    int to,w,rev;
    road (int A,int B,int C)
    {
        to=A,w=B,rev=C;
    }
};
vector &lt;road&gt; e[N];
int n,m,c1,c2,depth[N];
queue &lt;int&gt; dl;
bool bfs()
{
    memset(depth,0,sizeof depth);
    depth[c1]=1;
    dl.push(c1);
    while(dl.empty()==false)
    {
        int now=dl.front();
        dl.pop();
        for(int i=0;i&lt;int(e[now].size());i++)
            if(e[now][i].w&gt;0 and depth[e[now][i].to]==0)
            {
                depth[e[now][i].to]=depth[now]+1;
                dl.push(e[now][i].to);
            }
    }
    if(depth[c2]==0) return false;
    return true;
}
int dfs(int now,int f)
{
    if(now==c2) return f;
    int ans=0;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(e[now][i].w&gt;0 and depth[e[now][i].to]==depth[now]+1)
        {
            int temp=dfs(e[now][i].to,min(f,e[now][i].w));
            e[now][i].w-=temp;
            e[e[now][i].to][e[now][i].rev].w+=temp;
            f-=temp,ans+=temp;
            if(f==0) break;
        }
    return ans;
}
int Dinic()
{
    int ans=0;
    while(bfs()==true)
        ans+=dfs(c1,inf);
    return ans;
}
inline void AddLine(int s,int t,int w)
{
    e[s].push_back(road(t,w,e[t].size()));
    e[t].push_back(road(s,0,e[s].size()-1));
}
int main()
{
    n=read(),m=read(),c1=read(),c2=read();
    for(int i=1;i&lt;=n;i++) e[i].reserve(8);
    for(int i=1;i&lt;=n;i++)
        if(i==c1 or i==c2)
            AddLine(i,i+n,inf);
        else
            AddLine(i,i+n,1);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        AddLine(s+n,t,inf);
        AddLine(t+n,s,inf);
    }

    printf("%d",Dinic());
    return 0;
}

//正解（C++）
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>126</wp:post_id>
		<wp:post_date><![CDATA[2019-02-15 15:48:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-15 15:48:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1345-usaco5-4%e5%a5%b6%e7%89%9b%e7%9a%84%e7%94%b5%e4%bf%a1telecowmunication]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%9c%80%e5%b0%8f%e5%89%b2"><![CDATA[最小割]]></category>
		<category domain="category" nicename="%e7%bd%91%e7%bb%9c%e6%b5%81"><![CDATA[网络流]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[417]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2341] [HAOI2006]受欢迎的牛</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/luogu-p2341-haoi2006%e5%8f%97%e6%ac%a2%e8%bf%8e%e7%9a%84%e7%89%9b/</link>
		<pubDate>Fri, 15 Feb 2019 15:52:43 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=128</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2341">洛谷</a>

<hr />

<h1>Solution</h1>

前排提示，本蒟蒻做法既奇葩又麻烦

我们先可以把题目转换一下。
可以把<strong>一头牛喜欢另外一头牛理解为另外一头牛被一头牛喜欢</strong>。
<strong>我们把被喜欢的关系建边，即B被A喜欢，从B向A连一条有向边。</strong>
<strong>显然，一个点若能到达其他所有节点，它就是题目中的明星牛。</strong>

接下来，我们可以考虑一个类似于DP的做法。
即一个点能访问到的点，等同于它的儿子们访问的到的点加上它自己。
显然，这种特性要在DAG（有向无环图）上才能方便的使用。
所以说，我们第一步要对题目做的是<strong>缩点</strong>。

缩完点之后，我们就可以进行图上DP了。
我们可以用一个01数组$f[i][j]$表示i能具体能到达的点为j（用010101数列表示）。
显然 f[i] |= f[k] （或运算）（k为i直接相连的点）
答案为f[i][j] j=11111111.... 的点

当然，这样做有一个问题。
点的最大数目为n，我们这样做是$O(n^2)$的，在最坏条件（没有一个点能缩在一起）的情况下，会T。
我们这时候就得请出bitset。
<a href="https://www.cnblogs.com/RabbitHu/p/bitset.html">bitset的食用方法</a>（借用胡小兔dalao的博客）

使用bitset后，我们计算一个点能到达其他的点的复杂度一下子降为了$O(n/32)$
总复杂度为$O(n^2/32)$

然后就可以过啦。

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P2341 [HAOI2006]受欢迎的牛
//June,5th,2018
//缩点+（完全没必要的）bitset
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int  N=10000+100;
vector &lt;int&gt; e[N],e2[N];
int n,m,belong[N],nd_tot,dfn[N],mcount,low[N],cnt[N];
bool InStack[N];
stack &lt;int&gt; s;
bitset &lt;N&gt; arrival[N]; 
void Tarjan(int now)
{
    InStack[now]=true;
    s.push(now);
    dfn[now]=low[now]=++mcount;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(dfn[e[now][i]]==0)
        {
            Tarjan(e[now][i]);
            low[now]=min(low[now],low[e[now][i]]);
        }
        else if(InStack[e[now][i]]==true)
            low[now]=min(low[now],low[e[now][i]]);
    if(low[now]==dfn[now])
    {
        nd_tot++;
        while(s.empty()==false)
        {
            int temp=s.top();
            s.pop();
            InStack[temp]=false;
            belong[temp]=nd_tot;
            cnt[nd_tot]++;
            if(temp==now) break;
        }
        arrival[nd_tot][nd_tot]=true;
    }
}
bool vis[N];
int ans=0;
void dfs(int now)
{
    vis[now]=true;
    for(int i=0;i&lt;int(e2[now].size());i++)
    {
        if(vis[e2[now][i]]==false)
            dfs(e2[now][i]);
        arrival[now]|=arrival[e2[now][i]];
    }
    if(int(arrival[now].count())==nd_tot)
        ans+=cnt[now];
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        e2[i].reserve(4),
        e[i].reserve(4);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        e[t].push_back(s);
    }

    for(int i=1;i&lt;=n;i++)
        if(dfn[i]==0)
            Tarjan(i);
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;int(e[i].size());j++)
            if(belong[i]!=belong[e[i][j]])
                e2[belong[i]].push_back(belong[e[i][j]]);
    for(int i=1;i&lt;=nd_tot;i++)
        if(vis[i]==false)
            dfs(i);

    printf("%d",ans);
    return 0;
}

//正解（C++）
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>128</wp:post_id>
		<wp:post_date><![CDATA[2019-02-15 15:52:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-15 15:52:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2341-haoi2006%e5%8f%97%e6%ac%a2%e8%bf%8e%e7%9a%84%e7%89%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e7%bc%a9%e7%82%b9-%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f"><![CDATA[缩点/强连通分量]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[420]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>关于博客搬迁</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e5%85%b3%e4%ba%8e%e5%8d%9a%e5%ae%a2%e6%90%ac%e8%bf%81/</link>
		<pubDate>Fri, 15 Feb 2019 16:27:17 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=131</guid>
		<description></description>
		<content:encoded><![CDATA[本菜鸡已经在慢慢搬啦~

<del>现在已经搬到了第<strong>6</strong>7页(从后往前)很快就能搬完啦(咕)</del>

<strong>已经搬完啦~</strong>

<del>如您目前有文章需求，可以先移步本菜鸡的<a href="https://www.cnblogs.com/GoldenPotato/">博客园</a></del>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date><![CDATA[2019-02-15 16:27:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-15 16:27:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e5%8d%9a%e5%ae%a2%e6%90%ac%e8%bf%81]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[443]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3119] [USACO15JAN]草鉴定Grass Cownoisseur</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p3119-usaco15jan%e8%8d%89%e9%89%b4%e5%ae%9agrass-cownoisseur/</link>
		<pubDate>Sun, 17 Feb 2019 03:02:38 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=136</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3119">洛谷</a>

<hr />

<h1>Solution</h1>

这题显然要先把缩点做了。

然后我们就可以考虑如何处理走反向边的问题。
像我这样的蒟蒻，当然是使用搜索，带记忆化的那种（滑稽）。

考虑设$f(i,j)$表示到达第i个点，还能走j次反向边，所能到达的最多的点的数量。
转移可以表示为：
<a href="https://imgchr.com/i/ksxCnS"><img src="https://s2.ax1x.com/2019/02/17/ksxCnS.md.png" alt="ksxCnS.md.png" /></a>

如果x能到达1所在的强连通分量或max出来的值不为0，说明当前状态可行，否则不可行。

然后用记忆化搜索表达出来就OK了

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
struct road
{
    int to,IsBack;
    road (int A,int B)
    {
        to=A,IsBack=B;
    }
};
vector &lt;int&gt; e[N];
vector &lt;road&gt; e2[N];
int belong[N],nd_tot,nd_to,low[N],dfn[N],InStack[N],cnt[N];
stack &lt;int&gt; st;
void Tarjan(int now)
{
    low[now]=dfn[now]=++nd_to;
    InStack[now]=true;
    st.push(now);
    for(int i=0;i&lt;int(e[now].size());i++)
        if(dfn[e[now][i]]==0)
        {
            Tarjan(e[now][i]);
            low[now]=min(low[now],low[e[now][i]]);
        }
        else if(InStack[e[now][i]]==true)
            low[now]=min(low[now],low[e[now][i]]);
    if(low[now]==dfn[now])
    {
        nd_tot++;
        while(st.empty()==false)
        {
            int temp=st.top();
            st.pop();
            belong[temp]=nd_tot;
            InStack[temp]=false;
            cnt[nd_tot]++;
            if(temp==now)
                break;
        }
    }
}
int n,m,S,f[N][2];
int dfs(int now,int back)
{
    if(f[now][back]&gt;=0) return f[now][back];
    int t_ans=0;
    bool OK=false;
    for(int i=0;i&lt;int(e2[now].size());i++)
        if(e2[now][i].to!=S and back-e2[now][i].IsBack&gt;=0)
            t_ans=max(t_ans,dfs(e2[now][i].to,back-e2[now][i].IsBack));
        else if(back&gt;=e2[now][i].IsBack)
            OK=true;
    if(t_ans!=0 or OK==true)
        return f[now][back]=t_ans+cnt[now];
    else
        return f[now][back]=0;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4),
        e2[i].reserve(4);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
    }

    for(int i=1;i&lt;=n;i++)
        if(dfn[i]==0)
            Tarjan(i);
    S=belong[1];
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;int(e[i].size());j++)
            if(belong[i]!=belong[e[i][j]])
            {
                e2[belong[i]].push_back(road(belong[e[i][j]],0));
                e2[belong[e[i][j]]].push_back(road(belong[i],1));
            }

    memset(f,0x80,sizeof f);
    int ans=0;
    for(int i=0;i&lt;int(e2[S].size());i++)
        ans=max(ans,dfs(e2[S][i].to,1-e2[S][i].IsBack));

    printf("%d",ans+cnt[S]);
    return 0;
}

//C++（正解）
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>136</wp:post_id>
		<wp:post_date><![CDATA[2019-02-17 03:02:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-17 03:02:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3119-usaco15jan%e8%8d%89%e9%89%b4%e5%ae%9agrass-cownoisseur]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="dag-dp"><![CDATA[DAG DP]]></category>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e7%bc%a9%e7%82%b9-%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f"><![CDATA[缩点/强连通分量]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[468]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3469] [POI2008]BLO-Blockade (割点)</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/luogu-p3469-poi2008blo-blockade-%e5%89%b2%e7%82%b9/</link>
		<pubDate>Tue, 19 Feb 2019 11:34:22 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=140</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3469">洛谷</a>

<hr />

<h1>Solution</h1>

先跟我大声念：
$\huge poi!$

.

然后开始干正事。
首先，我们先把题目中的点分为两类：<strong>去除这个点能把图分为几个部分的，去除这个点不影响整个图的连通性的。</strong>
如下图：
<img src="https://s2.ax1x.com/2019/02/19/kgraxx.png" alt="kgraxx.png" />
点上的数字表示这个点的搜索序。

我们称这些对连通性有影响的点为<strong>割点</strong>。
先假设我们能求出这些点以及其出去后把图分为几块之后那几块分别的大小。

是不是发现了什么？
对于非割点，答案显然是$2*(n-1)$ (因为它不能影响别的点对连通性，能影响的只是别人到它以及它到别人)

对于割点，它把那几块弄得无法联通，即那几块中不同块的两个点肯定就无法联通了，答案也就是每组块的点的数量互相乘出来，再加上$2*(n-1)$。

接下来就是如何求割点了。
这时候我们又得请出伟大的$Tarjan$了。
先回忆一下求强连通分块的做法，我们这里求割点的做法与其类似。
但有以下几点不同：
1.我们在求low的时候不用讨论所连向的点是否在栈中了，因为无向图中没有横插边的说法（但是要记录当前的父亲，防止我们的low直接计算回去）
2.当一个点的某一个孩子的low>=此点的dfn时，说明这个点就是割点。因为孩子的low大于当前节点的dfn，说明它没有办法直接从当前节点回到搜索树搜过的节点。如果当前节点删除了，此孩子将会分割开来）

至于怎么求每个孩子的size........
（我想这个应该不用说了吧）
就是搜的时候加上去就好，如果不清楚的话看一下代码就懂了。

时间复杂度$O(n)$
完全OjbK

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P3469 [POI2008]BLO-Blockade
//June,11th,2018
//玄幻割点
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
vector &lt;long long&gt; e[N],nd_size[N];
int n,m;
int dfn[N],low[N],IsGD[N],nd_to,size[N];
void Tarjan(int now,int fa)
{
    dfn[now]=low[now]=++nd_to;
    size[now]++;
    int temp=0;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(dfn[e[now][i]]==0)
        {
            Tarjan(e[now][i],now);
            size[now]+=size[e[now][i]];
            low[now]=min(low[now],low[e[now][i]]);
            if(low[e[now][i]]&gt;=dfn[now])
            {
                temp+=size[e[now][i]];
                IsGD[now]=true;
                nd_size[now].push_back(size[e[now][i]]);
            }
        }
        else if(e[now][i]!=fa)
            low[now]=min(low[now],low[e[now][i]]);
    if(IsGD[now]==true and n-temp-1!=0)
        nd_size[now].push_back(n-temp-1);
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
    {
        e[i].reserve(4);
        nd_size[i].reserve(4);
    }
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    Tarjan(1,0);

    for(int i=1;i&lt;=n;i++)
    {
        long long ans=2*(n-1);
        if(nd_size[i].size()!=0 and nd_size[i].size()!=1)
        {
            for(int j=0;j&lt;int(nd_size[i].size());j++)
                for(int k=j+1;k&lt;int(nd_size[i].size());k++)
                    ans+=2*nd_size[i][j]*nd_size[i][k];
        }
        printf("%lld\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>140</wp:post_id>
		<wp:post_date><![CDATA[2019-02-19 11:34:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-19 11:34:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3469-poi2008blo-blockade-%e5%89%b2%e7%82%b9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e7%bc%a9%e7%82%b9-%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f"><![CDATA[缩点/强连通分量]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[641]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-19 11:37:14]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-19 11:37:14]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[poi!]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>后缀自动机(SAM)学习笔记</title>
		<link>https://www.goldenpotato.cn/?p=339</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=339</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>339</wp:post_id>
		<wp:post_date><![CDATA[2019-03-06 15:30:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1613]跑路</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p1613%e8%b7%91%e8%b7%af/</link>
		<pubDate>Fri, 22 Feb 2019 00:55:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=145</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门:<a href="https://www.luogu.org/problemnew/show/P1613">洛咕</a>

<hr />

<h1>Solution</h1>

挺有意思的一道题。

题面已经挺明显的描述出了这题的主要思想：<strong>倍增</strong>。
先这样想，我们可以把这题这样建模：<strong>有一堆点，若两个点之间的距离之和可以达到2的n次方，那么这两个点可以用1的时间相互到达。</strong>
也就是说，<strong>我们把距离能为2的n次方的点对用边权为1的边连上，再做一次最短路径，</strong>就可以求出答案了。

接下来问题就是如何求出每两个点是否能以2的n次方的时间相互到达。
考虑使用DP。
<strong>我们设$f[i][j][k]$ 表示 $i$到$j$是否能以$2$的$k$次方的距离相互到达。</strong>
转移的时候得运用倍增的思想：若两个点能以两端$2$的$k-1$次方的距离相互到达，那么两个点就能以2的k次方的距离相互到。
接下来我们就可以运用<strong>类似Floyd的办法</strong>来处理这个DP，我们可以在最外层枚举这个k，里面三层和Floyd的意义一模一样，就是枚举中转点与起始点。
初始化就是题目中直接相连的两个点，它们的$f[a][b][0]=1$ （它们距离为1,是2的0次方）

时间复杂度： $O(n^3*64)$

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1613 跑路
//June,13th,2018
//倍增+DP+最短路
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50+10;
const int K=65+10;
int f[N][N][K],dis[N][N],n,m;
int main()
{
    n=read(),m=read();
    memset(dis,0x3f,sizeof dis);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        f[s][t][0]=1;
        dis[s][t]=1;
    }

    for(int o=1;o&lt;=64;o++)
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
                for(int k=1;k&lt;=n;k++)
                    if(f[j][i][o-1]==true and f[i][k][o-1]==true)
                    {
                        f[j][k][o]=true;
                        dis[j][k]=1;
                    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            for(int k=1;k&lt;=n;k++)
                dis[j][k]=min(dis[j][k],dis[j][i]+dis[i][k]);

    printf("%d",dis[1][n]);
    return 0;
}

//正解（C++）
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>145</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 00:55:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 00:55:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1613%e8%b7%91%e8%b7%af]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="dag-dp"><![CDATA[DAG DP]]></category>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84"><![CDATA[最短路径]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[487]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>一些坑点</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e4%b8%80%e4%ba%9b%e5%9d%91%e7%82%b9-2/</link>
		<pubDate>Fri, 22 Feb 2019 01:03:37 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=147</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>填坑中</strong>
$\color{blue} {last update ： Jan,21st,2019}$

<hr />

<h1>通用</h1>

$\color {red} {-1.仔细审题*2}$

<ol>
<li>永远要有想法，不要觉得复杂度不对空间就不开够。<strong>空间永远开到最大值（或者说是自己不MLE的极限）</strong>，以免发生复杂度正确但是空间没有开够的惨痛教训（NOI.ac WHZZT 邀请赛R1）</li>
<li>在会爆int的题目中，一定要仔细<strong>检查是否有会爆int的中间变量写了int</strong>。 （from NNEZ_R2_T1）</li>
<li>使用-=时，<strong>把-=后面的东西用括号括起来</strong>，防止可能出现的负负为正等SB错误 (from Luogu P1270)</li>
<li>在需要mod一个数的题目中，要检查输出(printf)时有没有做计算,如果有计算，要括起来再mod一次(Luogu P2679)</li>
<li>使用迭代器时，不要在if中++或--，以免出现奇奇怪怪的顺序问题。 (Luogu P3626)</li>
<li>二分答案/二分时，<strong>不要瞎JB对左端点和右端点优化</strong>，直接取题面的最大值和最小值就好，防止因端点取错而爆炸（from NNEZ_R2_T3）</li>
</ol>

<hr />

<h1>DP</h1>

<ol>
<li>在初始化不是0（0作为极值的情况下），一定要讨论可以取得到的边界条件，否则会听取WA声一片。 (Luogu P1437)</li>
<li>一定要<strong>仔细检查答案应该取哪个状态</strong>。 ([HAOI2008]木棍分割)</li>
</ol>

<hr />

<h1>数论</h1>

<ol>
<li>使用exgcd时，记得检查x，y变量前是否加上了&amp;。 （Luogu P1516）</li>
<li>计算lcm时，先除gcd再乘，以防乘爆 （Luogu P4777）</li>
<li>线性求欧拉函数和莫比乌斯函数时，要注意初始化phi[1]=1或miu[1]=1</li>
<li>写FFT时，记得加上对type的判断，若type=true，则x0=conj(x0);</li>
</ol>

<hr />

<h1>计算几何</h1>

<ol>
<li>求凸包的时候要对x，y都排序，且要去重，在一条直线上也要弹栈（防止全部全在一条直线上的数据）。否则将会在用凸包求其他东西的时候出现奇奇怪怪的问题。</li>
<li>旋转卡壳一定要特判n==2的情况。</li>
</ol>

<hr />

<h1>数据结构</h1>

<ol>
<li>并查集中在求需要父亲的地方，请直接调用函数，而不要相信你路径压缩过的fa[x]，直接调用的话有可能因为各种各样奇怪的原因导致你取到的不是最终父亲。(from Luogu P2170)</li>
<li>线段树pushdown的时候记得特判叶子节点的情况，否则会RE到飞起 （NOI2015 软件包管理器）</li>
<li>圆方树一定要开2倍空间（来存额外的方点） ([BeiJing2013]压力)</li>
<li>小心线段树的常数 (NNEZ noip2018R2 T1)</li>
<li>splay<strong>查询时也要splay</strong>以保证势能分析有效 ([Luogu P4197] Peaks )</li>
</ol>

<hr />

<h1>图论</h1>

<ol>
<li>Dinic在分层时记得$vis[S]=true;$ (P4174 [NOI2006]最大获利)</li>
<li>在多组数据时，Tarjan的栈一定要清空，防止一些偶然事件 (Uva610)</li>
</ol>

<hr />

<h1>字符串</h1>

<ol>
<li>SAM要开<strong>两倍空间</strong>。 (Luogu P3975[TJOI]弦论)</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>147</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 01:03:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 01:03:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e4%ba%9b%e5%9d%91%e7%82%b9-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>1</wp:is_sticky>
										<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2423]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[一只蒟蒻]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.16.62.254]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-26 14:12:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-26 14:12:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>9</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[116.252.221.146]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-02-26 15:01:39]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-02-26 15:01:39]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[stO lbc Orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>8</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[orion]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1211584869@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[223.104.22.231]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-04 10:38:20]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-04 10:38:20]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.139.211.148]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-04 10:47:17]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-04 10:47:17]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>13</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>15</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.139.211.148]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-04 23:46:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-04 23:46:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Orz %%%]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>8</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>43</wp:comment_id>
			<wp:comment_author><![CDATA[Woshiluo]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[woshiluo@woshiluo.site]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[49.118.167.216]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-05-02 14:22:54]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-05-02 14:22:54]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[啊啊啊wq为什么特色图片是星奏啊]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>44</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.139.133.188]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-05-02 15:34:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-05-02 15:34:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:huaji9:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>43</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>45</wp:comment_id>
			<wp:comment_author><![CDATA[Woshiluo]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[woshiluo@woshiluo.site]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[144.34.251.243]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-05-02 16:22:29]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-05-02 16:22:29]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我还不容易脱离新岛夕给我下的套...

你又给我拾回来了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>44</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>59</wp:comment_id>
			<wp:comment_author><![CDATA[lemir3]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dogb2333@outlook.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.139.95.226]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-07-07 09:27:20]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-07-07 09:27:20]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>60</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-07-07 15:44:06]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-07-07 15:44:06]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:huaji9:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>59</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P2261] [CQOI2007]余数求和</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p2261-cqoi2007%e4%bd%99%e6%95%b0%e6%b1%82%e5%92%8c/</link>
		<pubDate>Fri, 22 Feb 2019 01:08:07 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=149</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2261">洛谷</a>

<hr />

<h1>Solution</h1>

这题显然有一个$O(n)$的直接计算法，$60$分到手。

接下来我们就可以拿出草稿纸推一推式子了
首先，取模运算在这里很不和谐，我们得转换一下。
对于任意取模计算，我们都有：
<img src="https://s2.ax1x.com/2019/02/22/kWRzLj.png" alt="kWRzLj.png" />
 所以，我们可以做以下推算
<img src="https://s2.ax1x.com/2019/02/22/kWW9wn.png" alt="kWW9wn.png" />
经过一些手算，我们发现$k/i$(向下取整)是由一段一段的区间组成的，如下图
<img src="https://s2.ax1x.com/2019/02/22/kWWCoq.png" alt="kWWCoq.png" />

显然，每段区间的右端点可以通过二分的方法来找
对于每一段区间，我们可以把k/i提出来，括号里面就变成了（i+(i+1)+(i+2)+(i+3)+.....+右端点） 直接用等差数列来算就好

时间复杂度我不会算XD　　

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P2261 [CQOI2007]余数求和
//Jul,7th
//取模运算推一推
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int main(int argc, char **argv)
{
    //freopen("sum.in","r",stdin);
    //freopen("sum.out","w",stdout);
    long long n,K;
    scanf("%lld%lld",&amp;n,&amp;K);

    long long ans=n*K;
    for(long long i=1;i&lt;=n;i++)
    {
        long long temp=K/i;
        long long l=i,r=n,mid,nxt=i;
        while(l&lt;=r)
        {
            mid=(l+r)/2;
            if(K/mid==temp)
                nxt=max(nxt,mid),l=mid+1;
            else
                r=mid-1;
        }
        ans-=(((i+nxt)*(nxt-i+1))/2)*temp;
        i=nxt;
    }

    printf("%lld",ans);
    return 0;
}

//正解（C++）
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>149</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 01:08:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 01:08:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2261-cqoi2007%e4%bd%99%e6%95%b0%e6%b1%82%e5%92%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[397]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1122]最大子树和</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p1122%e6%9c%80%e5%a4%a7%e5%ad%90%e6%a0%91%e5%92%8c/</link>
		<pubDate>Fri, 22 Feb 2019 01:26:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=152</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P1122">洛谷</a>

<hr />

<h1>Solution</h1>

这是一道简单的树形DP题。
首先，我们可以转换一下题面，可以发现，题目要求我们求出一颗树上的最大联通子图。
因为我们是在树上取的，实际上就是取一颗子树。
这个就是最基础的树形DP模型了。

我们可以设f[i]表示我们选的子图以i为根所能取的子树的最大值。
转移是：
$f[i] = beauty[i] + xigema(max(f[j],0))$
（也就是一颗树的孩子所能取的子树，如果它孩子为根的子树>0，就取它，否则不取）
答案就是最大的$f[i]$

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1122 最大子树和
//Jul,30th,2018
//树形DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=16000+100;
const int inf=0x3f3f3f3f;
vector &lt;int&gt; e[N];
int n,beauty[N];
long long f[N];
bool vis[N];
long long dfs(int x)
{
    f[x]=beauty[x];
    vis[x]=true;
    for(int i=0;i&lt;int(e[x].size());i++)
        if(vis[e[x][i]]==false)
            f[x]=max(f[x],f[x]+dfs(e[x][i]));
    return f[x];
}
int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;=n;i++)
        beauty[i]=read();
    for(int i=1;i&lt;n;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    dfs(1);

    long long ans=-inf;
    for(int i=1;i&lt;=n;i++)
        ans=max(ans,f[i]);
    printf("%lld",ans);
    return 0;
}

//正解(C++)
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>152</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 01:26:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 01:26:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1122%e6%9c%80%e5%a4%a7%e5%ad%90%e6%a0%91%e5%92%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%bd%a2dp"><![CDATA[树形DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[439]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2014]选课</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p2014%e9%80%89%e8%af%be/</link>
		<pubDate>Fri, 22 Feb 2019 01:30:50 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=154</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2014">洛谷</a>

<hr />

<h1>Solution</h1>

这是一道十分经典的树形DP题，这种类型的树形DP有一种很普遍的解法。

首先，观察题目，我们把这道题转换一下：给定一颗树，选出包含1号节点（根)的一颗子树，使得点权和最大。
我们可以这样子定义状态：
设$f[i][j]$ 表示以i为根节点的子树，选出j个节点，所能达到的最大点权值。

对于二叉树来说，转移很显然，就是枚举左子树分配多少个节点，就可以对应的得出右子树能分配到多少个节点，对所有情况取最大值就好。
对于多叉树来说，问题就没有那么简单了，这里，我们有两个方案可以解决这个问题：
一是多叉树转二叉树，
二是树上背包。

<del>因为我不会多叉树转二叉树，</del>所以在这里我主要讲一讲第二种方法。
我们一般在树上做的是多重背包问题。
我以本题为例子，讲一下树上如何做多重背包。
首先，<strong>我们肯定要一层循环枚举子树(可以类似为背包问题中枚举第几件物品)。</strong>
<strong>第二层循环我们得枚举当前以节点的子树能分配的节点数（可以类似为背包问题中枚举背包容量）</strong>
<strong>(这一层循环一定要从后往前枚举，类似与背包压在一维做的做法)</strong>
<strong>第三层循环我们就可以枚举当前子树分配多少个节点了（可以类似多重背包中枚举第i件物品要几件）</strong>

下面是这种枚举在这道题应用的代码：

<pre><code class="language-cpp ">for(int i=0;i&lt;int(e[x].size());i++)//枚举子树
    {
        int temp=dfs(e[x][i]);//先把子树的f递归下去算出来
        tot+=temp;//tot记录到当前子树为止总节点数
        for(int j=tot;j&gt;=1;j--)//枚举自己这颗树的总分配数
            for(int k=0;k&lt;=temp;k++)//枚举子树分配多少个节点
                if(j-k&gt;=1)
                    f[x][j]=max(f[x][j],f[x][j-k]+f[e[x][i]][k]);
    }
</code></pre>

树上背包一般看上去是三重循环，非常恐怖。
但事实上，根据一堆证明（不会证），其复杂度为两重循环。
<del>所以复杂度应该是O（能过）</del>
复杂度是$O(N<em>N</em>M)$

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=300+10;
vector &lt;int&gt; e[N];
long long n,m,f[N][N],v[N];
int dfs(int x)
{
    int tot=1;
    f[x][1]=v[x];
    for(int i=0;i&lt;int(e[x].size());i++)
    {
        int temp=dfs(e[x][i]);
        tot+=temp;
        for(int j=tot;j&gt;=1;j--)
            for(int k=0;k&lt;=temp;k++)
                if(j-k&gt;=1)
                    f[x][j]=max(f[x][j],f[x][j-k]+f[e[x][i]][k]);
    }
    return tot;
}
int main()
{
    n=read(),m=read();
    for(int i=0;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;=n;i++)
    {
        e[read()].push_back(i);
        v[i]=read();
    }

    dfs(0);

    printf("%lld",f[0][m+1]);
    return 0;
}

//正解(c++)
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>154</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 01:30:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 01:30:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2014%e9%80%89%e8%af%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%bd%a2dp"><![CDATA[树形DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[440]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1450] [HAOI2008]硬币购物</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/luogu-p1450-haoi2008%e7%a1%ac%e5%b8%81%e8%b4%ad%e7%89%a9/</link>
		<pubDate>Fri, 22 Feb 2019 01:35:37 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=156</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P1450">洛谷</a>

<hr />

<h1>Solution</h1>

这是一道很有意思的在背包里面做容斥的题目。

首先，我们可以很轻松地想到暴力做背包的做法。
就是对于每一次询问，我们都做一次背包。
复杂度$O(tot<em>s</em>log(di))$ (使用二进制背包优化)
显然会T得起飞。

接下来，我们可以换一种角度来思考这个问题。
首先，我们可以假设没有每个物品的数量的限制，那么这样就会变成一个很简单的完全背包问题。
至于完全背包怎么写，我们在这里就不做过多讨论，如有需要，看看代码就能理解了。
完全背包做完后，我们可以得到一个$f[i]$表示填满i的背包的方案数的数组。

那么，我们接下来可以用容斥来解决不可行的方案的问题。
假设只有1件物品的使用次数超出了所给的数量，假设这件物品是第x件。
那么可以用 $f[s-(d[x]+1)*c[x]]$ 表示这件物品不可行的方案总数。

因为对于花钱数为$s-(d[x]+1)<em>c[x]$ 里面的每一种方法，都可以通过使用购买$d[x]+1$件的$x$物品来超出所给的数量。所以 $f[s-(d[x]+1)</em>c[x]]$ 可以表示该物品不可行方案总数。

那么答案是四件物品不可行方案总数这和吗？

nope
因为我们会重复减去一些东西。例如：一种方案即超出了第一件物品的使用数，也超出了第二件物品的使用数，我们却重复扣除了这种方案两次。
所以说我们这时候就得使用容斥来解决这个问题。
容斥中有一个很基础的定理（我不会证）：
<strong>对于有n的限制条件的事件，只要其中符合一个条件就算可行，其可行方案总数为：</strong>
<strong>（符合其中0个（条件的方案数，后同）-符合其中1个+符合其中2个-符合其中3个+符合其中4个-符合其中5个+符合其中6个....）</strong>

那么，我们就可以根据这个定理求出不可行的方案总数。
对于这题来说，代码如下:

<pre><code class="language-cpp ">for(a[1]=0;a[1]&lt;=1;a[1]++)
            for(a[2]=0;a[2]&lt;=1;a[2]++)
                for(a[3]=0;a[3]&lt;=1;a[3]++)
                    for(a[4]=0;a[4]&lt;=1;a[4]++)
                    {
                        int cnt=0,t_s=s;
                        for(int j=1;j&lt;=4;j++)
                            if(a[j]==1) cnt++,t_s-=(d[j]+1)*c[j];
                        if(cnt%2==0) cnt=1;
                        else cnt=-1;

                        if(t_s&gt;=0)
                            ans=ans+cnt*f[t_s];
                    }
</code></pre>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P1450 [HAOI2008]硬币购物
//Aug,27th,2018
//DP+容斥
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+1000;
long long f[N];
int n,m;
long long c[5],d[5];
int main(int argc, char **argv)
{
    for(int i=1;i&lt;=4;i++)
        c[i]=read();
    m=read();

    f[0]=1;
    for(int j=1;j&lt;=4;j++)
        for(int i=c[j];i&lt;=100000;i++)
            f[i]+=f[i-c[j]];
    for(int i=1;i&lt;=m;i++)
    {
        for(int j=1;j&lt;=4;j++)
            d[j]=read();
        int s=read(),a[5];
        long long ans=0;
        for(a[1]=0;a[1]&lt;=1;a[1]++)
            for(a[2]=0;a[2]&lt;=1;a[2]++)
                for(a[3]=0;a[3]&lt;=1;a[3]++)
                    for(a[4]=0;a[4]&lt;=1;a[4]++)
                    {
                        int cnt=0,t_s=s;
                        for(int j=1;j&lt;=4;j++)
                            if(a[j]==1) cnt++,t_s-=(d[j]+1)*c[j];
                        if(cnt%2==0) cnt=1;
                        else cnt=-1;

                        if(t_s&gt;=0)
                            ans=ans+cnt*f[t_s];
                    }

        printf("%lld\n",ans);
    }
    return 0;
}

//正解(c++)
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>156</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 01:35:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 01:35:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1450-haoi2008%e7%a1%ac%e5%b8%81%e8%b4%ad%e7%89%a9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%ae%b9%e6%96%a5"><![CDATA[容斥]]></category>
		<category domain="category" nicename="%e8%83%8c%e5%8c%85dp"><![CDATA[背包DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[445]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3626] [APIO2009] 会议中心</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/luogu-p3626-apio2009-%e4%bc%9a%e8%ae%ae%e4%b8%ad%e5%bf%83/</link>
		<pubDate>Fri, 22 Feb 2019 04:26:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=160</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3626">洛谷</a>

<hr />

<h1>Solution</h1>

如果题目只要求求出第一问，那这题显然就是大水题。
但是加上第二问的话.......那这题就成为大（du）火（liu）题了。

对于第一问：求一整个区间的最大线段总数，我们可以很轻松的切掉。
怎么处理第二问呢？
我们可以考虑这样做：
对于一条线段，如果它属于答案的一部分，那么它一定会有以下性质：
<strong>区间③的最大线段数 = 区间①的最大线段数 + 区间②的最大线段数 + 1（当前线段）</strong> （区间最大线段数指用传统贪心方法求出的一段区间的可能的最多的线段的数量）
<a href="https://imgchr.com/i/kWqzOx"><img src="https://s2.ax1x.com/2019/02/22/kWqzOx.md.png" alt="kWqzOx.md.png" /></a>

那怎么求一段区间的最大线段数呢？
第一想法是前缀和？看起来很OK？
nope
因为不同区间中，里面的的初始线段会不同，以下这个图可以简单说明这种情况
<img src="https://s2.ax1x.com/2019/02/22/kWLpm6.png" alt="kWLpm6.png" />

但是，我们可以发现一个很重要的特点：
<strong>每条线段的下一条可行线段是固定的</strong>
有了这个特点，我们就可以对路径做倍增，就可以在log的时间求出某一个区间的线段数。
至于求每一个区间的第一条线段，我们可以用set+lowbound的方法找。

这样子，你就可以嘴巴AC这道题啦
<del>实际上你会花费大量的时间来调这道毒瘤题</del>

<hr />

<h1>Code</h1>

<del>（我常数太大，开O2才能卡过（set太辣鸡））</del>

<pre><code class="language-cpp ">// luogu-judger-enable-o2
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=200000+100;
struct line
{
    int l,r,no;
    friend bool operator &lt; (line A,line B)
    {
        return A.l&lt;B.l;
    }
}l[N];
bool cmp(line A,line B)
{
    if(A.l==B.l)
    {
        if(A.r!=B.r)
            return A.r&gt;B.r;
        else
            return A.no&gt;B.no;
    }
    return A.l&lt;B.l;
}
bool cmp2(line A,line B)
{
    return A.no&lt;B.no;
}
int n,ans,root,fa[N][20+2];
bool use[N],vis[N];
stack &lt;int&gt; ms;
set &lt;line&gt; mset;
set &lt;line&gt; used;
vector &lt;int&gt; e[N];
void dfs(int now,int FA)
{
    vis[now]=true;
    fa[now][0]=FA;
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
            dfs(e[now][i],now);
}
int POW[21];
int Count(int L,int R)
{
    line temp; temp.l=L;
    set&lt;line&gt;:: iterator t=mset.lower_bound(temp);
    if((*t).r &gt; R) return 0;
    int now=(*t).no,ans=1;
    for(int i=20;i&gt;=0;i--)
        if(l[fa[now][i]].r&lt;=R and fa[now][i]!=0)
            now=fa[now][i],ans+=POW[i];
    return ans;
}
int main()
{
    //freopen("center.in","r",stdin);
    //freopen("center.out","w",stdout);

    n=read();
    for(int i=1;i&lt;=n;i++)
        l[i].l=read(),l[i].r=read(),l[i].no=i;

    sort(l+1,l+1+n,cmp);
    memset(use,1,sizeof use);
    for(int i=1;i&lt;=n;i++)
    {
        while(ms.empty()==false and l[ms.top()].r&gt;=l[i].r)
        {
            use[ms.top()]=false;
            ms.pop();
        }
        ms.push(i);
    }
    int to=-1;
    for(int i=1;i&lt;=n;i++)
        if(use[i]==true and l[i].l&gt;to)
        {
            ans++;
            to=l[i].r;
        }
    for(int i=1;i&lt;=n;i++) e[i].reserve(4);
    for(int i=1;i&lt;=n;i++)
        if(use[i]==true)
        {
            //cerr&lt;&lt;l[i].no&lt;&lt;" ";
            mset.insert(l[i]);
            bool OK=false;
            for(int j=i+1;j&lt;=n;j++)
                if(use[j]==true and l[j].l&gt;l[i].r)
                {
                    e[l[j].no].push_back(l[i].no);
                    OK=true;
                    break;
                }
            if(OK==false)
                e[0].push_back(l[i].no);
        }
    printf("%d\n",ans);    

    dfs(0,0);
    sort(l+1,l+1+n,cmp2);
    for(int i=0;i&lt;=20;i++)
        POW[i]=1&lt;&lt;i;
    l[0].r=0x3f3f3f3f;
    line tt;
    tt.l=-1,tt.r=-1,tt.no=0; mset.insert(tt),used.insert(tt);
    tt.l=0x3f3f3f3f,tt.r=0x3f3f3f3f;mset.insert(tt),used.insert(tt);
    for(int i=1;i&lt;=n;i++)
    {
        int L,R;
        set&lt;line&gt;:: iterator t=used.lower_bound(l[i]);
        if((*t).l&lt;=l[i].r) continue;
        R=(*t).l-1;
        t--;
        if((*t).r&gt;=l[i].l) continue;
        L=(*t).r+1;
        if(Count(L,l[i].l-1)+Count(l[i].r+1,R)==Count(L,R)-1)
        {
            printf("%d ",i);
            used.insert(l[i]);
        }
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>160</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 04:26:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 04:26:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3626-apio2009-%e4%bc%9a%e8%ae%ae%e4%b8%ad%e5%bf%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="set"><![CDATA[set]]></category>
		<category domain="category" nicename="%e5%80%8d%e5%a2%9e"><![CDATA[倍增]]></category>
		<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="category" nicename="%e5%a0%86"><![CDATA[堆]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[433]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3986] 斐波那契数列</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p3986-%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97/</link>
		<pubDate>Fri, 22 Feb 2019 04:31:00 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=162</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="ttps://www.luogu.org/problemnew/show/P3986">洛谷</a>

<hr />

<h1>Solution</h1>

这是一道很有意思的数论题。
首先，我们可以发现直接枚举a和b会T的起飞。

接下来，我们就可以观察一下式子了，我们略微手算一下，就会有这样的结果：
<img src="https://s2.ax1x.com/2019/02/22/kWLV1A.png" alt="kWLV1A.png" />

我们可以发现，a，b在每一项中的数量都可以用同一个斐波那契数列表示。
我们可以用$g[x]$表示斐波那契数列的第x项，那么，我们可以得到$f[x]=a<em>g[x-1]+b</em>g[x]$

接下来，由常识可以知道，斐波那契数列的第40项就差不多有10^9那么大了。
所以说，我们可以考虑枚举当前项x，问题就变为了有多少个$a，b$使得 $K=a<em>g[x-1]+b</em>g[x]$
移项得：$b=(K-g[x-1]*a)/g[x]$

因为$a，b$都是整数，问题就变为了有多少个$a$，使得$K-g[x-1]*a$能被$g[x]$整除
即：
<a href="https://imgchr.com/i/kWLZ6I"><img src="https://s2.ax1x.com/2019/02/22/kWLZ6I.png" alt="kWLZ6I.png" /></a>

对于斐波那契数列，有一个定理，就是$f[x]$与$f[x-1]$互质（证明略复杂，在这里就不给出了），这样就保证了同余方程有解。
同时，我们还有一个限制，就是$ K-g[x-1]*a > 0 $(因为b>0)即$ a&lt;K/g[x-1] $的

由这两个式子，我们就可以求出对于每一个$x$，有多少个$a，b$可以使得$K=a<em>g[x-1]+b</em>g[x]$

.

酱紫，我们就可以AC这道题(≧∀≦)♪

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=45;
const int n=40+2;
const int poi=1000000007;
long long f[N],K,ans;
long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)
{
    if(B==0)
    {
        x=1,y=0;
        return A;
    }
    long long temp=exgcd(B,A%B,x,y),tx=x;
    x=y,y=tx-(A/B)*y;
    return temp;
}
long long inv(long long A,long long POI)
{
    long long t,tt;
    exgcd(A,POI,t,tt);
    return (t%POI+POI)%POI;
}
int main()
{
    scanf("%lld",&amp;K); 

    f[1]=f[2]=1;
    for(int i=3;i&lt;=n;i++)
        f[i]=f[i-1]+f[i-2];
    for(int i=2;i&lt;=n;i++)
    {
        long long a=(K*inv(f[i-1],f[i]))%f[i],to=K/f[i-1]-1;
        if(a&lt;to)
        {
            if(a==0) ans--;
            ans=(ans+1+(to-a)/f[i])%poi;
        }
    }

    printf("%lld",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>162</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 04:31:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 04:31:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3986-%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[388]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3959] 宝藏</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p3959-%e5%ae%9d%e8%97%8f/</link>
		<pubDate>Fri, 22 Feb 2019 04:34:44 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=164</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3959">洛谷</a>

<hr />

<h1>Solution</h1>

这道题的是一道很巧妙的状压DP题。
首先，看到数据范围，应该状压DP没错了。

根据我们之前状压方程的设计经验，我们很快就能设计出这样的方程：
设$f[i][j]$表示用到第i个元素，当前连接状态为j的开销的min
但是我们很快就会发现，这个方程没法转移，因为随着连接方案的不同，新插入的点的K值会不同。

怎么办呢？
这时候我们可以重新设计一个巧妙的的状态。
重新阅读题目，我们可以发现题目中的<strong>K值可以理解为距离初始点的“层数”</strong>，下面这幅图可以简单的表示出来:
<a href="https://imgchr.com/i/kWLG1s"><img src="https://s2.ax1x.com/2019/02/22/kWLG1s.md.png" alt="kWLG1s.md.png" /></a>

那么，我们可以考虑这样子设状态：
设$f[i][j]$表示到第$i$层，总共取了的点的状态为$j$。
这样的话，转移就可以取出来了：
$f[i][j]=MIN(f[i-1][k]+trans[k][j]*(i-1))$ (k为j的子集，即有可能转移到j的状态) (trans[k][j]表示从状态k转移到状态j的最小花费的路程)
trans需要暴力预处理出来。

怎么枚举子集呢？
如果$2^n$枚举就会T掉，因为我们枚举到了非子集的情况。
这里就引出了枚举子集的小技巧
对于状态x，它的子集为：$p=x,p!=0,p=(p-1)\&amp;x $  (至于怎么证明，这里就不给出了，在草稿上推一推就会发现里面的精妙了)

答案就是$min(f[i][2^{n-1}])$，初始化$f[1][2^{i-1}]=0 (i∈[1,n])$

就酱，这道题就被我们切掉啦φ(>ω&lt;*)

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P3959 宝藏 
//Sep,5th,2018
//状压DP+枚举子集小技巧
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=12+2;
const int M=1&lt;&lt;N;
int n,m,dis[N][N],trans[M][M],POW[N];
long long f[N][M];
int main()
{
    n=read(),m=read();
    memset(dis,0x3f,sizeof dis);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read(),v=read();
        if(dis[s][t]&gt;v)
            dis[s][t]=dis[t][s]=v;
    }

    m=(1&lt;&lt;n);
    POW[0]=1;
    for(int i=1;i&lt;=n;i++)
        POW[i]=POW[i-1]*2;
    for(int i=0;i&lt;m;i++)
        for(int j=i;j!=0;j=(j-1)&amp;i)
        {
            bool OK=true;
            int temp=i^j;
            for(int k=n-1;k&gt;=0;k--)
                if(temp&gt;=POW[k])
                {
                    int tmin=0x3f3f3f3f;
                    for(int o=1;o&lt;=n;o++)
                        if((POW[o-1]&amp;j)==POW[o-1])
                            tmin=min(tmin,dis[o][k+1]);
                    if(tmin==0x3f3f3f3f)
                    {
                        OK=false;
                        break;
                    }
                    trans[j][i]+=tmin;
                    temp-=POW[k];
                }
            if(OK==false)
                trans[j][i]=0x3f3f3f3f;
        }

    /*cerr&lt;&lt;endl&lt;&lt;endl;
    for(int i=0;i&lt;m;i++)
        for(int j=0;j&lt;m;j++)
            if(trans[i][j]!=0x3f3f3f3f and trans[i][j]!=0)
                cerr&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;trans[i][j]&lt;&lt;endl;*/

    memset(f,0x3f,sizeof f);
    for(int i=1;i&lt;=n;i++)
        f[1][POW[i-1]]=0;
    for(int i=2;i&lt;=n;i++)
        for(int j=0;j&lt;m;j++)
            for(int k=j;k!=0;k=(k-1)&amp;j)
                if(trans[k][j]!=0x3f3f3f3f)
                    f[i][j]=min(f[i][j],f[i-1][k]+(i-1)*trans[k][j]);

    long long ans=0x3f3f3f3f3f3f3f3fll;
    for(int i=1;i&lt;=n;i++)
        ans=min(ans,f[i][m-1]);
    printf("%lld",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>164</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 04:34:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 04:34:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3959-%e5%ae%9d%e8%97%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%8a%b6%e5%8e%8bdp"><![CDATA[状压DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[468]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1066] 2^k进制数</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p1066-2k%e8%bf%9b%e5%88%b6%e6%95%b0/</link>
		<pubDate>Fri, 22 Feb 2019 04:39:53 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=166</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P1066">洛谷</a>

<hr />

<h1>Solution</h1>

这是一道神奇的题目，我们有两种方法来处理这个问题，一种是DP，一种是组合数。
<strong>这题需要高精度，以下省略此声明</strong>

.

<h3>DP</h3>

如果你对数学不感兴趣/喜欢写DP/<del>(不想虐待自己)</del>，这里是DP做法。

首先，我们可以发现，这个数最多有$w/k$位(向上取整),如下图所示：
<img src="https://s2.ax1x.com/2019/02/22/kWLNn0.png" alt="kWLNn0.png" />
那么，我们就可以以这个特性做DP啦。
设$f[i][j]$表示枚举到第i位(指2^k进制下的)，最后一位数为j。
$f[i][j] = ∑ f[i-1][k] ((j==0\ and\ k==0)\ or\ k&lt;j) $
这里的k显然是可以用前缀和优化的

初始化 $f[1][i]=1$ (i=0~2^(w%k)-1)

当然，还有一些小细节:f[倒数第2/第1个][0]=0

答案为$∑f[w/k][i] $
（因为我没写过DP做法，这个做法纯口胡，如有错误请通知蒟蒻博主）

<h3>组合数</h3>

那....组合数呢？

事实上，这题的组合数做法的确很妙，（当然也有不少细节）
假设我们枚举了第一位数，那么后面位数的方案数是可以通过组合数来计算出来的。
<strong>因为后面的数要比第一位大，那么后面的数相当于从 [第一位数+1,2^k-1] 这个数的区间中选出x个数（x为后面的位数数量）来 （因为每一种方案都可以通过摆成升序满足题目要求）。</strong>

但是考虑到有可能有若干个前导零，我们还要枚举第一个位数从哪开始。
因为枚举了前导零，我们枚举第一位数时应该从1开始（从0开始会有重复）

这样子，答案为:
<a href="https://imgchr.com/i/kWL0NF"><img src="https://s2.ax1x.com/2019/02/22/kWL0NF.png" alt="kWL0NF.png" /></a>

<del>(事实上口胡起来简单，写起来还有很多细节，这得亲自体会然后就会感到这题的毒瘤)</del>

.

就酱，我们就可以切掉<del>嘴巴AC</del>出这道题啦(～￣▽￣)～

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
struct Int128
{
    static const int N=500;
    int a[N],len;
    Int128()
    {
        memset(a,0,sizeof a);
        len=0;
    }
    void Print()
    {
        for(int i=len;i&gt;=1;i--)
            printf("%d",a[i]);
    }
    friend Int128 operator * (Int128 A,int B)
    {
        for(int i=1;i&lt;=A.len;i++)
            A.a[i]*=B;
        bool IsFullZero=true;
        for(int i=1;i&lt;=A.len;i++)
        {
            if(A.a[i]&gt;=10)
            {
                A.a[i+1]+=A.a[i]/10,A.a[i]%=10;
                if(i==A.len and A.a[i+1]!=0)
                    A.len++;
            }
            if(A.a[i]!=0) IsFullZero=false;
        }
        if(IsFullZero==true) A.len=1;
        return A;
    }
    friend Int128 operator / (Int128 A,int B)
    {
        Int128 ans;
        int temp=0;
        for(int i=A.len;i&gt;=1;i--)
        {
            temp=temp*10+A.a[i];
            if(temp&gt;=B)
            {
                ans.a[i]=temp/B,temp=temp%B;
                ans.len=max(ans.len,i);
            }
        }
        return ans;
    }
    friend Int128 operator + (Int128 A,Int128 B)
    {
        if(A.len&lt;B.len) swap(A,B);
        for(int i=1;i&lt;=A.len;i++)
        {
            A.a[i]=A.a[i]+B.a[i];
            if(A.a[i]&gt;9)
            {
                A.a[i+1]++;A.a[i]-=10;
                if(i==A.len)
                    A.len++;
            }
        }
        return A;
    }
};
const int N=1&lt;&lt;(9+1);
Int128 C[N];
int n,x,K,w,first,m;
int main()
{
    scanf("%d%d",&amp;K,&amp;w);

    first=1&lt;&lt;(w%K),x=w/K;
    if(w%K==0) 
        first=1&lt;&lt;K,x--;
    m=1&lt;&lt;K;


    Int128 ans;
    for(int j=0;j&lt;=x-1;j++)
    {
        int tx=x-j;
        memset(C[tx].a,0,sizeof C[tx].a);
        C[tx].a[1]=1,C[tx].len=1;
        for(int i=tx+1;i&lt;=m;i++)
        {
            memset(C[i].a,0,sizeof C[i].a);
            C[i]=(C[i-1]*i)/(i-tx);
        }
        if(j!=0) first=m;
        for(int i=1;i&lt;m and i&lt;first;i++)
        {
            if(m-1-i&lt;tx) break;
            ans=ans+C[m-1-i];
        }
        //ans.Print();
        //cerr&lt;&lt;endl;
    }

    ans.Print();
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>166</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 04:39:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 04:39:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1066-2k%e8%bf%9b%e5%88%b6%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[511]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2827] 蚯蚓</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e6%a8%a1%e6%8b%9f/luogu-p2827-%e8%9a%af%e8%9a%93/</link>
		<pubDate>Fri, 22 Feb 2019 04:44:49 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=168</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面：</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2827">洛谷</a>

<hr />

<h1>Solution</h1>

看到这题，我们肯定会有一个大胆想法。
那就是直接用堆模拟这个过程。
对于q，我们只需要在堆中多维护一个T,记录每个点插入的时间，在新的元素插入时直接计算所比较的点的当前长度就可以完成插入了。
时间复杂度$O(M*log(M))$
这样的做法只能获得65-70分，因为后面的数据非常大。

所以说，我们要另寻他路。
首先，我们经过看题解手玩可以发现一个很显然但是很重要的结论：
在$q=0$的时候，一条线段所分裂出来的两条线段肯定要比它更小的线段分裂出来的对应的两条线段更大。

<blockquote>
  证明十分简单，设x，y为两条分裂前的线段，且x>y
  那么，较长的那一条(假设p>0.5(p为分割点)) 为： px 与 py， 显然，px>py
  同理可证另一条线段也有这种关系。
</blockquote>

根据这个关系，我们可以考虑这样的做法：
我们开三个队列，<strong>第一个队列放入排好序的原序列，第二个队列放每次分裂出来的较长的蚯蚓，第三个放每次分裂出来的较短的蚯蚓。</strong>
那么根据刚才的证明，我们可以得出，<strong>第二个与第三个队列一定是有序的</strong>，因为我们每次取的蚯蚓一定比之前取的更短，所以分裂出来的肯定比比之前分裂出来的蚯蚓更短。
这样子，我们就可以模拟这个过程，每次取三个队列中最大的那一个，并把分裂出来的对应放到第二第三个队列的末尾就好。

事实上，对于$q>0$的情况，这个推论也是成立的。

<blockquote>
  首先，我们可以假设出来x与y分别是分裂前的线段长度且x>y,假设x与y之间间隔的时间为T
  那么，在y分裂的时刻，x分裂出来的线段较长的长度为(假设p>0.5)：
  $px+T<em>q $ 
  y分裂出来的较长的线段长度为： $(y+T</em>q)<em>p = py + T</em>q<em>p $
  显然 $ px+T</em>q > py + T<em>q</em>p$
</blockquote>

所以说，我们刚刚的结论在这里也是成立的。
对于在某一时刻的线段的具体长度，<strong>我们可以通过在队列中多记录一个插入时间，这样就可以算出某一时刻的某条线段的具体长度了。</strong>

时间复杂度$O（nlogn+m）$

.

就酱，我们就可以AC这道题啦(≧ω≦)/

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P2827 蚯蚓
//Sep,9th,2018
//巧妙的三个队列
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int M=7000000+N+2000;
int a[M],n,m,q,u,v,t;
struct worm
{
    int T,s;
    worm (int A,int B)
    {
        s=A,T=B;
    }
    inline int GetLen(int mtime)//mtime秒后的长度
    {
        return s+(mtime-T)*q;
    }
};
queue &lt;worm&gt; A,B,C;
double p;
bool cmp(int x,int y)
{
    return x&gt;y;
}
int main()
{
    n=read(),m=read(),q=read(),u=read(),v=read(),t=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();

    sort(a+1,a+1+n);
    for(int i=n;i&gt;=1;i--)
        A.push(worm(a[i],0));
    for(int i=1;i&lt;=m;i++)
    {
        long long from=-1,t_MAX=-0x3f3f3f3f;
        if(A.empty()==false) from=1,t_MAX=A.front().GetLen(i-1);
        if(B.empty()==false and B.front().GetLen(i-1)&gt;t_MAX) from=2,t_MAX=B.front().GetLen(i-1);
        if(C.empty()==false and C.front().GetLen(i-1)&gt;t_MAX) from=3,t_MAX=C.front().GetLen(i-1);
        int px=(t_MAX*u)/v,t_px=t_MAX-px;
        B.push(worm(max(px,t_px),i));
        C.push(worm(min(px,t_px),i));
        if(from==1) A.pop();
        else if(from==2) B.pop();
        else C.pop();
        if(i%t==0)
            printf("%lld ",t_MAX);
    }
    printf("\n");

    n=0;
    while(A.empty()==false)
        a[++n]=A.front().GetLen(m),A.pop();
    while(B.empty()==false)
        a[++n]=B.front().GetLen(m),B.pop();
    while(C.empty()==false)
        a[++n]=C.front().GetLen(m),C.pop();
    sort(a+1,a+1+n,cmp);
    for(int i=1;i&lt;=n;i++)
        if(i%t==0)
            printf("%d ",a[i]);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>168</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 04:44:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 04:44:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2827-%e8%9a%af%e8%9a%93]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%a8%a1%e6%8b%9f"><![CDATA[模拟]]></category>
		<category domain="category" nicename="%e6%a8%a1%e6%8b%9f"><![CDATA[模拟]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[385]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3953] 逛公园</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p3953-%e9%80%9b%e5%85%ac%e5%9b%ad/</link>
		<pubDate>Fri, 22 Feb 2019 09:04:16 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=174</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

蒟蒻博客：<a href="https://www.luogu.org/problemnew/show/P3953">QAQ</a>

<hr />

<h2>Solution</h2>

<strong>这是一道神题</strong>

首先，我们不妨想一下K=0，即求最短路方案数的部分分。
我们很容易可以想到一个做法，就是魔改迪杰斯特拉做法：
<strong>一个点可以更新到达其他点的距离，那个点的方案数就是这个点的方案数；如果一个点所更新出来的距离和之前的相等，那个点的方案数加等当前点的方案数。</strong>
用式子可以表现为：
$$f[i]=f[i] (dis[j]>dis[i]+x)$$

$$f[j]+=f[i] (dis[j]==dis[i]+x)$$
<strong>(i表示当前点，j表示它更新的点，x为i到j那条路的距离)</strong>
那我们怎么保证它的顺序不会出错，即如何保证一个点去更新其他点的方案数的时候，这个点的方案数是正确的呢？
<img src="https://s2.ax1x.com/2019/03/27/AaUW9S.png" alt="AaUW9S.png" />

事实上，这种做法就是一种DP。

那么，对于K！=0的情况怎么处理呢？
观察数据，我们会发现K最大只有50。
因此，我们可以考虑在DP上加一维来解决这个K值。
考虑这样设状态：
<strong>f[i][j] 表示到达i点，距离为dis[i]+j 的方案数</strong>

转移非常好写
$$f[i][j] = sigema (f[k][dis[i]+j-dis[k]-a])$$
(k为直接连到i的点，a表示它们之间的边权)
初始化其实我们在30分做法中就已经求好了。

转移顺序是个问题。
我们显然可以在外层枚举j，问题是，有时候，dis[i]+j-dis[k]-a会等于j，如果枚举i的顺序错了，答案肯定会跟着错。
<strong>对于dis[i]+j-dis[k]-a==j 的点，肯定是k去更新i，又因为边权没有负值，所以我们就可以按照dis从小到大去去枚举i的值。</strong>

以上是没有零边的做法。
对于有零边的情况，我们刚刚的做法就会出问题。如图：
<img src="https://s2.ax1x.com/2019/03/27/AaUIns.png" alt="AaUIns.png" />

所以说，我们把原图转换一下<strong>，只保留0边，对新图做拓扑排序</strong>。
<strong>如果做完拓扑排序之后，有几个点没有进入过排序中，就说明这个图有零环，就gg了。</strong>
我们把拓扑序做完之后再执行原来有的最短路和dp，这样就不会错了。

就酱，我们就嘴巴AC这道题啦o(<em>￣▽￣</em>)o 。
事实上，这样做并A不了，因为这题TM卡常(╯°Д°)╯︵┻━┻
<del>然后，你会被卡30分并因此退役（或者是开O2A掉这道题（但是NOIP中并不开O2，所以你还是因此退役了））</del>

<hr />

<h2>Code</h2>

<pre><code class="language-cpp line-numbers">//Luogu P3953 逛公园
//Sep,18th,2018
//最短路+拓扑排序+DP+卡常神题
// luogu-judger-enable-o2
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int M=50+5;
const int inf=0x3f3f3f3f;
struct DIS
{
    int dis,no,zero;
}dis[N];
bool cmp(DIS A,DIS B)
{
    if(A.dis==B.dis)
        return A.zero&lt;B.zero;
    return A.dis&lt;B.dis;
}
struct road
{
    int to,w;
    road(int A,int B)
    {
        to=A,w=B;
    }
    friend bool operator &lt; (road A,road B)
    {
        if(A.w==B.w)
            return dis[A.to].zero &gt; dis[B.to].zero;
        return A.w &gt; B.w;
    }
};
vector &lt;road&gt; e[N],rev[N];
int n,m,K,poi,T,rd[N],dl2[N],front2,tail2,dis2[N];
long long f[N][M];
priority_queue &lt;road,vector&lt;road&gt; &gt; dl;
bool vis[N];
void dj()
{
    for(int i=1;i&lt;=n;i++)
        dis[i].dis=inf,dis[i].no=i;
    dis[1].dis=0;
    memset(dis2,0x3f,sizeof dis2);
    dis2[1]=0;
    while(dl.empty()==false) dl.pop();
    memset(vis,0,sizeof vis);
    dl.push(road(1,0));
    f[1][0]=1;
    int cnt=0;
    while(cnt!=n and dl.empty()==false)
    {
        road temp=dl.top();
        dl.pop();
        if(vis[temp.to]==true) continue;
        vis[temp.to]=true;
        int now=temp.to,dis_now=temp.w;
        for(int i=0;i&lt;int(e[now].size());i++)
            if(dis_now+e[now][i].w &lt; dis[e[now][i].to].dis)
            {
                f[e[now][i].to][0]=f[now][0];
                dis[e[now][i].to].dis=dis_now+e[now][i].w;
                dis2[e[now][i].to]=dis_now+e[now][i].w;
                dl.push(road(e[now][i].to,dis[e[now][i].to].dis));
            }
            else if(dis_now+e[now][i].w == dis[e[now][i].to].dis)
                f[e[now][i].to][0]=(f[e[now][i].to][0]+f[now][0])%poi;
    }
}
void GetTP()
{
    tail2=front2=0;
    memset(vis,0,sizeof vis);
    for(int i=1;i&lt;=n;i++)
        if(rd[i]==0)
            dl2[tail2++]=i;
    int cnt=0;
    while(tail2&gt;front2)
    {
        dis[dl2[front2]].zero=++cnt;
        vis[dl2[front2]]=true;
        for(int i=0;i&lt;int(e[dl2[front2]].size());i++)
            if(e[dl2[front2]][i].w==0 and vis[e[dl2[front2]][i].to]==false)
            {
                rd[e[dl2[front2]][i].to]--;
                if(rd[e[dl2[front2]][i].to]==0)
                    dl2[tail2++]=e[dl2[front2]][i].to;
            }
        front2++;
    }
}
int main()
{
    T=read();
    for(int i=1;i&lt;N;i++)
        e[i].reserve(4),rev[i].reserve(4);
    for(;T&gt;0;T--)
    {
        memset(f,0,sizeof f);
        memset(rd,0,sizeof rd);
        n=read(),m=read(),K=read(),poi=read();
        for(int i=1;i&lt;=n;i++)
            e[i].clear(),rev[i].clear();
        for(int i=1;i&lt;=m;i++)
        {
            int a=read(),b=read(),c=read();
            e[a].push_back(road(b,c));
            rev[b].push_back(road(a,c));
            if(c==0)
                rd[b]++;
        }

        GetTP();
        bool OK=true;
        for(int i=1;i&lt;=n;i++)
            if(vis[i]==false)
                OK=false;
        if(OK==false)
        {
            printf("-1\n");
            continue;
        }
        dj();

        sort(dis+1,dis+1+n,cmp);    
        for(int j=1;j&lt;=K;j++)
            for(int i=1;i&lt;=n;i++)
                for(int k=0;k&lt;int(rev[dis[i].no].size());k++)
                {
                    int t=dis[i].no,s=rev[t][k].to;
                    if(dis2[t]!=inf and dis2[s]!=inf and dis2[t]+j-dis2[s]-rev[t][k].w&gt;=0 )
                        f[t][j]=(f[t][j]+f[s][dis2[t]+j-dis2[s]-rev[t][k].w])%poi;
                }

        long long ans=0;
        for(int i=0;i&lt;=K;i++)
            ans=(ans+f[n][i])%poi;
        printf("%lld\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>174</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 09:04:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 09:04:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3953-%e9%80%9b%e5%85%ac%e5%9b%ad]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="dag-dp"><![CDATA[DAG DP]]></category>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84"><![CDATA[最短路径]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[683]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2831] 愤怒的小鸟</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p2831-%e6%84%a4%e6%80%92%e7%9a%84%e5%b0%8f%e9%b8%9f/</link>
		<pubDate>Fri, 22 Feb 2019 09:21:20 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=176</guid>
		<description></description>
		<content:encoded><![CDATA[题面：<a href="https://www.luogu.org/problemnew/show/P2831">洛谷</a>

<hr />

<h2>Solution</h2>

首先，我们可以先康一康题目的数据范围：n&lt;=18，应该是状压或者是搜索。
事实上，这题搜索和状压DP都是能做的。
（<del>因为搜索在我心中留下了阴影（斗地主）</del>，所以在这里，我讲状压DP的做法）

根据我们以往设计状压DP的经验，我们可以很轻松地设计这一题的状态：
<strong>设f[i]表示打下的猪猪的状态为i的方案数</strong>，（状态在这里用二进制方式来表示，例如：00101表示打下了第1和第3只猪）
那么有： $f[i] = min(f[j])+1$ （j为i的子集）
这里用到一个枚举子集的技巧，对于一个状态i，它可以这样枚举子集：
for(int j=i;j>=0;j=(j-1)&amp;i) (至于证明，你可以在草稿纸上画画，很快就会发现它的精妙了)

那我们怎么判断能否从状态 j 转移到 i 呢？
首先，根据数学常识，<strong>我们需要3个x不一样的点才能确定一条抛物线。这题已经固定了原点了，所以我们还需要两个点来确定一条抛物线</strong>。
<strong>如果j与i只有一个或两个x不同的点 是不同的，那显然是可以转移的。</strong>
对于有两个以上的点，<strong>我们可以用前两个点通过解二元一次方程来计算函数的a与b，然后再去一个一个判断每个不同的点是否在这条抛物线上</strong>。

对于如何解二元一次方程..........（这应该是数学常识吧）
复杂度$O(3^n&#42;n&#42;T)$
显然TLE，事实上，这样做只能得60分。

那怎么优化复杂度呢？
刚刚的枚举子集显然是不可行了，那我们可以换个思路。
我们可以枚举点。
<strong>对于某一种状态，我们肯定可以枚举两个（或一个）没有用过的点去构成新的抛物线从而更新其他的状态。</strong>
这样子，我们成功地把复杂度降为了 $O(2^n&#42;n^2&#42;T)$
依然过不了，事实上，这样做能得85分。

上一个作法已经和正解很接近了。
我们可以考虑这样优化方程：
<img src="https://s2.ax1x.com/2019/03/27/AaUqhT.png" alt="AaUqhT.png" />
这样子，我们复杂度就降为了$ O(2^n&#42;n&#42;T)$

就酱，我们就可以把这道题切掉啦(´▽`)ﾉ

<hr />

<h2>Code</h2>

<pre><code class="language-cpp line-numbers">//Luogu P2831 愤怒的小鸟
//Sep,19th,2018
//状压DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=18+2;
const double eps=1e-7;
struct node
{
    double x,y;
}nd[N];
long long f[1&lt;&lt;N];
int n,POW[N],g[N][N];
inline double pf(double x)
{
    return x*x;
}
bool solve(node A,node B,double &amp;a,double &amp;b)
{
    if(fabs(A.x-B.x)&lt;=eps) return false;
    a=(B.x*A.y-A.x*B.y)/(pf(A.x)*B.x-pf(B.x)*A.x);
    b=(pf(B.x)*A.y-pf(A.x)*B.y)/(pf(B.x)*A.x-pf(A.x)*B.x);
    if(a&gt;=0) return false;
    return true;
}
double fun(double x,double a,double b)
{
    return a*pf(x)+b*x;
}
int main()
{
    POW[0]=1;
    for(int i=1;i&lt;N;i++)
        POW[i]=POW[i-1]*2;
    int T,tt;
    scanf("%d",&amp;T);
    for(;T&gt;0;T--)
    {
        memset(g,0,sizeof g);
        scanf("%d%d",&amp;n,&amp;tt);
        for(int i=1;i&lt;=n;i++)
            scanf("%lf%lf",&amp;nd[i].x,&amp;nd[i].y);

        for(int i=1;i&lt;=n;i++)
            for(int j=i+1;j&lt;=n;j++)
            {
                double a=0,b=0;
                bool OK=solve(nd[i],nd[j],a,b);
                if(OK==false) continue;
                for(int k=1;k&lt;=n;k++)
                    if(fabs(fun(nd[k].x,a,b)-nd[k].y)&lt;=eps)
                        g[i][j]+=POW[k-1];
            }

        memset(f,0x3f,sizeof f);
        f[0]=0;
        int to=(1&lt;&lt;n)-1,used[N];
        for(int i=0;i&lt;to;i++)
        {
            memset(used,0,sizeof used);
            int temp=i,j;
            for(j=n-1;j&gt;=0;j--)
                if(temp-POW[j]&gt;=0)
                {
                    temp-=POW[j];
                    used[j+1]=true;
                }
            for(j=1;j&lt;=n;j++)
                if(used[j]==false) 
                    break;
            f[i|POW[j-1]]=min(f[i|POW[j-1]],f[i]+1);
            for(int k=j+1;k&lt;=n;k++)
                if(used[k]==false and g[j][k]!=0)
                        f[i|g[j][k]]=min(f[i|g[j][k]],f[i]+1);
        }

        printf("%lld\n",f[to]);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>176</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 09:21:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 09:21:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2831-%e6%84%a4%e6%80%92%e7%9a%84%e5%b0%8f%e9%b8%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%8a%b6%e5%8e%8bdp"><![CDATA[状压DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[494]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4215] 踩气球</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p4215-%e8%b8%a9%e6%b0%94%e7%90%83/</link>
		<pubDate>Fri, 22 Feb 2019 09:23:08 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=178</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4215">洛谷</a>

<hr />

<h1>Solution</h1>

这题十分有意思。

首先，我们可以先想想离线做法，因为在线做法可以从离线做法推出。<del>（虽然这题推不出）</del>

我们可以明确一点，一个熊孩子开心的时间是满足二分的要求的（如果他某个时刻开心了，那之后的时刻都会保持开心）。

对于判断一个区间是否为全0，我们可以用主席树以一个log的代价来判断。

得到每个熊孩子开心的时刻之后，我们就可以直接前缀和解决问题了。

时间复杂度$O(m*log^2)$

.

很可惜，这题强制在线。

很可惜*2，<del>刚刚的做法跟正解一点关系都没有</del>。

我们可以考虑用线段树。

问题是怎么判断一个熊孩子在某个操作后是否开心呢？

我们显然可以快速地判断线段树上的一个直接的区间（即这个区间可以用一个节点表示）是否全为0，问题是我们不能很快地判断一个非直接的区间是否全为0。

所以说，我们可以考虑<strong>把熊孩子“拆开”</strong>。

因为<strong>一个熊孩子的区间一定可以表示为线段树上的几个直接区间，我们可以在这些直接区间上打上标记，记录这个区间被哪几个熊孩子直接包含</strong>。

我们<strong>再记录一下每个熊孩子被拆成了几个区间</strong>。

<strong>一个区间全部变为0的时候，我们把它对应的熊孩子的记录值-1，当一个熊孩子记录值为0的时候，就代表着这个熊孩子的区间被彻底干掉了</strong>。

时间复杂度$O(mlogn+qlogn)$

.

就酱，这题就被我们切掉啦φ(>ω&lt;*)

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P4215 踩气球
//Oct,14th,2018
//有意思的线段树
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
int ans,tot[N];
struct SegmentTree
{
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    #define mid ((now_l+now_r)/2)
    vector &lt;int&gt; son[N&lt;&lt;2];
    int IsClear[N&lt;&lt;2],cnt[N];
    inline void update(int now)
    {
        IsClear[now]=IsClear[lson]&amp;IsClear[rson];
    }
    void Mark(int L,int R,int x,int now,int now_l,int now_r)
    {
        if(now_l&gt;=L and now_r&lt;=R)
        {
            tot[x]++;
            son[now].push_back(x);
            return;
        }
        if(L&lt;=mid) Mark(L,R,x,lson,now_l,mid);
        if(R&gt;mid) Mark(L,R,x,rson,mid+1,now_r);
    }
    void Sub(int x,int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            cnt[x]--;
            if(cnt[x]==0)
                IsClear[now]=true;
        }
        if(now_l!=now_r)
        {
            if(x&lt;=mid) Sub(x,lson,now_l,mid);
            else Sub(x,rson,mid+1,now_r);
            update(now);
        }
        if(IsClear[now]==true)
            for(int i=0;i&lt;int(son[now].size());i++)
            {
                tot[son[now][i]]--;
                if(tot[son[now][i]]==0)
                    ans++;
            }
    }
    #undef lson
    #undef rson
    #undef mid
}sgt;
int n,m,q;
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        sgt.cnt[i]=read();
    for(int i=1;i&lt;=m;i++)
    {
        int L=read(),R=read();
        sgt.Mark(L,R,i,1,1,n);
    }

    int q=read(),lans=0;
    for(int i=1;i&lt;=q;i++)
    {
        int x=read();
        x=(x+lans-1)%n+1;
        sgt.Sub(x,1,1,n);
        lans=ans;
        printf("%d\n",lans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>178</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 09:23:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 09:23:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4215-%e8%b8%a9%e6%b0%94%e7%90%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[412]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3899] [湖南集训]谈笑风生</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3899-%e6%b9%96%e5%8d%97%e9%9b%86%e8%ae%ad%e8%b0%88%e7%ac%91%e9%a3%8e%e7%94%9f/</link>
		<pubDate>Fri, 22 Feb 2019 09:27:54 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=180</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3899">洛谷</a>

<hr />

<h1>Solution</h1>

你们搞的这道题啊，excited！

.

这题真的很有意思。
首先，我们可以先理解一下题面：固定一个a，找到一个b，c就是a与b的公共子树中的某个点。
那么，我们显然可以把这个b分成两类，第一种是在a上面的，第二种在a下面的。

对于b在a上面的情况，<strong>显然，c一定是a的子树中的某个点，</strong>答案即为$min(K，depth[a])*size[a]$

对于b在a下面的情况，问题就会变得比较exciting了。
我们可以考虑使用主席树来搞这个问题。
考虑建一颗这样的主席树，<strong>以节点深度为主席树下标</strong>。
对于一个节点，如果B在这个节点上，那么，它对答案的贡献显然是它的$size-1$。
那么，我们把它的贡献插入到它对应的主席树中（以深度为下标）。
每一个子节点开一颗主席树，记录到它为止所有的深度的答案和，有点类似前缀和，以dfs序为时间轴。
这样，我们可以用一种类似树上差分的办法来“抠”出一颗子树对应的线段数（以深度为下标），这颗线段数中的$[depth[x]+1,depth[x]+K]$区间的sum就是这个x点的答案啦。

.

就酱，这题就被我们切掉啦٩(๑>◡&lt;๑)۶

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const long long N=300000+100;
const long long M=N*30;
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    long long son[M][2],cnt;
    long long sum[M];
    inline void update(long long now)
    {
        sum[now]=sum[son[now][0]]+sum[son[now][1]];
    }
    void Build(long long now,long long now_l,long long now_r)
    {
        if(now_l==now_r) 
            return;    
        Build(son[now][0]=++cnt,now_l,mid);
        Build(son[now][1]=++cnt,mid+1,now_r);
    }
    void Add(long long x,long long num,long long now,long long pre,long long now_l,long long now_r)
    {
        if(now_l==now_r)
        {
            sum[now]=sum[pre];
            sum[now]+=num;
            return ;
        }
        if(x&lt;=mid) son[now][1]=son[pre][1],Add(x,num,son[now][0]=++cnt,son[pre][0],now_l,mid);
        else son[now][0]=son[pre][0],Add(x,num,son[now][1]=++cnt,son[pre][1],mid+1,now_r);
        update(now);
    }
    long long Query(long long L,long long R,long long now,long long pre,long long now_l,long long now_r)
    {
        if(now_l&gt;=L and now_r&lt;=R)
            return sum[now]-sum[pre];
        long long ans=0;
        if(L&lt;=mid) ans+=Query(L,R,son[now][0],son[pre][0],now_l,mid);
        if(R&gt;mid) ans+=Query(L,R,son[now][1],son[pre][1],mid+1,now_r);
        return ans;
    }
    void Print(long long now,long long now_l,long long now_r)
    {
        cerr&lt;&lt;"no."&lt;&lt;now&lt;&lt;" now_l&amp;r:"&lt;&lt;now_l&lt;&lt;" "&lt;&lt;now_r&lt;&lt;" sonl&amp;r"&lt;&lt;son[now][0]&lt;&lt;" "&lt;&lt;son[now][1]&lt;&lt;" sum:"&lt;&lt;sum[now]&lt;&lt;endl;
        if(now_l!=now_r)
        {
            Print(son[now][0],now_l,mid);
            Print(son[now][1],mid+1,now_r);    
        }
    }    
    #undef mid
}sgt;
vector &lt;long long&gt; e[N];
long long n,m,depth[N],size[N],dfn[N],dfn_to,r[N];
void dfs2(long long now)
{
    dfn[now]=++dfn_to;
    size[now]=1;
    for(long long i=0;i&lt;(long long)(e[now].size());i++)
        if(depth[e[now][i]]==0)    
        {
            depth[e[now][i]]=depth[now]+1;
            dfs2(e[now][i]);
            size[now]+=size[e[now][i]];    
        }
}
void dfs(long long now)
{
    r[dfn[now]]=++sgt.cnt;
    sgt.Add(depth[now],size[now]-1,r[dfn[now]],r[dfn[now]-1],1,n);
    //sgt.Print(r[dfn[now]],1,n);
    //cerr&lt;&lt;endl;
    for(long long i=0;i&lt;(long long)(e[now].size());i++)
        if(depth[e[now][i]]&gt;depth[now])
            dfs(e[now][i]);
}
int main()
{
    n=read(),m=read();
    for(long long i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(long long i=1;i&lt;n;i++)
    {
        long long s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);    
    }

    sgt.Build(0,1,n);
    //sgt.Print(0,1,n);
    //cerr&lt;&lt;endl;
    depth[1]=1;
    dfs2(1);
    dfs(1);

    for(long long i=1;i&lt;=m;i++)
    {
        long long p=read(),K=read();
        long long ans=sgt.Query(depth[p]+1,depth[p]+K,r[dfn[p]+size[p]-1],r[dfn[p]-1],1,n);
        ans+=min(K,depth[p]-1)*(size[p]-1);
        printf("%lld\n",ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>180</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 09:27:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 09:27:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3899-%e6%b9%96%e5%8d%97%e9%9b%86%e8%ae%ad%e8%b0%88%e7%ac%91%e9%a3%8e%e7%94%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[446]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[CF893F]Subtree Minimum Query</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/cf893fsubtree-minimum-query/</link>
		<pubDate>Fri, 22 Feb 2019 09:30:47 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=182</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面：</h1>

传送门：<a href="http://codeforces.com/problemset/problem/893/F">Codeforces</a>

题目大意：给你一颗有根树，点有权值，问你每个节点的子树中距离其不超过k的点的权值的最小值。（边权均为1，强制在线）

<hr />

<h1>Solution</h1>

这题很有意思。

我们一般看到这种距离不超过k的题目，第一反应一般是建以深度为下标，以dfs序为时间轴的的主席树。
很不幸，区间最小值并不能通过减去历史状态得出某个子树的状态。

所以说，这题妙在思想的转换。
考虑以dfs序为下标，<strong>以深度为时间轴建一颗主席树</strong>。
我们可以bfs，按深度一层层地把点加进去。
这样子，我们就可以查询对应深度之内的这颗子树的最小权值啦。

就酱，我们就可以把这题切掉啦ヽ(￣▽￣)ﾉ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+1000;
const int M=30*N;
int n,r,a[N];
vector &lt;int&gt; e[N];
struct SegmentTree
{
    static const int inf=0x3f3f3f3f;
    #define mid ((now_l+now_r)&gt;&gt;1)
    int MIN[M],son[M][2],cnt;
    inline void update(int now)
    {
        MIN[now]=min(MIN[son[now][0]],MIN[son[now][1]]);    
    }
    void Build(int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            MIN[now]=inf;
            return;    
        }
        Build(son[now][0]=++cnt,now_l,mid);
        Build(son[now][1]=++cnt,mid+1,now_r);
        update(now);
    }
    void Change(int x,int num,int now,int pre,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            MIN[now]=num;
            return;
        }
        if(x&lt;=mid) son[now][1]=son[pre][1],Change(x,num,son[now][0]=++cnt,son[pre][0],now_l,mid);
        else son[now][0]=son[pre][0],Change(x,num,son[now][1]=++cnt,son[pre][1],mid+1,now_r);
        update(now);
    }
    int Query(int L,int R,int now,int now_l,int now_r)
    {
        if(now_l&gt;=L and now_r&lt;=R)
            return MIN[now];
        int ans=inf;
        if(L&lt;=mid) ans=min(ans,Query(L,R,son[now][0],now_l,mid));
        if(R&gt;mid) ans=min(ans,Query(L,R,son[now][1],mid+1,now_r));
        return ans;
    }
    void Print(int now,int now_l,int now_r)
    {
        cerr&lt;&lt;"no."&lt;&lt;now&lt;&lt;" now_l&amp;r:"&lt;&lt;now_l&lt;&lt;" "&lt;&lt;now_r&lt;&lt;" sonl&amp;r"&lt;&lt;son[now][0]&lt;&lt;" "&lt;&lt;son[now][1]&lt;&lt;" MIN:"&lt;&lt;MIN[now]&lt;&lt;endl;
        if(now_l!=now_r)
        {
            Print(son[now][0],now_l,mid);
            Print(son[now][1],mid+1,now_r);    
        }
    }    
    #undef mid
}sgt;
int dfn[N],depth[N],dfn_to,size[N],depth_MAX;
void dfs(int now)
{
    depth_MAX=max(depth_MAX,depth[now]);
    dfn[now]=++dfn_to;
    size[now]=1;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(dfn[e[now][i]]==0)
        {
            depth[e[now][i]]=depth[now]+1;
            dfs(e[now][i]);
            size[now]+=size[e[now][i]];    
        }
}
int dl[N],front,tail,root[N];
void bfs()
{
    dl[tail++]=r;
    int depth_now=0;
    while(tail&gt;front)
    {
        int now=dl[front];
        int temp=root[depth_now];
        if(depth[now]!=depth_now)
        {
            depth_now=depth[now];
            temp=root[depth_now-1];
        }
        root[depth_now]=++sgt.cnt;
        sgt.Change(dfn[now],a[now],root[depth_now],temp,1,n);
        //sgt.Print(root[depth_now],1,n);
        //cerr&lt;&lt;endl;
        for(int i=0;i&lt;int(e[now].size());i++)
            if(depth[e[now][i]]&gt;depth[now])
                dl[tail++]=e[now][i];
        front++;    
    }
}
int main()
{
    n=read(),r=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();
    for(int i=1;i&lt;n;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    depth[r]=1;
    dfs(r);
    sgt.Build(0,1,n);
    //sgt.Print(0,1,n);
    //cerr&lt;&lt;endl;
    bfs();

    int m=read(),lans=0;
    for(int i=1;i&lt;=m;i++)
    {
        int x=read(),K=read();
        x=((x+lans)%n)+1,K=(K+lans)%n;
        int temp=min(depth[x]+K,depth_MAX);
        lans=sgt.Query(dfn[x],dfn[x]+size[x]-1,root[temp],1,n);
        printf("%d\n",lans);    
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>182</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 09:30:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 09:30:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[cf893fsubtree-minimum-query]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[445]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2824] [HEOI2016/TJOI2016]排序</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p2824-heoi2016-tjoi2016%e6%8e%92%e5%ba%8f/</link>
		<pubDate>Fri, 22 Feb 2019 09:33:55 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=184</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2824">洛谷</a>

<hr />

<h1>Solution</h1>

这题极其巧妙。

首先，如果直接做m次排序，显然会T得起飞。
注意一点：我们只需要找到一个数。
所以说，我们可以考虑一个绝妙的想法：<strong>我们可以用二分答案的方法缩小要找的数的区间</strong>。
考虑二分一个值，判定p位置的数排序之后，p位置上的数是否>=mid
如果>=mid,则向右找，否则向左找。

怎么判定p位置的数排序之后是否>=mid呢？
考虑这样做：<strong>扫描一遍原数组，>=mid的数赋值为1，&lt;mid的数赋值为0。</strong>
这样子，题目就变成了一个01序列排序。

这就很可做了，我们直接线段树维护之即可，我们只需要实现区间查询与区间赋值。
对于一个01区间排序，我们只需要知道这个区间有多少个0，多少个1，然后区间修改即可。

时间复杂度$O(m*logn^2)$

.

就酱，这题就可以切掉啦(ﾉ´▽｀)ﾉ♪

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu  P2824 [HEOI2016/TJOI2016]排序
//Oct,19th,2018
//二分答案缩小范围+线段树妙题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=30000+100;
int a[N],w[N];
struct SegmentTree
{
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    #define mid ((now_l+now_r)&gt;&gt;1)
    static const int M=N&lt;&lt;2;
    int sum[M][2],lazy[M];
    inline void update(int now)
    {
        sum[now][0]=sum[lson][0]+sum[rson][0];
        sum[now][1]=sum[lson][1]+sum[rson][1];
    }
    inline void pushdown(int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            lazy[now]=2;
            return;
        }
        lazy[lson]=lazy[rson]=lazy[now];
        sum[lson][lazy[now]]=mid-now_l+1,sum[lson][!lazy[now]]=0;
        sum[rson][lazy[now]]=now_r-mid,sum[rson][!lazy[now]]=0;
        lazy[now]=2;
    }
    void Build(int now,int now_l,int now_r)
    {
        sum[now][0]=sum[now][1]=0;
        lazy[now]=2;
        if(now_l==now_r)
        {
            sum[now][w[now_l]]++;
            return;
        }
        Build(lson,now_l,mid);
        Build(rson,mid+1,now_r);
        update(now);
    }
    void Change(int L,int R,int x,int now,int now_l,int now_r)
    {
        if(L&gt;R) return;
        if(lazy[now]!=2) pushdown(now,now_l,now_r);
        if(now_l&gt;=L and now_r&lt;=R)
        {
            sum[now][x]=now_r-now_l+1,sum[now][!x]=0;
            lazy[now]=x;
            return;
        }
        if(L&lt;=mid) Change(L,R,x,lson,now_l,mid);
        if(R&gt;mid) Change(L,R,x,rson,mid+1,now_r);
        update(now);
    }
    int Query(int L,int R,int x,int now,int now_l,int now_r)
    {
        if(lazy[now]!=2) pushdown(now,now_l,now_r);
        if(now_l&gt;=L and now_r&lt;=R)
            return sum[now][x];
        int ans=0;
        if(L&lt;=mid) ans+=Query(L,R,x,lson,now_l,mid);
        if(R&gt;mid) ans+=Query(L,R,x,rson,mid+1,now_r);
        return ans;
    }
    #undef lson
    #undef rson
    #undef mid
}sgt;
struct OP
{
    int type,L,R;
}op[N];
int n,m,p;
bool Check(int x)
{
    for(int i=1;i&lt;=n;i++)
        if(a[i]&gt;=x) w[i]=1;
        else w[i]=0;
    sgt.Build(1,1,n);
    for(int i=1;i&lt;=m;i++)
    {
        int cnt0=sgt.Query(op[i].L,op[i].R,0,1,1,n),cnt1=op[i].R-op[i].L+1-cnt0;
        if(op[i].type==0)
            sgt.Change(op[i].L,op[i].L+cnt0-1,0,1,1,n),
            sgt.Change(op[i].L+cnt0,op[i].R,1,1,1,n);
        else
            sgt.Change(op[i].L,op[i].L+cnt1-1,1,1,1,n),
            sgt.Change(op[i].L+cnt1,op[i].R,0,1,1,n);
    }
    if(sgt.Query(p,p,1,1,1,n)==1) return true;
    return false;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();
    for(int i=1;i&lt;=m;i++)
        op[i].type=read(),op[i].L=read(),op[i].R=read();
    p=read();

    int L=0,R=n+100,ans=0;
    while(L&lt;=R)
    {
        int mid=(L+R)/2;
        if(Check(mid)==true)
            ans=max(ans,mid),L=mid+1;
        else
            R=mid-1;
    }

    printf("%d",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>184</wp:post_id>
		<wp:post_date><![CDATA[2019-02-22 09:33:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-22 09:33:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2824-heoi2016-tjoi2016%e6%8e%92%e5%ba%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[438]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>NOIP2018 填坑记</title>
		<link>https://www.goldenpotato.cn/%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95/noip2018-%e5%a1%ab%e5%9d%91%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 09:48:47 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=188</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>Oct,22ed,2018　　DAY -18</h2>

又是颓废的一天呢

我好菜啊，一个圆方树弄了一整天（点双怎么那么毒瘤）。（铁人两项怎么那么多点）

<h2>Oct,23rd,2018　　DAY -17</h2>

又双叒叕颓了一天

下午考了一个蜜汁模拟塞，全部都是历年T1，写的是时候出现了巨多问题，什么输入写挂啊，忘记初始化啊，双向边写成单项边啊，导致我比机房dalao多调了半个小时。（好在我最终的没有写挂。）先膜一下10分钟ak的lyj dalao。有好多机房dalao因为各种各样的原因没有ak。wzj dalao忘开longlong挂了20分，太惨了。

晚上听了神仙讲课，半程自闭，好神啊。怎么还有那么毒的二分答案的check。（以及我的南普口音造成的“额分”尴尬）

走之前两位教练做了训话，以后不能再颓废了呢。（再这样颓下去怕不是noip退役）（第二天:真香）

ps：<del>怎么爆名费辣么贵啊，不愧是china cheating money founderation</del>

<h2>Oct,24th,2018　　DAY -16</h2>

被暴打的一天

早上考了一个膜你赛，T1是一道蜜汁背包带贪心的题目，T2因为不会卡特兰数被lyj暴打，T3的数位DP又双叒叕调爆了。成功滚粗。

下午当然是调调调调调上午的代码（T2的线段数怎么辣么难写啊w）

晚上又考了一个武汉zyb邀请赛，依旧被暴打。T1被错误的大样例卡了一个小时（现在我还是忍不住暴打出题人的想法），T2是典型的不可做题（这样还绑subtest，毒瘤出题人），T3写了一个蜜汁分块+biteset+线段树的做法，当时对拍了半个小时，觉得稳如老狗，很不幸，T3依旧爆零了，（应该是随机的数据太弱了），成功滚粗*2

<del>我又菜又颓，真的是要退役</del>

<h2>Oct,25th,2018　　DAY -15</h2>

又被暴打了

上午又考了一个膜你赛，T1写了一个nlog^2的玄学二分答案+线段树上二分（事实上，那题可以直接在数组上二分），结果线段树常数爆大，卡成暴力分（事实上，lowerbound也会T，要手写二分，在这里问候卡常出题人和他的家人）。T2是一道区间DP带上一些玄学优化（结果被机房dalao们贪心爆踩），我只能想出n^3的区间DP啊，我好菜啊，T3是一道期望不可做题，推半天式子还是调不出大样例，理所当然的爆零了。

下午写出T2贪心A掉的问题引起了写了正解以及没写贪心的wzj和lyjdalao的愤怒，直接对着标程把所有贪心卡掉了w（真爽）（我只是因为没有写贪心而爽）

然后当然是调调调调上午被卡常卡爆的T1，然后写了一下T2，昨晚的T3好妙啊，居然可以在数列上做哈希。（还是想不通为啥我的分块+bitset会wa）

又被打爆了，我好菜啊

<h2>Oct,26th,2018　　DAY -14</h2>

今天并没有考试（失去了一雪前耻的机会（或者说是再一次被打爆的机会））

那裆燃是去学前一天怨念十足的卡特兰数啊（卡特兰数真好玩）（真香）

我已经决定了，将来出题一定要当一个毒瘤，不仅要卡常，而且要求答案膜上一个卡特兰数输出，让所有不注意常数与不会卡特兰数的人全部爆零，哇哈哈

<h2>Oct,27th,2018　　DAY -13</h2>

周六，当然是颓颓颓颓颓颓颓啦。

顺便做了几道题愉悦身心，结果被神题暴打

ZJOI2013蚂蚁寻路一眼看上去是可做题，写起来却极其恶心，细节讨论起来比模拟题还多，毒瘤不可做题

交了6次之后总算A掉了（真香）

很不幸，还是被暴打了，神犇学弟这道题1A，tql

<h2>Oct,29th,2018　　DAY -12</h2>

今天学到了好多新东西呢。

LUCAS定理真好玩鸭（居然膜着膜着会出现n&lt;m的情况，感谢学弟的指点，学弟太强啦）

欧拉函数真好玩鸭（玄学线性塞写了一个极度恶心的三目运算符，我是谁，我在哪里，我写的是啥）

带修莫队真好玩鸭（好玩个鬼，怎么数颜色那么毒瘤啊，卡了奇偶排序，块大小，居然还要对t排序）

今天好多姬房惨案啊，场面一度混乱

<h2>Oct,31st,2018　　DAY -9</h2>

今天的模拟赛又被暴打了。

T1是个玄学模拟题，大致读了一眼题意，发现不会输出顺序.......然后写了个60分暴力就草草下一题了。

T2是个玄学逆序对题，完全没有任何思路，就写了个40分的暴力。

T3是个不可做题，考场上想了一个玄学做法，期望30分。

好消息是，我的T3，T3并没有写挂.....坏消息是T1挂掉了

原因是TM的读错题

一定好好审题啊！！！！！如果是在NOIp考场上就真的退役了。

又被暴打了，我怎么那么菜啊

<h2>Nov,5th,2018　　DAY-4</h2>

今天的模拟赛非常信心，非常可做。

T1是一个斐波那契数列大水题，5minA掉直接下一题。

T2是一个LCA+树上倍增乱搞小水题，30min写了个正解，30min写了暴力和对拍，跑了3w组数据，没啥问题。

T3是一个树上DP求最大匹配的正常题，先花了30min写了个大暴力。我在考场上第一反应是贪心，花了30min写了一个贪心做法，并不能过对拍。冷静之后发现这题好像是求树上的最大匹配问题，那显然可以网络流做啊。接着就开始怀疑人生：我已经半年没有写过网络流了，我很有可能调不出，建图有可能建错,有可能被卡掉.......赶紧上了个厕所冷静一下，回来猛然发现这题可以树形DP乱搞水过，赶紧写了一个树形DP，顺便上了对拍。总共用时1h。

接下来的一个半小时，检查了一下极限数据和数据范围，输入输出之后，当然是打开emacs颓五子棋啊（电脑好强啊，连跪5局），连带做着AK的美梦。

很不幸的是，T1挂成了30分，原因是我又双叒叕TM的读错题了。

斐波那契数列第0项居然是0！！！！！！！！

很显然，在人均AK的神仙群中，我又被暴打了。

以后一定要好好审题！！！！！这样下去吃枣药丸。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>188</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 09:48:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 09:48:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[noip2018-%e5%a1%ab%e5%9d%91%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[273]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>卡特兰数学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e5%8d%a1%e7%89%b9%e5%85%b0%e6%95%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 09:53:29 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=190</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>为什么要学卡特兰数？</h1>

为了解决一类计数问题

NOIp能考吗：能

<del>以此记录我模拟赛中被强行卡特兰数卡爆的贪心神题</del>

<hr />

<h1>什么是卡特兰数？</h1>

<blockquote>
  卡特兰数又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。--百度百科
</blockquote>

用人话来说，就是开头为1，2，5，14，42，132，429，1430，4862....的数列

<h1>卡特兰数的公式</h1>

<h3>卡特兰数的一般公式</h3>

<a href="https://imgchr.com/i/k5XalD"><img src="https://s2.ax1x.com/2019/02/25/k5XalD.png" alt="k5XalD.png" /></a>

(只有下标的是卡特兰数，右边那个是组合数)

<h3>卡特兰数的递推式</h3>

<a href="https://imgchr.com/i/k5XwOH"><img src="https://s2.ax1x.com/2019/02/25/k5XwOH.png" alt="k5XwOH.png" /></a>
<img src="https://s2.ax1x.com/2019/02/25/k5Xykt.png" alt="k5Xykt.png" />

<hr />

<h1>卡特兰数有什么用</h1>

<blockquote>
  此处内容借鉴了:https://blog.csdn.net/wu_tongtong/article/details/78161211
</blockquote>

<h3>1.括号匹配类计数问题：</h3>

　　给你n个左括号,n个右括号,问有多少种合法的括号放置方案 
　　eg. ()()()是合法的方案，)( 是不合法的方案

　　能抽象为这类问题的题目，其方案数就是卡特兰数
　　例题：luogu P3200 有趣的数列

<h2>2.出栈次序问题</h2>

　　有1-n个元素，依次进栈，问你有多少种合法的出栈方案

　　能抽象为这类问题的题目，其方案数也是卡特兰数。

　　例子：
　　　　有2n个人去餐厅吃饭，有n个人有10块钱纸币，n个人有5块钱纸币，餐厅的饭卖5块钱一份，问有多少种可行的买饭顺序
　　　　我们可以抽象为：用5块钱买饭就入栈一次，用10块钱买饭就出栈一次

<h2>3.二叉树形态数问题</h2>

　　有n个叶子，问你有多少个形态不同的二叉树

　　这种类型的题目方案数就是卡特兰数

　　暂无例子( ･´ω`･ )]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>190</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 09:53:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 09:53:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8d%a1%e7%89%b9%e5%85%b0%e6%95%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[289]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>边双学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e8%be%b9%e5%8f%8c%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 09:56:31 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=192</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是边双？</h1>

<blockquote>
  双连通分量又分点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量。求双连通分量可用Tarjan算法。——百度百科
</blockquote>

用人话来说，就是在无向图上以边为关键字，对原图缩点

<hr />

<h1>为什么要学边双</h1>

与强连通分量类似，我们可以求出边双之后对原图缩点，使原图变为一个没有环的图，方便我们后续处理。

<hr />

<h1>边双怎么写</h1>

跟强连通分量做法一模一样，唯一的不同就是我们在取low的时候要小心一下不能取父节点，以防之前取回去

<hr />

<h1>例题：</h1>

luogu P2783 有机化学之神偶尔会做作弊
这题我们只需要对原图做边双缩点之后LCA直接前缀和做就好。

<pre><code class="language-cpp ">//Luogu P2783 有机化学之神偶尔会做作弊
//Nov,9th,2018
//边双
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;    
}
const int N=10000+100;
vector &lt;int&gt; e[N],e2[N];
int low[N],dfn[N],dfn_to,mstack[N],top,belong[N],cnt;
bool vis[N],InStack[N];
void Tarjan(int now,int fa)
{
    low[now]=dfn[now]=++dfn_to;
    vis[now]=InStack[now]=true;
    mstack[++top]=now;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            Tarjan(e[now][i],now);
            low[now]=min(low[now],low[e[now][i]]);
        }
        else if(e[now][i]!=fa and InStack[e[now][i]]==true)
            low[now]=min(low[now],low[e[now][i]]);
    if(dfn[now]==low[now])
    {
        cnt++;
        while(top&gt;0)
        {
            InStack[mstack[top]]=false;
            belong[mstack[top--]]=cnt;
            if(mstack[top+1]==now)
                break;
        }
    }
}
int n,m;
int fa[N][21],pre[N],depth[N];
void dfs(int now)
{
    vis[now]=true;
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i&lt;int(e2[now].size());i++)
        if(vis[e2[now][i]]==false)
        {
            depth[e2[now][i]]=depth[now]+1;
            fa[e2[now][i]][0]=now;
            pre[e2[now][i]]=pre[now]+1;
            dfs(e2[now][i]);
        }
}
int LCA(int x,int y)
{
    if(depth[x]&lt;depth[y]) swap(x,y);
    for(int i=20;i&gt;=0;i--)
        if(depth[x]-(1&lt;&lt;i)&gt;=depth[y])
            x=fa[x][i];
    if(x==y) return x;
    for(int i=20;i&gt;=0;i--)
        if(fa[x][i]!=fa[y][i])
            x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
void OutPut(int x)
{
    if(x==0)
    {
        printf("0");
        return;
    }
    int temp[50],ws=0;
    while(x&gt;0)
        temp[++ws]=x%2,x/=2;
    for(int i=ws;i&gt;=1;i--)
        printf("%d",temp[i]);
}
int main()
{
    //freopen("2783.in","r",stdin);
    //freopen("2783.out","w",stdout);

    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4),
        e2[i].reserve(4);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    Tarjan(1,1);
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;int(e[i].size());j++)
            if(belong[i]!=belong[e[i][j]])
                e2[belong[i]].push_back(belong[e[i][j]]);

    memset(vis,0,sizeof vis);
    pre[1]=1;
    dfs(1);

    int q=read();
    for(int i=1;i&lt;=q;i++)
    {
        int x=belong[read()],y=belong[read()],lca=LCA(x,y);
        int ans=pre[x]+pre[y]-pre[lca];
        if(lca!=1) ans-=pre[fa[lca][0]];
        OutPut(ans);
        printf("\n");
        //printf("%d\n",ans);
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>192</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 09:56:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 09:56:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%be%b9%e5%8f%8c%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e8%be%b9%e5%8f%8c-%e7%82%b9%e5%8f%8c"><![CDATA[边双/点双]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[339]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>裴蜀定理学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e8%a3%b4%e8%9c%80%e5%ae%9a%e7%90%86%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 09:58:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=194</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是裴蜀定理</h1>

<blockquote>
  裴蜀定理（或贝祖定理，Bézout's identity）得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约
  数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且（a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。
  ——百度百科
</blockquote>

用人话来说就是：

$\sum a_i*x_i=b$
上面的x有解当且仅当 $gcd(ai)|b$

<h1>例题</h1>

luogu P4549 【模板】裴蜀定理

<pre><code class="language-cpp ">//Luogu P4549 【模板】裴蜀定理
//Nov,9th,2018
//裴蜀定理模板提
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int gcd(int a,int b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
int main()
{
    int n=read();
    int ans;
    if(n&lt;2)
        ans=read();
    else
    {
        ans=gcd(read(),read());
        for(int i=3;i&lt;=n;i++)
            ans=gcd(ans,read());
    }

    printf("%d",ans&gt;0?ans:-ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>194</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 09:58:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 09:58:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%a3%b4%e8%9c%80%e5%ae%9a%e7%90%86%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[341]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>NOIp2018 滚粗记</title>
		<link>https://www.goldenpotato.cn/%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95/noip2018-%e6%bb%9a%e7%b2%97%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 10:02:16 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=196</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>DAY 1</h1>

<h3>8：30</h3>

总算拿到题目啦！
打开题目一看，T1T2T3全部512MB，1s，没有什么特别奇怪的时间限制的题目，题目应该可做(吧)。

<h3>8：32</h3>

啥废事都没做，直接开T1。
等等。。。。。。等一下下
这熟悉的题意。。。。。。
这不是神TM的积木大赛原题吗？
直接5min消灭，过了大样例，稳如老狗。

<h3>8：37</h3>

快速过了一眼T2,T3。T2好像不怎么可做，想了5分钟只会一个a^n的10分暴力。T3好像更不可做，想了5分钟没啥头绪，连暴力都不怎么会写。那还是去开T2好了。
在草稿纸上YY了一下，觉得这题跟裴蜀定理有这什么不可描述的关系，回头读题，不对啊，不能找零啊。
又YY了半个小时，想了想怎么优化之前那个a^n次方的暴力，感觉不怎么可以优化.......怎么办啊，要退役辣。
打了个哈欠冷静一下，猛然发现好像我们只会选之前有过的纸币，并不会新造别的面额的纸币出来。一看样例解释....好像蜜汁有道理。
就酱，我的复杂度成功优化到了2^n,总算能得50分辣，（但是还是要退役）
赶紧花了10分钟敲完了暴力，过了一下样例，结论应该没有猜错。
下一秒，我就想出了怎么优化这个暴力：我们能组合出来的面额的钞票一定不会使用。
然后又花了10分钟去敲了一个优化后的暴力，即我们不枚举哪些不可能使用的钞票。
等等.......我怎么感觉不用枚举？
当然不用枚举啊喂 (*´ﾉ皿`) ，我们都把能组合的去掉了，再不用剩下的纸币一定会gg啊。
又花了10分钟敲了个数据生成器跑对拍，对拍没啥问题，稳如老狗。

<h3>9：15</h3>

辣么快就到T3了，今天应该很稳啊。(<em>/ω＼</em>)
掏出草稿纸开始yy，最小值最大....emmmmmm，这显然二分鸭。
那怎么判断呢........gg
想了半个小时，还是没啥头绪，有点点虚，就去上了个厕所冷静一下。
回来路上发现我们好像可以用树形DP来搞二叉树和m=1的链的情况。
问题是暴力怎么写啊w
又想了10分钟，好像我们可以直接每次暴力枚举选哪条路，判断一下可不可行就好。
接下来当然是写写写写写啦。
10min敲完大暴力，直接过前两个样例，稳。
20min敲完链的树形DP，又花了10min写对拍，没有拍出任何错误，稳。
20min敲完二叉树的树形DP,又花了5min改数据生成器，结果并拍不上，不稳了
猛然发现我犯了一个很脑残的细节错误，改了改就能过对拍了，稳

<h3>11:30</h3>

总算弄好了，拍也拍上了，如果没啥意外的话应该就这样了吧。
剩下半个小时没能做啥事，也就对拍一下，检查一下拼写，检查数据范围，也就结束了。

<h3>12:10</h3>

woc，好像T3的根节点不一定只有两个叉，（怕不是要gg）（出题人应该不会卡吧）
woc，人均AK，我又要被暴打了
woc，dalao们居然玩了1个小时贪吃蛇，太强了

<hr />

<h1>DAY 2</h1>

<h3>8:30</h3>

早有耳闻昨天晚上紧急换题，今天会难到起飞。
一眼T1:woc,这不是SB题吗？我们只需要每次贪心的选能到达的点中编号最小的就好啦。
然后5min敲完，一测，并不能过样例。
回头去读题目：woc，我看错题了，走过的点不能再回去。
那......好像不可做啊。
打个哈欠冷静一下，看一眼数据范围：m&lt;=n
.......
那个60分的树显然直接在树上贪心暴做就可以.....问题是剩下40分的gay环外向树怎么做.......
好像可以用一个很骚的贪心配合找环强行搞一波。
在草稿纸上yy了半个小时，感觉可能很难写，决定战略放弃一下，先去看T2T3，有空再回来写T1（flag）。

<h3>9:17</h3>

快速过了一眼T2和T3。T2:woc，这啥题啊，怎么看起来辣么不可做啊。T3:前44分显然是保安站岗原题啊，还有8分的随机树我们也是可以暴力维护一下的。
进过几轮思维上的挣扎，决定先去写T3。
花了30分钟快速打完了保安站岗那道题的代码，略作修改，直接取跑样例。
woc，怎么过不了“大”样例啊。
赶紧肉眼静态查错，没问题啊，没有任何地方写挂了。
woc，那怎么搞啊。
上了个厕所冷静一下，回来后直接在草稿纸上手玩样例。
不对啊，我手玩的结果和我的程序一模一样啊。
赶紧回头读题，猛然发现读错题了，这题要求每两个点之间都必须至少有一个人，和保安站岗并不同。
emmmmmm，好像更好维护了
又花了15分钟魔改之前写的DP，总算能“大”样例了。
此时已经10:00了，觉得还是先战略放缓一下那8分，先去看一眼T2好了（flag*2）

<h3>10:02</h3>

花了5分钟，总算彻底理解了题意，同时脑子里马上出现一个看起来可行的结论：每个格子的左下角那个格子一定比右上角那个格子更大才有可能满足题目要求。
花2分钟对着样例解释观察了一波，好像是对的。
那这个东西显然可以用状压暴力维护啊，然后再上个矩阵快速幂暴力优化一下就好了吧（数据范围也是这样说的）
为了求稳，先写了个暴力搜索验证一下想法。
拍了15分钟，拍好了，过了样例1，稳。
很不幸，这个东西并不能过样例2，事实上，样例2的答案为121，我的答案为144。
......
这就很尴尬了。
花了15分钟验证想法.....并没有问题鸭.....
那我写一个直接按题意模拟的暴力试试？
又过去了15分钟，我把更暴力的暴力打完了。
一测样例2，依旧是神TM的144。
黑人问号.jpg
难道我读错题了？？？
回头一个一个字读题，并没有啥问题啊。
.......
到这个时候，已经11点了，距离考试结束仅有1个小时了。难道真的要退役了？
不，还有希望，立马放弃T2，先把T3的8分先写了，再回去写不稳的T1。

<h3>11:02</h3>

根据往年的剧本，这个时候我应该要不就弃疗了，要不就在搞对拍。然而今年，我到现在连题都没写完。
凭借着17年单身的手速，以光速魔改了T3的暴力做法，把它成功地优化到了m*深度的复杂度。
然后当场爆写对拍，爆调代码，总算在11:30分的时候拍上了。

<h3>11:31</h3>

为了尽快写完T1，我赶紧对之前的做法简化了一波，并魔改了一下做法，变成了一个有可能写出来的东西。
当场爆写。
距离考试结束还有10分钟的时候，我写完了，但并过不了样例。
我快速写出来的代码一般都有成吨的问题，这次也逃不过一劫，我的代码有成吨的bug。
凉了，直到最后一刻我也没有调完T1。
最后还是没有检查后面的文件名和数组，祈祷自己不要写爆吧。

<h3>12:30</h3>

woc，T1我干嘛要写O（n）的SB贪心啊，我直接m*n暴力枚举那一条边被干掉不就好了吗？也许这就是题好人菜吧。

<hr />

<h1>DAY 1 + DAY 2</h1>

期望得分：100+100+75+60+10(?)+52=397(?) = gg

洛咕数据：100+100+65+60+25+52=402 = gg

牛客数据：100+100+65+60+15+52=392=进一步gg

咕咕f数据:100+100+60+60+15+44=379=滚回去学文化

比起上年，我有了30分的“巨大进步”

也许这就是颓的后果罢。

总体来说，DAY1发挥得比较正常，DAY2在解题策略上有严重失误，T2浪费了过多时间，为了追求一个看起来的正解花了太多的时间，却抛弃了能得到的T1的40分。这种错误正是我批判的，没想到，自己也会在正式比赛上成为自己批判的对象。

<hr />

<h3>update 2019/1/14</h3>

虽然我DAY2考得十分爆炸，但是还是凭着GX-10的成绩苟进了省选轮。

在这之后一定不能再颓了呢，这样下去怕不是要文化竞赛两爆零]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>196</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 10:02:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 10:02:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[noip2018-%e6%bb%9a%e7%b2%97%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%b8%b8%e8%ae%b0-%e8%87%aa%e9%97%ad%e8%ae%b0-%e6%bb%9a%e7%b2%97%e8%ae%b0"><![CDATA[游记/自闭记/滚粗记]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[458]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>11</wp:comment_id>
			<wp:comment_author><![CDATA[Dictoy.]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2172414507@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.175.244.10]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-04 03:05:13]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-04 03:05:13]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[好耶,沙发还空着ヾ(≧▽≦*)o.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>12</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.139.211.148]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-04 03:58:15]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-04 03:58:15]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[︿(￣︶￣)︿]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>11</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>淀粉质(点分治) 学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e6%b7%80%e7%b2%89%e8%b4%a8%e7%82%b9%e5%88%86%e6%b2%bb-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 10:05:43 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=198</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是<del>淀粉质</del>点分治？</h1>

就是把分治搬到树上，以某个点为根，分别分治处理子树的答案，再计算子树与子树间的答案的玄学算法。

举个例子：
如何求出一颗树上距离为K且所经过的点最少的点对？

对于这种题，我们可以把某个点（一般为重心）作为根，然后对左右子树递归处理，先分别得出左右子树的答案，再求出横跨两个子树之间的点对的答案。

<hr />

<h1>为什么要学淀粉质</h1>

对于上面那道题，如果我们用传统的暴力做法，最优的复杂度只能得到O(n2)的暴力枚举，但是如果我们用淀粉质来搞，我们就可以做到O(n∗logn)的复杂度（如果K很大的话，我们可能还得套个数据结构上去，复杂度就变成了O(n∗log2n)），我们就可以通过这类题目。

<hr />

<h1>怎么淀粉质啊</h1>

正如我们刚刚说说的，淀粉质的实质是选出一个点，对其左右子树分治，再计算组合不同子树的答案。

所以说，我们在处理某颗子树之前，必须先选出来一个点作为这个子树的根。

我们选的这个点，对我们复杂度的影响极其巨大。
我们可以考虑选重心，重心就是指如果这个点做为根，其任意一颗子树大小均不会超过总点树的1/2。
如果我们每次对子树分治的时候，新选的根是重心，那我们的树的总层数一定不会超过logn层。
对于找重心，我们每次都做一遍dfs就好。

<pre><code class="language-cpp ">int GetSize(int now)
{
    t_vis[now]=true;
    size[now]=1;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false)
            size[now]+=GetSize(e[now][i].to);
    t_vis[now]=false;
    return size[now];
}
int root,cnt;
void GetRoot(int now)
{
    t_vis[now]=true;
    int t_size=1,OK=true;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false)
        {
            GetRoot(e[now][i].to);
            if(size[e[now][i].to]&gt;cnt/2) OK=false;
            t_size+=size[e[now][i].to];
        }
    if(cnt-t_size&gt;cnt/2) OK=false;
    if(OK==true) root=now;
    t_vis[now]=false;
}
</code></pre>

选出来重心之后，我们就可以以重心为根分治了。
首先，我们显然可以递归处理子树，然后再处理跨越两个子树的情况。
对于我们上面讲的那道题，我们所需要求的就是跨过两个子树且距离为K的点对的数量。
我们可以考虑这样做：
我们先开一个桶来记录长度为x的路径的点的数量，然后对每颗子树先做两遍dfs，第一遍先去桶里找到目前的点为止，之前找到的子树中有没有K-dis_now的路径。第二遍我们再把到每个点的距离放到桶里面去。
搞完之后，我们可以再dfs一次来回溯掉之前加上的东西，如果我们直接memset的话，会T的。
<strong>注意：我们这里的dfs必须只能走已经分治完成的点，分治完成的点才是其儿子</strong>

<pre><code class="language-cpp ">void dfs2(int now,int dis,int t_cnt,int type)
{
    t_vis[now]=true;
    if(type==1 and K-dis&gt;=0)
        ans=min(ans,t_cnt+tot[K-dis]);
    if(type==2 and dis&lt;M)
        tot[dis]=min(tot[dis],t_cnt);
    if(type==3 and dis&lt;M)
        tot[dis]=inf;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(done[e[now][i].to]==true and t_vis[e[now][i].to]==false)
            dfs2(e[now][i].to,dis+e[now][i].w,t_cnt+1,type);
    t_vis[now]=false;
}
void dfs(int now)
{
    vis[now]=true;
    vector &lt;road&gt; son;
    son.reserve(32);
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i].to]==false)
        {
            cnt=GetSize(e[now][i].to);
            GetRoot(e[now][i].to);
            dfs(root);
            son.push_back(e[now][i]);
        }
    for(int i=0;i&lt;int(son.size());i++)
        dfs2(son[i].to,son[i].w,1,1),dfs2(son[i].to,son[i].w,1,2);
    for(int i=0;i&lt;int(son.size());i++)
        dfs2(son[i].to,son[i].w,1,3);
    done[now]=true;
}
</code></pre>

这样子搞，看起来时间复杂度很爆炸，其实并不大，因为我们最多有logn层，每层做n次，总复杂度也就只有O(n∗logn)

这样子，我们就搞定啦φ(>ω&lt;*)

<hr />

<h1>完整的代码</h1>

题目传送门：https://www.luogu.org/problemnew/show/P4149（题目稍有变动，但方法类似）

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=200000+100;
const int M=1000000+100;
const int inf=0x3f3f3f3f;
struct road
{
    int to,w;
    road (int A,int B)
    {
        to=A,w=B;
    }
};
vector &lt;road&gt; e[N];
int n,K;
bool vis[N],t_vis[N],done[N];
int size[N],cnt,root;
int GetSize(int now)
{
    t_vis[now]=true;
    size[now]=1;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false)
            size[now]+=GetSize(e[now][i].to);
    t_vis[now]=false;
    return size[now];
}
void GetRoot(int now)
{
    t_vis[now]=true;
    int t_size=1,OK=true;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false)
        {
            GetRoot(e[now][i].to);
            t_size+=size[e[now][i].to];
            if(size[e[now][i].to]&gt;(cnt/2))
                OK=false;
        }
    if(cnt-t_size&gt;(cnt/2))
        OK=false;
    if(OK==true) root=now;
    t_vis[now]=false;
}
int ans=inf,tot[M];
void dfs2(int now,int dis,int t_cnt,int type)
{
    t_vis[now]=true;
    if(type==1 and K-dis&gt;=0)
        ans=min(ans,t_cnt+tot[K-dis]);
    if(type==2 and dis&lt;M)
        tot[dis]=min(tot[dis],t_cnt);
    if(type==3 and dis&lt;M)
        tot[dis]=inf;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(done[e[now][i].to]==true and t_vis[e[now][i].to]==false)
            dfs2(e[now][i].to,dis+e[now][i].w,t_cnt+1,type);
    t_vis[now]=false;
}
void dfs(int now)
{
    vis[now]=true;
    vector &lt;road&gt; son;
    son.reserve(32);
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i].to]==false)
        {
            cnt=GetSize(e[now][i].to);
            GetRoot(e[now][i].to);
            dfs(root);
            son.push_back(e[now][i]);
        }
    for(int i=0;i&lt;int(son.size());i++)
        dfs2(son[i].to,son[i].w,1,1),dfs2(son[i].to,son[i].w,1,2);
    for(int i=0;i&lt;int(son.size());i++)
        dfs2(son[i].to,son[i].w,1,3);
    done[now]=true;
}
int main()
{
    n=read(),K=read();
    for(int i=1;i&lt;n;i++)
    {
        int s=read(),t=read(),w=read();
        e[s].push_back(road(t,w));
        e[t].push_back(road(s,w));
    }

    cnt=GetSize(1);
    GetRoot(1);
    memset(tot,0x3f,sizeof tot);
    tot[0]=0;
    dfs(root);

    if(ans&gt;N) ans=-1;
    printf("%d",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>198</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 10:05:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 10:05:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b7%80%e7%b2%89%e8%b4%a8%e7%82%b9%e5%88%86%e6%b2%bb-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[302]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4178]Tree</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p4178tree/</link>
		<pubDate>Mon, 25 Feb 2019 10:08:21 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=201</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P4178">洛谷</a>

<hr />

<h1>Solution</h1>

首先，长成这样的题目一定是淀粉质跑不掉了。

考虑到我们不知道K的大小，我们可以开一个splay来统计比某个数小的数的数量。

<a href="https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%80%E7%B2%89%E8%B4%A8%E7%82%B9%E5%88%86%E6%B2%BB-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">不会点分治的戳我</a>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=40000+100;
struct road
{
    long long w;
    int to;
    road(int A,long long B)
    {
        to=A,w=B;
    }
};
struct SBT
{
    #define root son[0][1]
    int fa[N],son[N][2],w[N],size[N],cnt[N],to;
    inline void update(int now)
    {
        size[now]=size[son[now][0]]+size[son[now][1]]+cnt[now];
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        fa[x]=z,son[z][y==son[z][1]]=x;
        son[y][!type]=son[x][type],fa[son[x][type]]=y;
        son[x][type]=y,fa[y]=x;
        update(y),update(x);
    }
    void splay(int now,int to)
    {
        while(fa[now]!=to)
        {
            if(now==son[fa[now]][fa[now]==son[fa[fa[now]]][1]] and fa[fa[now]]!=to)
                rotate(fa[now],now==son[fa[now]][0]),
                rotate(now,now==son[fa[now]][0]);
            else
                rotate(now,now==son[fa[now]][0]);
        }
    }
    inline void InitTree()
    {
        root=to=0;
    }
    inline void init(int now)
    {
        fa[now]=son[now][0]=son[now][1]=size[now]=w[now]=0;
    }
    void Insert(int num)
    {
        if(root==0)
        {
            root=++to;
            init(root);
            fa[root]=0;
            w[root]=num,cnt[root]=1,update(root);
            return;
        }
        int now=root,last=root;
        while(now!=0)
        {
            if(w[now]==num)
            {
                cnt[now]++;
                splay(now,0);
                return;
            }
            last=now,now=son[now][num&gt;w[now]];
        }
        now=++to,init(now);
        w[now]=num,cnt[now]=1;
        fa[now]=last,son[last][num&gt;w[last]]=now;
        update(now),splay(now,0);
    }
    int Query(int num)
    {
        int now=root,t_ans=0;
        while(now!=0)
        {
            if(num&gt;=w[now])
            {
                if(w[now]&gt;=w[t_ans]) t_ans=now;
                now=son[now][1];
            }
            else
                now=son[now][0];
        }    
        if(t_ans==0) return 0;
        splay(t_ans,0);
        return size[son[root][0]]+cnt[root];
    }
    #undef root
}sbt;
vector &lt;road&gt; e[N];
long long n,K;
bool vis[N],t_vis[N],done[N];
int size[N],cnt,root;
int GetSize(int now)
{
    t_vis[now]=true;
    size[now]=1;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false)
            size[now]+=GetSize(e[now][i].to); 
    t_vis[now]=0;
    return size[now];
}
void GetRoot(int now)
{
    t_vis[now]=true,size[now]=1;
    bool OK=true;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and vis[e[now][i].to]==false)
        {
            GetRoot(e[now][i].to); 
            size[now]+=size[e[now][i].to];
            if(size[e[now][i].to]&gt;cnt/2)
                OK=false;
        }
    if(cnt-size[now]&gt;cnt/2)    OK=false;
    if(OK==true)    root=now;
    t_vis[now]=0;
}
int ans;
void dfs2(int now,long long dis,int type)
{
    t_vis[now]=true;
    if(type==1 and K-dis&gt;=0)
        ans+=sbt.Query(K-dis);
    else if(type==2)
        sbt.Insert(dis);
    for(int i=0;i&lt;int(e[now].size());i++)
        if(t_vis[e[now][i].to]==false and done[e[now][i].to]==true)
            dfs2(e[now][i].to,dis+e[now][i].w,type);
    t_vis[now]=false;
}
void dfs(int now)
{
    //cerr&lt;&lt;now&lt;&lt;endl;
    vis[now]=true;
    vector &lt;road&gt; son;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i].to]==false)
        {
            cnt=GetSize(e[now][i].to);
            GetRoot(e[now][i].to);
            son.push_back(e[now][i]);
            dfs(root);
        }
    sbt.InitTree();
    sbt.Insert(0);
    for(int i=0;i&lt;int(son.size());i++)
        dfs2(son[i].to,son[i].w,1),dfs2(son[i].to,son[i].w,2);
    done[now]=true;
}
int main()
{
    freopen("4178.in","r",stdin);

    n=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;n;i++)
    {
        long long s=read(),t=read(),w=read();
        e[s].push_back(road(t,w));
        e[t].push_back(road(s,w));
    }
    K=read();

    cnt=GetSize(1);
    GetRoot(1);
    dfs(root);

    printf("%d",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>201</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 10:08:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 10:08:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4178tree]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="splay"><![CDATA[splay]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%82%b9%e5%88%86%e6%b2%bb"><![CDATA[点分治]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[353]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2387] [NOI2014]魔法森林</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p2387-noi2014%e9%ad%94%e6%b3%95%e6%a3%ae%e6%9e%97/</link>
		<pubDate>Mon, 25 Feb 2019 10:52:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=203</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2387">洛谷</a>

<hr />

<h1>Solution</h1>

这题的思想挺好的。

对于这种最大值最小类的问题，很自然的可以想到二分答案。很不幸的是，这题是双关键字排序的，我们怎么二分呢？
先二分a再二分b？怎么看都布星啊。
那a+b作为关键字二分？也布星啊。

那咋搞啊？
不如，我们换个想法，我们把其中一个关键字枚举，再看在这个关键字的限制下，另外一个尽可能小。
仔细想想，应该是能覆盖到所有的情况的。
所以说，我们可考虑这样做：我们先枚举a的大小（即所选的边的a必须小于这个值），在满足前者的条件下，使得从出发先到终点的路上的最大的b尽可能小。
对于第二个问题，是不是很眼熟？没错，这个问题就是著名的原题货车运输：我们要使得路径上经过的b值的最大值最小，这条路径一定是在以b为关键字的最小生成树上的（具体证明请移步货车运输那道题的题解）。

所以说，我们现在研究的问题就变为了如何快速的维护一个变化的最小生成树。
快速维护变化的树，我们可以很自然地想到使用LCT来维护。再结合我们之前维护动态最小生存树的知识：每加入一条边，它必定会连接两个点而形成一个环，我们要判断这条边是否会在新的生成树上，只需要看一下环上的最大的边权和这条边的关系就好了，如果这条边的边权比环上的最大值还要小，我们就可以把环上的那条最大的边断开，接上我们这条新的边。否则的话，这条边一定不会成为新的最小生成树的一部分。
所以说，我们的LCT只需要在每新加入一条边时，检查其连接的两端是否是联通的。如果不联通的话，加入这条边一定是没有问题的。如果联通的话，就把所连两端的链split出来，找到最大值，比较一下大小关系就好。
至于如何用LCT维护边，我的方法是用点来代替边，即一条边以一个有连向它的两个端点的边的点来替代。具体写法可以参照一下代码。

时间复杂度为$O(n∗logn∗logn)$

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int M=100000+100;
const int N=50000+100;
const int T=N+M;
struct road
{
    int s,t,a,b;
}e[M];
int n,m;
bool cmp(road x,road y)
{
    return x.a&lt;y.a;
}
struct LCT
{
    int son[T][2],fa[T],lazy[T],MAX[T],num[T],mstack[T],top;
    inline void Update(int x)
    {
        MAX[x]=0;
        if(num[MAX[son[x][0]]]&gt;=num[x] and num[MAX[son[x][0]]]&gt;=num[MAX[son[x][1]]])
            MAX[x]=MAX[son[x][0]];
        if(num[MAX[son[x][1]]]&gt;=num[x] and num[MAX[son[x][1]]]&gt;=num[MAX[son[x][0]]])
            MAX[x]=MAX[son[x][1]];
        if(num[x]&gt;=num[MAX[son[x][0]]] and num[x]&gt;=num[MAX[son[x][1]]])
            MAX[x]=x;
    }
    inline void Mirror(int x)
    {
        lazy[x]=!lazy[x],swap(son[x][0],son[x][1]);
    }
    inline void PushDown(int x)
    {
        if(lazy[x]==0) return;
        lazy[x]=0;
        Mirror(son[x][0]),Mirror(son[x][1]);
    }
    inline bool IsRoot(int x)
    {
        return x!=son[fa[x]][0] and x!=son[fa[x]][1];
    }
    inline void Rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        if(IsRoot(y)==false)    son[z][y==son[z][1]]=x;
        fa[x]=z;
        son[y][!type]=son[x][type],fa[son[x][type]]=y;
        son[x][type]=y,fa[y]=x;
        Update(y),Update(x);
    }
    inline void Splay(int x)
    {
        mstack[top=1]=x;
        for(int i=x;i!=0;i=fa[i])
            mstack[++top]=fa[i];
        for(int i=top;i&gt;=1;i--)
            PushDown(mstack[i]);
        while(IsRoot(x)==false)
        {
            if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and IsRoot(fa[x])==false)
                Rotate(fa[x],x==son[fa[x]][0]),
                Rotate(x,x==son[fa[x]][0]);
            else
                Rotate(x,x==son[fa[x]][0]);
        }
    }
    void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            Splay(x),son[x][1]=t,fa[t]=x,Update(x);
    }
    inline void MakeRoot(int x)
    {
        Access(x),Splay(x);
        Mirror(x);
    }
    inline int FindRoot(int x)
    {
        Access(x),Splay(x);
        while(son[x][0]!=0)
            PushDown(x),x=son[x][0];
        Splay(x);
        return x;
    }
    inline void Link(int x,int y)//x-&gt;y
    {
        if(FindRoot(x)==FindRoot(y)) return;
        MakeRoot(x);
        fa[x]=y;
    }
    inline void Split(int x,int y)//root:y
    {
        MakeRoot(x);
        Access(y),Splay(y);
    }
    inline void Cut(int x,int y)
    {
        Split(x,y);
        if(x==son[y][0] and fa[x]==y)
        {
            son[y][0]=fa[x]=0;
            Update(y);
        }    
    }
    inline int Query(int x,int y)
    {
        MakeRoot(x);
        Access(y),Splay(y);
        return MAX[y];
    }
    inline void AddLine(int x)
    {
        if(e[x].s==e[x].t) return;//自环
        num[n+x]=e[x].b,MAX[n+x]=n+x;
        if(FindRoot(e[x].s)!=FindRoot(e[x].t))
        {
            Link(n+x,e[x].s),Link(n+x,e[x].t);
            return ;
        }
        int t=Query(e[x].s,e[x].t);
        if(num[n+x]&lt;num[t])
        {
            Cut(e[t-n].s,t);
            Cut(e[t-n].t,t);
            Link(e[x].s,n+x);
            Link(e[x].t,n+x);
        }
    }
    inline int Query2()
    {
        if(FindRoot(n)!=FindRoot(1)) return 0x3f3f3f3f;
        return num[Query(1,n)];
    }
}lct;
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
        e[i].s=read(),e[i].t=read(),e[i].a=read(),e[i].b=read();

    sort(e+1,e+1+m,cmp);
    int ans=0x3f3f3f3f;
    for(int i=1;i&lt;=m;i++)
    {
        lct.AddLine(i);
        ans=min(ans,e[i].a+lct.Query2());
    }

    if(ans==0x3f3f3f3f)
        printf("-1"); 
    else
        printf("%d",ans);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>203</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 10:52:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 10:52:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2387-noi2014%e9%ad%94%e6%b3%95%e6%a3%ae%e6%9e%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[404]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>LCT学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/lct%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 11:04:44 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=205</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>为啥要学LCT啊</h1>

在开坑之间，我们来先看一段对话：

Q：给你一颗森林，现在不断的连接森林中的两棵树，保证不连出环，多次问你某两个点的连通性？
A（dalao&amp;蒟蒻）：这不是SB题吗？显然并查集水过啊。
Q：说的好，但是如果我要删除某些边呢？
<del>A（dalao）：那就可持久化并查集啊，你的问题怎么那么水。</del>
A（蒟蒻）：........（发出gg的声音）

这时候，如果我们并不想写可持久化并查集的话，就得请出我们大名鼎鼎的林特卡特树了。

<hr />

<h1>啥是林特卡特树啊</h1>

LCT实质上就是用splay+树剖思想维护的动态森林。

用人话来说，<strong>就是维护一个可以随便删边和连边的森林（注：不能连出环来）</strong>

LCT的基础功能有：
　　1.连接森林中的两棵树或删除某条边
　　2.维护这颗森林的连通性
　　3.内定森林中某颗树的根

事实上，LCT还可以做一些包括但不限于维护一些奇奇怪怪的值的鬼畜操作。

<hr />

<h1>咋林特卡特树啊</h1>

首先呢，我们的得先了解LCT树[注1]与原森林的关系。

我们的LCT树是由一堆连通块组成的，一个连通块就是原森林中的一颗树。
而每个连通块又由一堆splay组成，每个splay可以理解为每颗原树中树链剖分上的重边。splay与splay之间又有连接关系，即一颗splay的根单向连到另外一颗splay的孩子上，这一堆有单向关系的splay就构成了一个联通块。（可以对应的理解为一个树的树链剖分是有一堆重链组成的，重链在这里以splay的形式出现）。

注1：（虽然这样叫是绝对不正确的，因为T就是tree的缩写，但是为了与LCT算法分开来，我们姑且把LCT维护的东西叫做LCT树）

<h3>Acess：</h3>

由上定义可以看出，我们要对某个点操作，首先要把这个点的连通块给提到LCT树的根上来（可以类比为splay到根上来），然后还要把这个splay连到到LCT树的根所在的重链上去。
听起来很复杂对不对？的确挺复杂。但是这个操作是LCT最基本的操作，其他所有操作都围绕着它展开。

具体原理可以参考这篇博客的介绍，这里只讲做法：

我们把当前操作的点先splay至它所在的splay的根，把这个根的右孩子连至上一次这样操作的根（即连一条重链），对当前点的父亲重复这个过程。

大概是长成这样：

<pre><code class="language-cpp ">inline void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            Splay(x),son[x][1]=t,fa[t]=x,Update(x);//注意这里的update，因为孩子关系变了，要更新根节点的数据
</code></pre>

<h3>GetRoot:</h3>

我们要判断原森林中两个点的连通性，你第一反应是什么？没错，我们只需要判断它们的根是否相同就可以了。因此，我们这里就需要一个getroot函数来得到每个点的根。

方法很简单：我们只需要先Acess这个点使得它所在的splay连通块作为LCT森林的根，把这个点splay到根，再一路向左找就好（因为原树中的根的深度一定是最小的）

代码大概长这样：

<pre><code class="language-cpp ">inline int FindRoot(int x)
    {
        Access(x),Splay(x);
        while(son[x][0]!=0)
            PushDown(x),x=son[x][0];
        Splay(x);//这里splay是为了让这个点所在的splay更平衡一点
        return x;
    }
</code></pre>

<h3>MakeRoot:</h3>

我们既然维护的是一颗动态的森林，那难免会有连边和删边。为了操作的方便，有时我们需要内定一个点作为原森林中的它所在的树的根。

具体做法是这样的：我们先把它Acess(x),splay(x)，让它先处于LCT森林的根，然后在把它的左右子树彻底翻转（即每个孩子都翻转），这里可以通过打标记来降低复杂度。（原理请看上面的链接的博客）

代码这样：

<pre><code class="language-cpp ">inline void MakeRoot(int x)
    {
        Access(x),Splay(x);
        Mirror(x);
    }
</code></pre>

<h3>Link:</h3>

LCT既然维护了一个森林，连连边都做不了，岂不是很丢人？

link的意思是连接原森林中的一条边。

我们只需要这样做：先getroot来判断一下他们是否已经在同一颗树上了，然后makeroot（x）来内定x作为它所在的树的根，再指定一下它的父亲为y即可（即连一条轻边）

<pre><code class="language-cpp ">inline int Link(int x,int y)//x-&gt;y
    {
        if(FindRoot(x)==FindRoot(y))    return 1;
        MakeRoot(x);
        fa[x]=y;
        return 0;
    }
</code></pre>

<h3>Split：</h3>

我们有时候要在LCT中拉出原森林中的一条边来获取信息或搞点事情，因此，我们需要一个函数来处理这破事。

我们只需要先内定x为根，然后再Acess(y)，splay(y)，此时，如果这条边存在的话，那么x一定是y的左孩子（因为它们深度相邻且x比y浅）

代码长这样：

<pre><code class="language-cpp ">inline void Split(int x,int y)//y为根
    {
        MakeRoot(x);
        Access(y),Splay(y);
    }
</code></pre>

<h3>Cut</h3>

LCT的意义就在于此（如果不能Cut，那连并查集都不如，人家一个log，LCT两个log呢），我们需要删除原森林中的一条边的时候，就需要cut操作了。

具体方法如下：先把这条边拉出来(Split)，然后再检查一下边是否存在，存在的话双向断边即可。

代码长这样：

<pre><code class="language-cpp ">inline int Cut(int x,int y)
    {
        Split(x,y);
        if(fa[x]==y and son[y][0]==x)
        {
            fa[x]=son[y][0]=0;
            Update(y);
            return 0;
        }
        return 1;
    }
</code></pre>

以上就是LCT的基本操作啦，如果有别的需求，我们可以在splay上多记录一点东西（正如之前专门考splay的题一样）就可以搞定啦。

恭喜你学会了LCT，撒花✿✿ヽ(°▽°)ノ✿

<hr />

<h1>有啥题目练啊</h1>

1.P2147 [SDOI2008]洞穴勘测 （LCT维护森林连通性）
2.P3203 [HNOI2010]弹飞绵羊 （LCT维护森林中的每棵树的长度）
3.P2168 [NOI2015]荷马史诗  （LCT维护边权和）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>205</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:04:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:04:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[lct%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[404]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[LuoguP2147] [SDOI2008]洞穴勘测</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogup2147-sdoi2008%e6%b4%9e%e7%a9%b4%e5%8b%98%e6%b5%8b/</link>
		<pubDate>Mon, 25 Feb 2019 11:07:56 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=207</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2147">洛谷</a>

<hr />

<h1>Solution</h1>

这题......

我们可以发现题目要求我们维护一个动态森林，而且只查询连通性....

显然LCT模板题啊，关于LCT玩法，可以<a href="https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lct%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">猛戳这里学习</a>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=10000+100;
struct LCT
{
    int fa[N],son[N][2],lazy[N],mstack[N],top;
    inline bool isRoot(int x)
    {
        return x!=son[fa[x]][0]&amp;&amp;x!=son[fa[x]][1];
    }
    inline void pushdown(int x)
    {
        if(lazy[x]==0) return;
        lazy[son[x][0]]=!lazy[son[x][0]],swap(son[son[x][0]][0],son[son[x][0]][1]);
        lazy[son[x][1]]=!lazy[son[x][1]],swap(son[son[x][1]][0],son[son[x][1]][1]);
        lazy[x]=0;
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        if(isRoot(y)==false)    son[z][y==son[z][1]]=x;
        fa[x]=z;
        fa[son[x][type]]=y,son[y][!type]=son[x][type];
        son[x][type]=y,fa[y]=x;
    }
    void splay(int x)
    {
        mstack[top=1]=x;
        for(int i=x;isRoot(i)==false;i=fa[i])
            mstack[++top]=fa[i];
        for(int i=top;i&gt;=1;i--)
            pushdown(mstack[i]);
        while(isRoot(x)==false)
        {
            if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and isRoot(fa[x])==false)
                rotate(fa[x],x==son[fa[x]][0]),
                rotate(x,x==son[fa[x]][0]);
            else
                rotate(x,x==son[fa[x]][0]);
        }
    } 
    void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            splay(x),son[x][1]=t;
    }
    void MakeRoot(int x)
    {
        Access(x);
        splay(x);
        lazy[x]=!lazy[x],swap(son[x][0],son[x][1]);
    }
    int FindRoot(int x)
    {
        Access(x),splay(x);
        while(son[x][0]!=0)
            pushdown(x),x=son[x][0];
        return x;    
    }
    void Link(int x,int y)
    {
        MakeRoot(x);
        fa[x]=y;
    }
    void split(int x,int y)
    {
        MakeRoot(x);
        Access(y),splay(y);
    }
    void Cut(int x,int y)
    {
        split(x,y);
        son[y][0]=fa[x]=0;
    }
}lct;
int n,m;
int main()
{
    n=read(),m=read();

    char OP[15];
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%s",OP+1);
        int u=read(),v=read();
        if(OP[1]=='C')
            lct.Link(u,v);
        else if(OP[1]=='D')
            lct.Cut(u,v);
        else
        {
            if(lct.FindRoot(u)==lct.FindRoot(v))
                printf("Yes\n");
            else
                printf("No\n");
        }
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>207</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:07:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:07:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogup2147-sdoi2008%e6%b4%9e%e7%a9%b4%e5%8b%98%e6%b5%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[309]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3203] [HNOI2010]弹飞绵羊</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3203-hnoi2010%e5%bc%b9%e9%a3%9e%e7%bb%b5%e7%be%8a/</link>
		<pubDate>Mon, 25 Feb 2019 11:10:25 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=209</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3203">洛谷</a>

<hr />

<h1>Solution</h1>

这题其实是有类似模型的。

我们先考虑不修改怎么写。考虑这样做：每个点向它跳到的点连一条边，最后肯定会连成一颗以n+1为根的树（我们拿n+1代表被弹出去了）。题目所问的即是某个点到树根的链的长度。

那么，如果我们加上修改，显然，某个点连向的点会发生改变。对于一个能修改边的树，我们可以很自然的想到用LCT维护之。
至于怎么求某条链的长度呢？这也是LCT的基础操作之一，我们只需要先MakeRoot（n+1），然后再Acess（x），splay（x）就可以把这条链拉出来了，我们维护splay的size就好。
如果您看不懂上面这句话，请戳我来学习<a href="https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lct%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">LCT与原树的对应关系</a>

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P3203 [HNOI2010]弹飞绵羊
//Jan,9th,2018
//LCT模板题II
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=200000+100;
int n,m;
struct LCT
{
    int son[N][2],fa[N],lazy[N],mstack[N],top,size[N];
    inline bool isRoot(int x)
    {
        return x!=son[fa[x]][0] &amp;&amp; x!=son[fa[x]][1];
    }
    inline void update(int x)
    {
        size[x]=size[son[x][0]]+size[son[x][1]]+1;
    }
    inline void mirror(int x)
    {
        lazy[x]=!lazy[x],swap(son[x][0],son[x][1]);
    }
    inline void pushDown(int x)
    {
        if(lazy[x]==0) return;
        lazy[x]=0;
        mirror(son[x][0]),mirror(son[x][1]);
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        if(isRoot(y)==false)
            son[z][y==son[z][1]]=x;
        fa[x]=z;
        son[y][!type]=son[x][type],fa[son[x][type]]=y;
        son[x][type]=y,fa[y]=x;
        update(y),update(x);
    }
    void splay(int x)
    {
        mstack[top=1]=x;
        for(int i=x;isRoot(i)==false;i=fa[i])
            mstack[++top]=fa[i];
        for(int i=top;i&gt;=1;i--)
            pushDown(mstack[i]);
        while(isRoot(x)==false)
        {
            if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and isRoot(fa[x])==false)
                rotate(fa[x],x==son[fa[x]][0]),
                rotate(x,x==son[fa[x]][0]);
            else
                rotate(x,x==son[fa[x]][0]);
        }
    }
    void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            splay(x),son[x][1]=t,fa[t]=x,update(x);
    }
    inline void MakeRoot(int x)
    {
        Access(x),splay(x);
        mirror(x);
    }
    inline void Link(int x,int y)//x翻为根连向y
    {
        MakeRoot(x);
        fa[x]=y;
    }
    inline void split(int x,int y)//y为根
    {
        MakeRoot(x);
        Access(y),splay(y);
    }
    inline void Cut(int x,int y)
    {
        split(x,y);
        son[y][0]=fa[x]=0;
        update(y);
    }
    int Query(int x)
    {
        MakeRoot(n+1);
        Access(x),splay(x);
        return size[x]-1;
    }
}lct;
int q[N];
int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        q[i]=read();

    for(int i=n;i&gt;=1;i--)
        if(i+q[i]&gt;n)
            lct.Link(i,n+1);
        else
            lct.Link(i,i+q[i]);
    m=read();
    for(int i=1;i&lt;=m;i++)
    {
        int op=read();
        if(op==1)
        {
            int x=read()+1;
            printf("%d\n",lct.Query(x));
        }
        else
        {
            int x=read()+1,K=read();
            if(x+q[x]&gt;n)
                lct.Cut(x,n+1);
            else
                lct.Cut(x,x+q[x]);
            q[x]=K;
            if(x+q[x]&lt;=n)
                lct.Link(x,x+q[x]);
            else
                lct.Link(x,n+1);
        }
    }
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>209</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:10:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:10:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3203-hnoi2010%e5%bc%b9%e9%a3%9e%e7%bb%b5%e7%be%8a]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[316]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3157][CQOI2011]动态逆序对</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3157cqoi2011%e5%8a%a8%e6%80%81%e9%80%86%e5%ba%8f%e5%af%b9/</link>
		<pubDate>Mon, 25 Feb 2019 11:14:26 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=211</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3157">洛谷</a>

<hr />

<h1>Solution</h1>

一开始我看到pty巨神写这套题的时候，第一眼还以为是个SB题：这不直接开倒车线段树统计就完成了吗？
然后冷静思考了一分钟，猛然发现单纯的线段树并不能解决这个问题，好像还要在外面再套上一颗树。
这就很shit了。你问我资磁不资磁树套树，我是不资磁的，树套树是暴力数据结构，我能资磁吗？
很不幸，昨天现实狠狠地打了我一脸：时间不够开新坑的，不切题又浑身难受，找了半天题，还是把这道题拉了出来（哈，真香）

不扯淡了，这题还是很显然的。
考虑开倒车，我们一个一个往里面加树，然后统计一下这个数能对当前的数列有多少贡献，贡献很容易想到：我们只需要找到在他后面比他小的数以及在他前面比他大的数就好。
然后本蒟蒻写了个蜜汁线段树套splay。
时间复杂度是$O(n∗log2n)$，空间复杂度为$O(n∗logn)$。理论上应该能过
可惜现实非常苦感：
<a href="https://imgchr.com/i/kIkYtg"><img src="https://s2.ax1x.com/2019/02/25/kIkYtg.md.png" alt="kIkYtg.md.png" /></a>

.....

那咋搞啊。
那我上个线段树套权值线段树吧
然后又码了半个小时。
时空复杂度均为$O(n∗log2n)$ (这明显要MLE啊，问题是题解蜜汁能过)
可惜现实依旧苦感：
<a href="https://imgchr.com/i/kIkthQ"><img src="https://s2.ax1x.com/2019/02/25/kIkthQ.md.png" alt="kIkthQ.md.png" /></a>

难道，改数据了？
接着，我copy了一发题解，交上去，A掉了.......
到目前为止，我还是想不通为啥开同样的数组，他A了，我T了。难道说他外层套的树状数组可以有效减少空间的消耗？

想不通，还请各位dalao赐教。

<hr />

<h1>Code （并不能A）</h1>

<h2>线段树套splay：</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+1000;
struct TreeInTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    #define root son[r][1]
    static const int M=N*25;
    int fa[M],son[M][2],size[M],cnt[M],num[M],to;
    inline void update(int x) 
    {
        size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x];
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        son[z][y==son[z][1]]=x,fa[x]=z;
        son[y][!type]=son[x][type],fa[son[x][type]]=y;
        son[x][type]=y,fa[y]=x;
        update(y),update(x);
    }
    void splay(int x,int to)
    {
        while(fa[x]!=to)
        {
            if(x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]] and fa[fa[x]]!=to)
                rotate(fa[x],x==son[fa[x]][0]);
            rotate(x,x==son[fa[x]][0]);
        }
    }
    void Insert(int w,int r)
    {
        if(root==0)
        {
            root=++to,fa[root]=r;
            num[root]=w,update(root);
            return;
        }
        int now=root,last=root;
        while(now!=0)
            last=now,now=son[now][w&gt;num[now]];
        now=++to,fa[now]=last,son[last][w&gt;num[last]]=now;
        num[now]=w,update(now);
        splay(now,r);
    }
    int Query1(int x,int r)
    {
        int now=root,ans=0;
        while(now!=0)
        {
            if(num[now]&gt;=x)
                now=son[now][0];
            else
            {
                if(num[now]&gt;num[ans]) ans=now;
                now=son[now][1];
            }
        }
        if(ans==0) return 0;
        splay(ans,r);
        return size[son[ans][0]]+cnt[ans];
    }
    int Query2(int x,int r)
    {
        int now=root,ans=0;
        num[0]=0x3f3f3f3f;
        while(now!=0)
        {
            if(num[now]&gt;x)
            {
                if(num[now]&lt;num[ans]) ans=now;
                now=son[now][0];
            }
            else
                now=son[now][1];
        }
        num[0]=0;
        if(ans==0) return 0;
        splay(ans,r);
        return size[son[ans][1]]+cnt[ans];
    }
    int t[N&lt;&lt;2];
    void Build(int now,int now_l,int now_r)
    {
        t[now]=++to;
        if(now_l==now_r) return;
        Build(lson,now_l,mid);
        Build(rson,mid+1,now_r);
    }
    inline void Insert2(int x,int w,int now,int now_l,int now_r)
    {
        Insert(w,t[now]);
        if(now_l!=now_r)
        {
            if(x&lt;=mid)    Insert2(x,w,lson,now_l,mid);
            else Insert2(x,w,rson,mid+1,now_r);
        }
    }
    int Query3(int l,int r,int w,int type,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            if(type==1) return Query1(w,t[now]);
            else return Query2(w,t[now]);
        }
        int sum=0;
        if(l&lt;=mid) sum+=Query3(l,r,w,type,lson,now_l,mid);
        if(r&gt;mid) sum+=Query3(l,r,w,type,rson,mid+1,now_r);
        return sum;
    }
    #undef mid
    #undef lson
    #undef rson
}tit;
int n,m,p[N],q[N],unOK[N];
long long ans[N];
int main()
{    
    freopen("3157.in","r",stdin);
    freopen("3157.out","w",stdout);

    int t=clock();
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        p[read()]=i;
    for(int i=1;i&lt;=m;i++)
        q[i]=read(),unOK[q[i]]=true;

    tit.Build(1,1,n);
    for(int i=1;i&lt;=n;i++)
        if(unOK[i]==false)
        {
            tit.Insert2(p[i],i,1,1,n);
            ans[m+1]+=tit.Query3(p[i],n,i,1,1,1,n)+tit.Query3(1,p[i],i,2,1,1,n);
        }
    for(int i=m;i&gt;=1;i--)
    {
        tit.Insert2(p[q[i]],q[i],1,1,n);
        ans[i]=ans[i+1]+tit.Query3(p[q[i]],n,q[i],1,1,1,n)+tit.Query3(1,p[q[i]],q[i],2,1,1,n);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%lld\n",ans[i]);
    cerr&lt;&lt;clock()-t&lt;&lt;endl;
    return 0;
}
</code></pre>

<h2>线段树套权值线段树</h2>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+1000;
int n,m,p[N],q[N],unOK[N];
long long ans[N];
struct TreeInTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    static const int M=N*200;
    int son[M][2],num[M],to;
    inline void update(int x) 
    {
        num[x]=num[son[x][0]]+num[son[x][1]];
    }
    void Insert(int x,int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            num[now]++;
            return;
        }
        if(now&gt;to) 
            cerr&lt;&lt;to;
        if(x&lt;=mid)
        {
            if(son[now][0]==0) son[now][0]=++to;
            Insert(x,son[now][0],now_l,mid);
        }
        else
        {
            if(son[now][1]==0) son[now][1]=++to;
            Insert(x,son[now][1],mid+1,now_r);
        }
        update(now);
    }
    int Query1(int l,int r,int now,int now_l,int now_r)
    {
        if(l&gt;r) return 0;
        if((now_l&gt;=l and now_r&lt;=r) or now==0)
            return num[now];
        int t_ans=0;
        if(l&lt;=mid) t_ans+=Query1(l,r,son[now][0],now_l,mid);
        if(r&gt;mid) t_ans+=Query1(l,r,son[now][1],mid+1,now_r);
        return t_ans;
    }
    int t[N&lt;&lt;2];
    void Build(int now,int now_l,int now_r)
    {
        t[now]=++to;
        if(now_l==now_r) return;
        Build(lson,now_l,mid);
        Build(rson,mid+1,now_r);
    }
    inline void Insert2(int x,int w,int now,int now_l,int now_r)
    {
        Insert(w,t[now],1,n);
        if(now_l!=now_r)
        {
            if(x&lt;=mid)    Insert2(x,w,lson,now_l,mid);
            else Insert2(x,w,rson,mid+1,now_r);
        }
    }
    int Query3(int l,int r,int w,int type,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            if(type==1) return Query1(1,w-1,t[now],1,n);
            else return Query1(w+1,n,t[now],1,n);
        }
        int sum=0;
        if(l&lt;=mid) sum+=Query3(l,r,w,type,lson,now_l,mid);
        if(r&gt;mid) sum+=Query3(l,r,w,type,rson,mid+1,now_r);
        return sum;
    }
    #undef mid
    #undef lson
    #undef rson
}tit;
int main()
{    
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        p[read()]=i;
    for(int i=1;i&lt;=m;i++)
        q[i]=read(),unOK[q[i]]=true;

    tit.Build(1,1,n);
    for(int i=1;i&lt;=n;i++)
        if(unOK[i]==false)
        {
            tit.Insert2(p[i],i,1,1,n);
            ans[m+1]+=tit.Query3(p[i],n,i,1,1,1,n)+tit.Query3(1,p[i],i,2,1,1,n);
        }
    for(int i=m;i&gt;=1;i--)
    {
        tit.Insert2(p[q[i]],q[i],1,1,n);
        ans[i]=ans[i+1]+tit.Query3(p[q[i]],n,q[i],1,1,1,n)+tit.Query3(1,p[q[i]],q[i],2,1,1,n);
    }

    for(int i=1;i&lt;=m;i++)
        printf("%lld\n",ans[i]);
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>211</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:14:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:14:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3157cqoi2011%e5%8a%a8%e6%80%81%e9%80%86%e5%ba%8f%e5%af%b9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%a5%97%e6%a0%91"><![CDATA[树套树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[396]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>一些很妙的网站</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e4%b8%80%e4%ba%9b%e5%be%88%e5%a6%99%e7%9a%84%e7%bd%91%e7%ab%99/</link>
		<pubDate>Mon, 25 Feb 2019 11:16:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=214</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>米奇妙♂妙♂屋</h1>

<h2>1.妙不可言的一键作图网站</h2>

<a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a>

（抄自神仙lbc的博客）

<h2>2.妙妙识图网站</h2>

<a href="http://www.iqdb.org/">http://www.iqdb.org/</a>

<h2>3.妙妙图床</h2>

<a href="https://imgchr.com/">https://imgchr.com/</a>

<h2>4.妙妙sitemap自动生成网站</h2>

<a href="https://www.xml-sitemaps.com/">https://www.xml-sitemaps.com/</a>

<h2>5.不可描述</h2>

<a href="https://blog.sprov.xyz/2019/08/03/v2-ui/">https://blog.sprov.xyz/2019/08/03/v2-ui/</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>214</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:16:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:16:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e4%ba%9b%e5%be%88%e5%a6%99%e7%9a%84%e7%bd%91%e7%ab%99]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="post_tag" nicename="%e9%a2%93%e5%ba%9f"><![CDATA[颓废]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[456]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[UOJ 275/BZOJ4737] 【清华集训2016】组合数问题</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/uoj-275-bzoj4737-%e3%80%90%e6%b8%85%e5%8d%8e%e9%9b%86%e8%ae%ad2016%e3%80%91%e7%bb%84%e5%90%88%e6%95%b0%e9%97%ae%e9%a2%98/</link>
		<pubDate>Mon, 25 Feb 2019 11:18:17 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=216</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="http://uoj.ac/problem/275">UOJ</a>

<hr />

<h1>Solution</h1>

<del>这题的数位DP好蛋疼啊qwq</del>

好吧，我们说回正题。

首先，我们先回忆一下LUCAS定理：

<h3>$C_n^m \equiv C_{n/p}^{m/p} \times C_{n\%p}^{m\%p}   (\%p)$</h3>

我们仔细观察这个定理，就可以发现一个事实：LUCAS定理本质上是在对n，m两个数做K进制下的数位分离

所以说，LUCAS定理我们可以这样表示：

<h3>$C_n^m \equiv \prod C_{a_i}^{b_i}$</h3>

（ai与bi为K进制拆分后的两个数的每一位数，若<strong>一个数的位数不足另一个数，则以前导零填充</strong>）

我们要判断一个$C_n^m$是否能被K整除，只需要保证其中一个$C_{a_i}^{b_i}$能被K整除（即同余K为零）就好。

又因为K为质数，且ai，bi均小于K，<strong>所以说我们要使得$C_{a_i}^{b_i}$为0，必须有$b_i$>$a_i$</strong>
.

.

所以说，问题就变为了对于有多少个$(i,j)$使得$j$中某一位$>i$

这个新的问题显然可以用数位DP来解决。

在这里，我使用记忆化搜索来写（用记忆化可以减少讨论数）

考虑这样设状态：

<strong>设$f[x][0/1][0/1][0/1][0/1][0/1]$表示填到第$x$位，</strong>

<strong>i是否卡上界n，j是否卡上界m，j是否卡上界 $(j&lt;i)$,上一位是否为前导零（这道题不需要，但是为了模板完整性。我还是写上去了），之前是否有某一位达成需求，之后可以达成的总共的可行方案数</strong>

转移非常好讨论，我们只需要注意一下j的上界是两个限制的最小值就好。

我是这样写转移的：

<pre><code class="language-cpp ">for(int i=0;i&lt;=(limit1==true?l1[to]:K);i++)
    {
        int t_j=(limit2==true?l2[to]:K);
        t_j=(limit3==true?min(i,t_j):t_j);
        for(int j=0;j&lt;=t_j;j++)
        {
            t_ans+=dfs(to+1,limit1==true and i==l1[to],limit2==true and j==l2[to],limit3==true and j==i,zero==true and i==0,OK==true or j&gt;i);
            t_ans%=poi;
        }
    }
</code></pre>

这样子写，看起来时间复杂度是

$O(T&#42;n^2&#42;2^5)$

但是因为我们会少讨论很多没有意义的情况，所以说能跑得过去。

确切复杂度我不会算qwq

还请dalao们指点

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//BZOJ 4737: 组合数问题
//Jan,14th,2019
//LUCAS定理的运用+鬼畜数位DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int poi=1000000007;
const int N=70;
long long f[N][2][2][2][2][2];//到i位，底数卡不卡n，指数卡不卡m，指数卡不卡底数，zero，OK
int n,l1[N],l2[N],K;
long long dfs(int to,bool limit1,bool limit2,bool limit3,bool zero,bool OK)
{
    if(f[to][limit1][limit2][limit3][zero][OK]&gt;=0) return f[to][limit1][limit2][limit3][zero][OK];
    long long t_ans=0;
    if(to==n+1)
    {
        if(OK==true)
            t_ans=1;
        return f[to][limit1][limit2][limit3][zero][OK]=t_ans;
    }
    for(int i=0;i&lt;=(limit1==true?l1[to]:K);i++)
    {
        int t_j=(limit2==true?l2[to]:K);
        t_j=(limit3==true?min(i,t_j):t_j);
        for(int j=0;j&lt;=t_j;j++)
        {
            t_ans+=dfs(to+1,limit1==true and i==l1[to],limit2==true and j==l2[to],limit3==true and j==i,zero==true and i==0,OK==true or j&gt;i);
            t_ans%=poi;
        }
    }
    return f[to][limit1][limit2][limit3][zero][OK]=t_ans;
}
int main()
{
    int T=read();K=read();
    for(;T&gt;0;T--)
    {
        n=0;
        long long num1=read(),num2=read();
        num2=min(num1,num2);//防止m&gt;n

        while(num1!=0)
            l1[++n]=num1%K,num1/=K;
        for(int i=1;i&lt;=n;i++)
            l2[i]=num2%K,num2/=K;
        reverse(l1+1,l1+1+n);
        reverse(l2+1,l2+1+n);
        memset(f,0x80,sizeof f);
        K--;
        dfs(1,true,true,true,true,false);
        K++;

        printf("%lld\n",f[1][true][true][true][true][false]);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>216</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:18:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:18:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uoj-275-bzoj4737-%e3%80%90%e6%b8%85%e5%8d%8e%e9%9b%86%e8%ae%ad2016%e3%80%91%e7%bb%84%e5%90%88%e6%95%b0%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="lucas"><![CDATA[LUCAS]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%95%b0%e4%bd%8ddp"><![CDATA[数位DP]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[373]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4124] [CQOI2016]手机号码</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p4124-cqoi2016%e6%89%8b%e6%9c%ba%e5%8f%b7%e7%a0%81/</link>
		<pubDate>Mon, 25 Feb 2019 11:20:25 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=220</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P4124">洛咕</a>

<hr />

<h1>Solution</h1>

感谢神仙@lizbaka的教学

这题是数位DP的非常非常模板的题目，<del>只是状态有点多</del>

.

这题我使用记忆化搜索实现的

<del>中国有句古话说的好，</del>有多少个要求就设多少个状态。

所以说，考虑这样设置状态:

设$f[i][j][k][2][2][2][2][2]$表示<strong>当前填到第i位，上一位填了j，上两位填了k，是否卡上界，上一个数是否为前导零，是否有4，是否有8，是否出现了连续三个相同的数字，之后任意填的可行方案总数</strong>

使用记忆化搜索的话，转移是非常容易的，我们只需要像写搜索一样递归写下去就好

差不多长成这样：

<pre><code class="language-cpp ">for(int i=0;i&lt;=(limit==true?l[to]:9);i++)
    {
        if(zero==false or i!=0)
            t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],false,four or i==4,eight or i==8,ok==true or(last1==last2 and last2==i));
        else
            t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],true,false,false,false);
    }
</code></pre>

注：此题不用讨论前导零，但是我为了模板的完整性，也加上了。

<strong>注意，递归算法一定要有出口，这里也不例外，出口为i==n+1（即已经填完了）</strong>

具体写法还请看代码

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P4124 [CQOI2016]手机号码
//Jan,13rd,2019
//测试递归实现数位DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=20;
long long f[N][15][15][2][2][2][2][2];//位数，上一位，上两位，limit，zero，4，8，OK
int n,l[N];
long long dfs(int to,int last1,int last2,bool limit,bool zero,bool four,bool eight,bool ok)
{
    if(f[to][last1][last2][limit][zero][four][eight][ok]&gt;=0) 
        return f[to][last1][last2][limit][zero][four][eight][ok];
    long long t_ans=0;  
    if(to==n+1) 
    {
        if((four and eight)==false and ok==true)
            t_ans=1;
        return f[to][last1][last2][limit][zero][four][eight][ok]=t_ans; 
    }
    for(int i=0;i&lt;=(limit==true?l[to]:9);i++)
    {
        if(zero==false or i!=0)
            t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],false,four or i==4,eight or i==8,ok==true or(last1==last2 and last2==i));
        else
            t_ans+=dfs(to+1,i,last1,limit==true and i==l[to],true,false,false,false);
    }
    return f[to][last1][last2][limit][zero][four][eight][ok]=t_ans;
}
int main()
{
    long long ans[3];
    for(int i=1;i&lt;=2;i++)
    {
        long long t_num;
        scanf("%lld",&amp;t_num);
        if(i==1) t_num--;
        n=0;
        while(t_num!=0)
            l[++n]=t_num%10,t_num/=10;
        reverse(l+1,l+1+n);

        memset(f,0x80,sizeof f);
        dfs(1,0,0,true,true,false,false,false);

        ans[i]=f[1][0][0][true][true][false][false][false];
    }

    printf("%lld",ans[2]-ans[1]);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>220</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:20:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:20:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4124-cqoi2016%e6%89%8b%e6%9c%ba%e5%8f%b7%e7%a0%81]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%95%b0%e4%bd%8ddp"><![CDATA[数位DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[436]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SPOJ16607 IE1 - Sweets</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/spoj16607-ie1-sweets/</link>
		<pubDate>Mon, 25 Feb 2019 11:21:15 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=222</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：

<ul>
<li><a href="https://www.luogu.org/problemnew/show/SP16607">洛咕</a></li>
<li><a href="https://www.spoj.com/problems/IE1/">SPOJ</a></li>
</ul>

<hr />

<h1>Solution</h1>

这题的想法挺妙的。

.

首先，对于这种区间求答案的问题，我们一般都可以通过类似前缀和的思想一减来消去a，<strong>即求[a,b]的答案可以转化为求[1,b]-[1,a-1]</strong>

接下来我们可以先考虑一下每个物品数量不限制的做法。我们可以把这个问题类比为放球问题：我们要在n个相同的盒子里放x个球，这个问题可以用隔板法解决，<strong>显然答案为$C_{x+n-1}^{n-1}$</strong>

因为我们的n特别小，而且p为合数，所以可以用分解质因数的方法来算这个组合数。

.

接下来，我们可以考虑一下如何处理多计算的答案，考虑用容斥定理来解决这个问题。

不了解容斥定理的同志可以先看一下<a href="https://blog.csdn.net/m0_37286282/article/details/78869512">这篇文章</a>

我们要求的是至少有一个物品不满足要求的方案总数，即求所有不满足要求的方案的并。

根据容斥定理，这个并的值为 $\sum有一个物品不满足要求-有两个物品不满足要求+有三个物品不满足要求-...$

所以说，我们只需要强制某些物品先选$m_i+1$个，再按照上面的放球问题的公式来计算就可以得出有若干个物品不满足要求的方案数。

答案即为总方案数-不满足要求的方案数的并

时间复杂度$O(2^n*log_{max(a,b)})$

这个问题就被我们切掉啦ヽ(￣▽￣)ﾉ

.

如果有不清楚的地方可以看一下代码。

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu SP16607 IE1 - Sweets
//Jan,14th,2019
//容斥原理的应用
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int poi=2004;
const int N=15;
int prime[6]={-1,2,3,5,7};
long long C(long long x,long long y)//x为底，y为指
{
    if(y&gt;x) return 0;
    int cnt[6]={0};
    long long t_ans=1;
    for(long long i=x-y+1;i&lt;=x;i++)
    {
        long long t_num=i;
        for(int j=1;j&lt;=4;j++)
            while(t_num%prime[j]==0)
            {
                t_num/=prime[j];
                cnt[j]++;
            }
        t_ans=(t_ans*t_num)%poi;
    }
    for(long long i=1;i&lt;=y;i++)
    {
        long long t_num=i;
        for(int j=1;j&lt;=4;j++)
            while(t_num%prime[j]==0)
            {
                t_num/=prime[j];
                cnt[j]--;
            }
        }
    for(int i=1;i&lt;=4;i++)
        while(cnt[i]&gt;0)
            t_ans=(t_ans*prime[i])%poi,cnt[i]--;
    return t_ans;
}
int m[N],n,a,b;
long long t_ans2,t_x;
bool used[N];
void dfs(int now)
{
    if(now==n+1)
    {
        long long t_cnt=0,tot=0;
        for(int i=1;i&lt;=n;i++)
            if(used[i]==true)
                t_cnt+=m[i]+1,tot++;
        if(t_cnt&gt;t_x) return;
        long long f=(tot%2==1?-1:1);
        t_ans2+=f*C(t_x-t_cnt+n,n);
        t_ans2=(t_ans2%poi+poi)%poi;
        return;
    }
    for(int i=0;i&lt;=1;i++)
        used[now]=i,dfs(now+1);
}
long long Calc(long long x)
{
    t_ans2=0,t_x=x;
    dfs(1);
    return t_ans2;
}
int main()
{
    n=read(),a=read(),b=read();
    for(int i=1;i&lt;=n;i++)
        m[i]=read();

    printf("%lld",((Calc(b)-Calc(a-1))%poi+poi)%poi);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>222</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:21:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:21:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj16607-ie1-sweets]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%ae%b9%e6%96%a5-%e6%95%b0%e5%ad%a6"><![CDATA[容斥]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[245]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>扩展欧几里得算法+推论</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95%e6%8e%a8%e8%ae%ba/</link>
		<pubDate>Mon, 25 Feb 2019 11:21:55 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=224</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是扩展欧几里得？</h1>

扩展欧几里得算法是建立在欧几里得算法(gcd)之上。

首先，我们知道有$a<em>x+b</em>y=gcd(a,b)$

我们怎么求这个$x,y$呢？

这时候我们就得使用exgcd算法，我们来推导一下吧！

$a&#42;x+b&#42;y=gcd(a,b)$

$a&#42;x+b&#42;y=gcd(b,a\% b)$

$a&#42;x+b&#42;y=b&#42;x'+(a- \left \lfloor \frac{a}{b} \right \rfloor&#42;b)&#42;y'$

$a&#42;x+b*y= a&#42;y'+b&#42;(x'-\left \lfloor \frac{a}{b} \right \rfloor&#42;y')$

因此，根据系数对应，我们得到了

$x=y'$,$y=x'-\left \lfloor \frac{a}{b} \right \rfloor*y'$

那这个式子我们显然可以在递归里面顺带算出来嘛。

再想一想，我们gcd的递归出口为$b=0$，即$a*x=gcd(a,b)$,所以说我们的$x,y$的递归出口也为$x=1,y=0$

代码大概长这样qwq：

<pre><code class="language-cpp ">long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)
{
    if(B==0) 
    {
        x=1,y=0;
        return A;
    }
    long long t=exgcd(B,A%B,x,y),tx=x;
    x=y;
    y=tx-(A/B)*y;
    return t;
}
</code></pre>

酱紫，我们就求出了$x,y$的一组解$x_0,y_0$

<hr />

<h1>进一步推导</h1>

如果我们要求x的最小正整数解，那不免要求x的通项公式。

首先我们的推导建立在已经求出了一组$(x_0,y_0)$使得$a\times x+b\times y=gcd(a,b)$

我们要求的$x$的通项公式是建立在$x_0$之上的，我们假设$x=x_0+p$，$y=y_0-q$

现在问题就变为了如何求这个$p$。

原式变为：
$$a(x_0+p)+b(y_0-q)=gcd(a,b)$$

展开得：
$$a<em>x_0+a</em>p+b<em>y_0-q</em>b=gcd(a,b)$$

与原式$a<em>x_0+b</em>y_0=gcd(a,b)$相减得
$$ap=bq$$

$$p=\frac{b*q}{a}$$

我们设$d=gcd(a,b)$，有$a=a'<em>d$,$b=b'</em>d$

将上一个式子上下同时除以$d$得
$$p=\frac{b'*q}{a'}$$

因为$p$为正整数，因此我们的$q$至少等于$a'$才能使得$p$的取值最小
$$p=b&#42;\frac{a'}{a}=b&#42;\frac{1}{d}=b&#42;\frac{1}{gcd(a,b)}$$

解毕，我们得到了$x$的通项公式$x=x_0+k*\frac{b}{gcd(a,b)}$

.

完结撒花(*´ﾟ∀ﾟ｀)ﾉ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>224</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:21:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:21:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95%e6%8e%a8%e8%ae%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[359]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>扩展中国剩余定理学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e6%89%a9%e5%b1%95%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 11:23:01 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=226</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>为什么要扩展中国剩余定理？</h1>

建议学习前置芝士：中国剩余定理<del>（不学也不要紧，因为并没有啥关系）</del>

我们知道，中国剩余定理是用来解线性同余方程组的算法，类似下面这个：
$x \equiv a_0 (p_0)$
$x \equiv a_1 (p_1)$
$x \equiv a_2 (p_2)$

很不幸，这里要求$p_0,p_1,p_2$两两互质

.

如果不互质怎么办？<del>当然是把出题者拖出去吊起来打啊。</del>这时候就得有请我们的扩展中国剩余定理了。

<hr />

<h1>什么是扩展中国剩余定理？</h1>

如上说述，就是用来求线性同余方程组的定理，但不要求p两两互质。

<hr />

<h1>怎么扩展中国剩余定理？</h1>

中国剩余定理的基本原则是将原方程组两两合并直至只有一个方程。

那咋合并呢？

假设我们现在有两个同余方程：

$x \equiv a_0 (p_0)$

$x \equiv a_1 (p_1)$

我们可以先写出式子：

$x=p_0&#42;k_0+a_0=p_1&#42;k_1+a_1$

移项得（我们这里的k在R上任意取值，因此不用纠结它的符号）：

$p_0&#42;k_0+p_1&#42;k_1=a_1-a_0$

emmmmm，这个式子是不是有一点点眼熟？

没错，我们可以用exgcd来求这个$k_0$。

这里就引出了我们<strong>扩展中国剩余定理的有解的要求：$a_1-a_0$必须为$gcd(p_0,p_1)$的倍数</strong>

当然，我们右边的$a_1-a_0$不一定等于$gcd(p_0,p_1)$,因此，我们用exgcd算出来的$k_0$必须乘以$\frac{a_1-a_0}{gcd(p_0,p_1)}$

酱紫，我们将$k_0$膜$\frac{p_1}{gcd(p_0,p_1)}$来得到$k_0$的最小正整数解。（原理请参考<a href="https://www.cnblogs.com/GoldenPotato/p/10269979.html">这篇文章</a>）

接下来，我们可以通过这个神奇的公式<del>(我并不懂为啥可以这样推)</del>来把这两个式子整合起来：

$x \equiv p_0*k_0 + a_0 (lcm(p_0,p_1)) $

.

酱紫，我们就可以一步步把这个方程组浓缩成一个式子啦φ(>ω&lt;*)

<hr />

<h1>例题：</h1>

<ul>
<li><a href="https://www.cnblogs.com/GoldenPotato/p/10270032.html">扩展中国剩余定理模板题：POJ2891</a></li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>226</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:23:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:23:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%89%a9%e5%b1%95%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8c%e4%bd%99"><![CDATA[同余]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[461]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[POJ 2891] Strange Way to Express Integers</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/poj-2891-strange-way-to-express-integers/</link>
		<pubDate>Mon, 25 Feb 2019 11:24:58 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=229</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="http://poj.org/problem?id=2891">POJ</a>

<hr />

<h1>Solution</h1>

就是裸的扩展中国剩余定理嘛qwq

注意几点：一定要时时刻刻<del>去膜</del>取模，否则一定会爆long long，尤其是算出来的$k_0$

这里给出几组易锅数据：(第三组容易爆long long)

<h3>input:</h3>

<pre><code class="">4
18373 16147
8614 14948
8440 17480
22751 21618
6
19576 8109
18992 24177
9667 17726
16743 19533
16358 12524
8280 22731
4
9397 38490
22001 25094
33771 38852
19405 35943
</code></pre>

<h3>output</h3>

<pre><code class="">13052907343337200
-1
78383942913636233
</code></pre>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//POJ2891 Strange Way to Express Integers
//Jan,14th,2019
//扩展中国剩余定理
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)
{
    if(B==0) 
    {
        x=1,y=0;
        return A;
    }
    long long t=exgcd(B,A%B,x,y),tx=x;
    x=y;
    y=tx-(A/B)*y;
    return t;
}
long long lcm(long long A,long long B)
{
    long long tx,ty;
    return (A*B)/exgcd(A,B,tx,ty);
}
const int N=100000+1000;
long long r[N],p[N];
int n;
int main()
{
    while(scanf("%d",&amp;n)!=EOF)
    {
        for(int i=1;i&lt;=n;i++)
            p[i]=read(),r[i]=read();

        long long R=r[1],P=p[1];
        bool OK=true;
        for(int i=2;i&lt;=n;i++)
        {
            long long x,y,gcd=exgcd(P,p[i],x,y);
            if((r[i]-R)%gcd!=0)
            {
                OK=false;
                break;
            }
            long long t_P=P,t=p[i]/gcd;
            x*=(r[i]-R)/gcd,P=lcm(P,p[i]),x=(x%t+t)%t;
            R=((t_P*x)%P+R)%P;
        }

        if(OK==true)
            printf("%lld\n",(R%P+P)%P);
        else
            printf("-1\n");
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>229</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:24:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:24:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2891-strange-way-to-express-integers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8c%e4%bd%99"><![CDATA[同余]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[341]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4777] 【模板】扩展中国剩余定理（EXCRT）</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p4777-%e3%80%90%e6%a8%a1%e6%9d%bf%e3%80%91%e6%89%a9%e5%b1%95%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86%ef%bc%88excrt%ef%bc%89/</link>
		<pubDate>Mon, 25 Feb 2019 11:26:33 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=231</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P4777">洛咕</a>

<hr />

<h1>Solution</h1>

真*扩展中国剩余定理模板题。<del>我怎么老是在做模板题啊</del>

但是这题与之前不同的是不得不写龟速乘了。

还有两个重点

<ul>
<li>我们在求LCM的时候，记得先/gcd再去乘另外那个数，直接乘会乘爆的</li>
<li>我们在做龟速乘之前，要保证要乘的两个数>=0,如果&lt;0的话，龟速乘会爆掉的，我们传进去之间记得膜一下</li>
</ul>

<del>int128:你说啥？这里风太大，我听不见。</del>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu  P4777 【模板】扩展中国剩余定理（EXCRT）
//Jan,15th,2019
//中国剩余定理
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
long long take(long long A,long long B,long long poi)
{
    if(B==0) return 0;
    long long temp=take(A,B/2,poi)*2%poi;
    if(B%2==1) temp=(temp+A)%poi;
    return temp;
}
long long exgcd(long long A,long long B,long long &amp;x,long long &amp;y)
{
    if(B==0)
    {
        x=1,y=0;
        return A;
    }
    long long t_ans=exgcd(B,A%B,x,y),tx=x;
    x=y,y=tx-(A/B)*y;
    return t_ans;
}

const int N=100000+100;
int n;
long long a[N],p[N];
int main()
{
    n=read();
    for(int i=1;i&lt;=n;i++)
        p[i]=read(),a[i]=read();

    long long A=a[1],P=p[1];
    for(int i=2;i&lt;=n;i++)
    {
        long long x,y,gcd=exgcd(P,p[i],x,y);
        long long t_P=P,t=p[i]/gcd;
        x=(x%t+t)%t,x=take(x,(((a[i]-A)/gcd)%t+t)%t,t);
        P=P*(p[i]/gcd),A=(A+take(t_P,x,P))%P;
    }

    printf("%lld",(A%P+P)%P);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>231</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:26:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:26:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4777-%e3%80%90%e6%a8%a1%e6%9d%bf%e3%80%91%e6%89%a9%e5%b1%95%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86%ef%bc%88excrt%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8c%e4%bd%99"><![CDATA[同余]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[364]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>第二类斯特林数学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e7%ac%ac%e4%ba%8c%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 25 Feb 2019 11:28:20 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=233</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>本菜鸡尚未学会第二类斯特林数，请各位dalao不要相信本文的任何一个字</strong>

<hr />

<h1>什么是第二类斯特林数</h1>

<blockquote>
  在组合数学，Stirling数可指两类数，第一类Stirling数和第二类Stirling数，都是由18世纪数学家James Stirling提出的。
  Stirling数有两种，第一类和第二类Stirling数，它们自18世纪以来一直吸引许多数学家的兴趣，如欧拉、柯西、西尔沃斯特和凯莱等。后来哥本哈根（Copenhagen）大学的尼尔森（Niels Nielsen，1865-1931）提出了"Stirlingschen Zahlen erster Art" [第一类Stirling数]和"Stirlingschen Zahlen zweiter Art" [第二类Stirling数]，首次把这两类数冠以「Stirling数」之名 。因为苏格兰数学家斯特林（J. Stirling, 1692-1770）首次发现这些数并说明了它们的重要性。 ——百度百科
</blockquote>

用人话来说，第二类斯特林数$S(i,j)$用来表示i个不一样的球放入j个相同盒子里的方案数。

<hr />

<h1>怎么算第二类斯特林数</h1>

我们可以假设当前这个球是单独放一个盒子还是放入有别的球的盒子中，如果单独放一个盒子，显然答案为$S(i-1,j-1)$,如果放入别的盒子中，因为它放在不同的盒子后能与盒子中原本有的球组成不同的方案，因此我们要在$S(i-1,j)$前面乘以盒子总数$j$

因此，我们可以得到以下递推式：

$S(i,j)=S(i-1,j-1)+j*S(i-1,j)$

还有一个我并不会证的通项公式，会证之后再补（咕咕咕）

$S(n,m)={\frac 1 {m!}}\sum_{k=0}^m (-1)^k C(m,k)(m-k)^n$

<hr />

<h1>第二类斯特林数有啥性质</h1>

有且只有一个，而且我也不会证，会证后补（咕咕咕）

$n^k=\sum_ { i=0}^n S(k,i)×i!×C(n,i)$

这个式子主要用于算一些蜜汁幂次方的时候可以用得到，例如<a href="https://www.luogu.org/problemnew/show/CF932E">这道题</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>233</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:28:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:28:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ac%ac%e4%ba%8c%e7%b1%bb%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0"><![CDATA[斯特林数]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[453]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[CF932E] Team Work</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/cf932e-team-work/</link>
		<pubDate>Mon, 25 Feb 2019 11:29:02 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=235</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<ul>
<li><a href="https://www.luogu.org/problemnew/show/CF932E">洛咕</a></li>
<li><a href="http://codeforces.com/problemset/problem/932/E">CodeForces</a></li>
</ul>

<hr />

<h1>Solution</h1>

<del>这题写得我脑壳疼，我好菜啊</del>

.

显然，这题让我们求$\sum_{i=1}^{n}C_n^i\times i^k$

这个$i^k$让人浑身难受，我们可以考虑把它搞掉，能搞掉某个数的幂次方的有啥？本蒟蒻只会第二类斯特林数。

.

所以说我们无脑把第二类斯特林数带进去再说：

$\sum_{i=1}^{n}C_n^i\times \sum_{j=0}^{i}S(k,j)&#42;j!&#42;C_i^j$

.

然后把组合数展开：

$\sum_{i=1}^{n}\frac{n!}{i!(n-i)!}\times \sum_{j=0}^{i}S(k,j)&#42;j!&#42;\frac{i!}{j!(i-j)!}$

.

因为前面那一项与j无关，我们可以把它放到后面去

$\sum_{i=1}^{n} \sum_{j=0}^{i} \frac{n!}{i!(n-i)!} &#42; S(k,j)&#42;j!&#42;\frac{i!}{j!(i-j)!}$

.

约分得：

$\sum_{i=1}^{n} \sum_{j=0}^{i} \frac{n!}{(n-i)!} &#42; S(k,j)&#42;\frac{1}{(i-j)!}$

.

因为$k$很小，$j$很大，而第二类斯特林数的定义告诉我们，当$j>k$时，$S(k,j)=0$。因此，我们可以考虑把$S(k,j)$放到外面来处理，根据<a href="https://blog.csdn.net/github_35736728/article/details/80933891">交换和号</a>的原则，我们可以处理前面两个$\sum$来方便把$S(k,j)$提到外面来。

交换和号后得：

$\sum_{j=0}^{n} \sum_{i=j}^{n} \frac{n!}{(n-i)!} &#42; S(k,j)&#42;\frac{1}{(i-j)!}$

.

然后就可以把$S(k,j)$提到外面来了：

$\sum_{j=0}^{n} S(k,j) \times \sum_{i=j}^{n} \frac{n!}{(n-i)!}&#42;\frac{1}{(i-j)!}$

.

考虑到一点，当我们的$j>k$的时候，$S(k,j)=0$，因此，我们前面$j$的枚举范围可以缩小为$min(k,n)$

$\sum_{j=0}^{min(n,k)} S(k,j) \times \sum_{i=j}^{n} \frac{n!}{(n-i)!}&#42;\frac{1}{(i-j)!}$

.

这时候我们可以发现：后面那个循环长得非常像组合数，考虑上下同时乘以$(n-j)!$让它变成组合数:

$\sum_{j=0}^{min(n,k)} S(k,j) \times \sum_{i=j}^{n} \frac{n!}{(n-j)!}&#42;\frac{(n-j)!}{(n-i)!*(i-j)!}$

$\sum_{j=0}^{min(n,k)} S(k,j) \times \sum_{i=j}^{n} \frac{n!}{(n-j)!}&#42;C_{(n-j)}^{(n-i)}$

.

同理，我们可以把后面那个阶乘提到前面去

$\sum_{j=0}^{min(n,k)} S(k,j)&#42;\frac{n!}{(n-j)!} \times \sum_{i=j}^{n} C_{(n-j)}^{(n-i)}$

.

我们还可以注意到，后面那个循环：当$i&lt;j$的时候，算出来的东西是没有意义的，因此我们可以改变循环范围为$i=0$ 来方便把那个难以计算的$\sum$变为方便计算的$2^x$的形式

$\sum_{j=0}^{min(n,k)} S(k,j)&#42;\frac{n!}{(n-j)!} \times \sum_{i=0}^{n} C_{(n-j)}^{(n-i)}$

.

$\sum_{j=0}^{min(n,k)} S(k,j)&#42;\frac{n!}{(n-j)!} \times 2^{(n-j)}$

.

搞定，到目前为止，这里里面的所有东西都可以方便的求出来了：

$S(k,j)$可以用$k^2$的递推暴力求算<del>神犇们大可用FFT或NTT快速计算，可惜我太菜了并不会</del>

$\frac{n!}{(n-j)!}$可以用一个$O(k)$的暴力递推算即可

$2^{(n-j)}$........如果不会算的话请自行右上角

.

时间复杂度$O(n^2)$

酱紫，这题就被我们A掉啦~

撒花ヾ(●´∀｀●)

.

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//CF932E Team Work
//Jan,15th,2019
//第二类斯特林数的应用+奇奇怪怪的推公式
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int poi=1000000007;
long long FastPow(long long A,long long B)
{
    if(B==0) return 1;
    long long t_ans=FastPow(A,B/2);
    t_ans=t_ans*t_ans%poi;
    if(B%2==1) t_ans=t_ans*A%poi;
    return t_ans;
}
const int N=5000+100;
long long S[N][N],jc[N];
int n,K;
int main()
{
    scanf("%d%d",&amp;n,&amp;K);

    S[1][1]=1;
    for(int i=2;i&lt;=K;i++)
        for(int j=1;j&lt;=i;j++)
            S[i][j]=(S[i-1][j-1]+j*S[i-1][j])%poi;
    jc[0]=1;
    for(int i=1;i&lt;=K;i++)
        jc[i]=jc[i-1]*(n-i+1)%poi;

    long long ans=0;
    int t=min(n,K);
    for(int i=0;i&lt;=t;i++)
        ans+=S[K][i]*jc[i]%poi*FastPow(2,n-i),ans%=poi;

    printf("%lld",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>235</wp:post_id>
		<wp:post_date><![CDATA[2019-02-25 11:29:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-02-25 11:29:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[cf932e-team-work]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e6%96%af%e7%89%b9%e6%9e%97%e6%95%b0"><![CDATA[斯特林数]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[455]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>快速傅里叶变换学习笔记（FFT）</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e5%bf%ab%e9%80%9f%e5%82%85%e9%87%8c%e5%8f%b6%e5%8f%98%e6%8d%a2%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%ef%bc%88fft%ef%bc%89/</link>
		<pubDate>Fri, 01 Mar 2019 06:50:39 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=248</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是FFT</h1>

FFT是用来快速计算两个<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%87%BD%E6%95%B0/10686272">多项式</a>相乘的一种算法。
如果我们暴力计算两个多项式相乘，复杂度必然是$O(n^2)$的，而FFT可以将复杂度降至$O(nlogn)$

<hr />

<h1>如何FFT</h1>

要学习FFT,我们得先了解它的思想。
首先，我们得先了解如何表示一个多项式。显然，我们最传统的方法表示多项式就是表示它的系数就好。但是，如果我们用系数来计算两个多项式相乘，复杂度无论如何都是$O(n^2)$的。因此，我们引入点值表示法。

<blockquote>
  <strong>补充资料：什么是点值表示</strong>
  设A(x)是一个n−1次多项式，那么把n个不同的x代入，会得到n个y。这n对(x,y)唯一确定了该多项式，即只有一个多项式能同时满足“代入这些x，得到的分别是这些y”。
  由多项式可以求出其点值表示，而由点值表示也可以求出多项式。<br />
  ——<a href="https://www.cnblogs.com/RabbitHu/p/FFT.html">胡小兔dalao的博客</a>
</blockquote>

所以说，我们要表示一个n-1次多项式，可以用n个点值来表示。如果用点值来计算两个多项式相乘，那就很简单了，我们只需要两个多项式的点值两两对应相乘即可（如果两个多项式次数不同，我们也必须让次数较小的那个多项式强行算够一样多的点值（即多取几个$x$来计算即可）），这样做的复杂度是$O(n)的$。

因此，如果我们能快速地把一个多项式从系数表示变为点值表示，我们就能快速计算两个多项式相乘啦。
这个快速计算的过程。

<h2>1.如何取点</h2>

我们要把一个多项式从系数形式变为点值形式，肯定躲不开取$x$的过程。先辈傅里叶已经为我们解决了这个问题。他取的$x$为虚数。

<blockquote>
  如果您没有学习过复数，请移步<a href="https://www.cnblogs.com/RabbitHu/p/FFT.html">胡小兔dalao的博客</a>，他有详细的讲解。
</blockquote>

<img src="https://img2018.cnblogs.com/blog/1316999/201901/1316999-20190117174606134-880289712.png" alt="" />
所以说，我们是假设把一个单位圆分成n份（纵坐标为虚部，横坐标为实部），单位圆上我们每取的一个点所代表的虚数（实部与虚部相加）即对应一个$x$

根据我们的数学知识，圆上的任意一个我们取出来的点的坐标都可以表示为$(cos((k&#42;2&#42;pi)/n),sin((k&#42;2&#42;pi)/n))$的形式，逆时针将这$n$个点从$0$开始编号，第$k$个点对应的虚数记作$ω_n^k$

<blockquote>
  <strong>补充资料：单位根的性质</strong>
      性质一：$ω^{2k}_{2n}=ω^k_n$
      证明：它们对应的点/向量是相同的。
      性质二：$ω^{k+n/2}_n=−ω^k_n$
      证明：它们对应的点是关于原点对称的（对应的向量是等大反向的）。
      ——<a href="https://www.cnblogs.com/RabbitHu/p/FFT.html">胡小兔dalao的博客</a>
</blockquote>

这样子，我们就取出了$n$个$x$

<blockquote>
  <strong>补充资料：为什么要取这些点</strong>
      如果我们取这些点，我们最后可以快速地把点值式转换为系数式，具体方法及证明见下文
</blockquote>

<h2>2.如何快速算出每个$x$对应的多项式的值</h2>

这就涉及到FFT的核心算法了。如果我们暴力去算，复杂度依旧是$O(n^2)$，并没有什么用。因此，我们FFT的核心思想是&#42;&#42;分治&#42;&#42;。

我们先把原多项式拉出来：
$A(x)=a_0&#42;x^0+a_1&#42;x^1+a_2&#42;x^2+a_3&#42;x^3+a_4&#42;x^4+...+a_{n-1}&#42;x^{n-1}$
设两个新的多项式：
$A_1(x)=a_0&#42;x^0+a_2&#42;x^1+a_4&#42;x^2+a_6&#42;x^3+...a_{n-2}&#42;x^{n/2-1}$
$A_2(x)=a_1&#42;x^0+a_3&#42;x^1+a_5&#42;x^2+a_7&#42;x^3+...a_{n-1}&#42;x^{n/2-1}$
显然我们有：
$A(x)=A_1(x^2)+x&#42;A_2(x^2)$

所以说，我们可以把原来得式子分成两个长度只有一半的式子，每次都能减少一半的计算量，这样子，我们复杂度就变成了$O(n&#42;logn)$

假设我们已经递归下去算出了$A_1$与$A_2$在$(\omega_{\frac{n}{2}}^{0}, \omega_{\frac{n}{2}}^{1}, \omega_{\frac{n}{2}}^{2}, ... , \omega_{\frac{n}{2}}^{\frac{n}{2} - 1})$的值，怎么合并回$A$在$(\omega_n^{0}, \omega_n^{1}, \omega_n^{2}, ... , \omega_n^{n-1})$的值呢？
我们把$\omega_n^x$带回我们刚刚的这个式子：$A(x)=A_1(x^2)+x&#42;A_2(x^2)$有：
$A(\omega_n^x)=A_1(\omega_n^{x^2})+\omega_n^x&#42;A_2(\omega_n^{x^2})$
$A(\omega_n^x)=A_1(\omega_{n/2}^{x})+\omega_n^x&#42;A_2(\omega_{n/2}^{x})$

那另外那一半怎么算呢？
同样把$\omega_n^{x+n/2}$带入$A(x)=A_1(x^2)+x&#42;A_2(x^2)$有：
$A(\omega_n^{k + \frac{n}{2}}) = A_1(\omega_n^{2k + n}) + \omega_n^{k + \frac{n}{2}}A_2(\omega_n^{2k + n})$
$A(\omega_n^{k + \frac{n}{2}}) = A_1(\omega_{\frac{n}{2}}^{k} \times \omega_n^n) + \omega_n^{k + \frac{n}{2}} $ $A_2(\omega_{\frac{n}{2}}^{k} \times \omega_n^n) $
$A(\omega_n^{k + \frac{n}{2}}) = A_1(\omega_{\frac{n}{2}}^{k}) - \omega_n^kA_2(\omega_{\frac{n}{2}}^{k})$ <sup id="fnref-248-1"><a href="#fn-248-1" class="footnote-ref" role="doc-noteref">1</a></sup>

实现上，差不多长这样：

<pre><code class="language-cpp ">const double PI=acos(-1);
typedef complex &lt;double&gt; cp;
inline cp omega (int K,int n)
{
    return cp(cos(2\*PI\*K/n),sin(2\*PI\*K/n));
}
void FFT(cp a[],int n,bool type)
{
    if(n==1) return;
    static cp buf[M];
    int m=n/2;
    for(int i=0;i&lt;m;i++)
        buf[i]=a[i\*2],buf[i+m]=a[i\*2+1];
    for(int i=0;i&lt;n;i++)
        a[i]=buf[i];
    FFT(a,m,type);
    FFT(a+m,m,type);
    for(int i=0;i&lt;m;i++)
    {
        cp x=omega(i,n);
        if(type==true) x=conj(x);//conj在这里做取倒的作用，具体作用请看下文第四点
        buf[i]=a[i]+x\*a[i+m];
        buf[i+m]=a[i]-x\*a[i+m];
    }
    for(int i=0;i&lt;n;i++)
        a[i]=buf[i];
}
</code></pre>

<h2>3.后续优化</h2>

理论上来说，我们已经可以实现FFT了，很不幸的是，递归版本的常数巨大（递归消耗以及大量的三角函数计算），我们可以通过一些<del>玄学</del>方法来优化这份FFT代码：

在进行fft时，我们要把各个系数不断分组并放到两侧，那么一个系数原来的位置和最终的位置有什么规律呢？

初始位置：0 1 2 3 4 5 6 7
第一轮后：0 2 4 6|1 3 5 7
第二轮后：0 4|2 6|1 5|3 7
第三轮后：0|4|2|6|1|5|3|7

“|”代表分组界限。

可以发现（这你都能发现？），一个位置a上的数，最后所在的位置是“a二进制翻转得到的数”，例如6(011)最后到了3(110)，1(001)最后到了4(100)。

那么我们可以据此写出非递归版本fft：先把每个数放到最后的位置上，然后不断向上还原，同时求出点值表示。  <sup id="fnref2:248-1"><a href="#fn-248-1" class="footnote-ref" role="doc-noteref">1</a></sup>

代码大概长这样：

<pre><code class="language-cpp ">void FFT(cp a[],int n,bool type)
{
    static int len=0,t_num=n-1,t[N];
    while(t_num!=0) t_num/=2,len++;
    for(int i=0,j;i&lt;=n;i++)
    {
        for(t_num=i,j=0;j&lt;len;j++)
            t[j]=t_num%2,t_num/=2;
        reverse(t,t+len);
        for(t_num=0,j=0;j&lt;len;j++)
            t_num+=t[j]\*(1&lt;&lt;j);
        if(i&lt;t_num) swap(a[i],a[t_num]);
    }
    for(int l=2;l&lt;=n;l\*=2)
    {
        int m=l/2;
        cp x0=omega(1,l);
        if(type==true) x0=conj(x0);
        for(int i=0;i&lt;n;i+=l)
        {
            cp x=cp(1,0);
            for(int j=0;j&lt;m;j++,x\*=x0)
            {
                cp temp=x\*a[i+j+m];
                a[i+j+m]=a[i+j]-temp;
                a[i+j]=a[i+j]+temp;
            }
        }
    }
}
</code></pre>

<h2>4.怎么把点值式换回系数</h2>

FFT有一个性质：把多项式$A(x)$的离散傅里叶变换结果作为另一个多项式$B(x)$的系数，取单位根的倒数即$ω^0_n,ω_n^{-1},ω_n^{-2},...,ω^{-n+1}_n$作为$x$代入$B(x)$，得到的每个数再除以$n$，得到的$是A(x)$的各项系数啦。

<blockquote>
  <strong>补充资料：如何证明这个性质</strong>
  我们设带入后$B$的某个点值为$z_k$,多项式$B$算出来的某个点值为$j_i$,我们有：
  $z_k = \sum_{i = 0}^{n - 1} y_i(\omega_n^{-k})^i $
  $z_k= \sum_{i = 0}^{n - 1}(\sum_{j = 0}^{n - 1} a_j(\omega_n^i)^j)(\omega_n^{-k})^i  $
  $z_k= \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i)$
  <sup id="fnref3:248-1"><a href="#fn-248-1" class="footnote-ref" role="doc-noteref">1</a></sup>
  这里的$\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i$是可以求出来得，当$j=k$的时候，这个式子等于n，其他时候均为0（使用等比数列求和即可证明）
  因此我们有：$z_k=n&#42;a_k$。
  证毕
</blockquote>

<hr />

<h1>最后的最后......</h1>

<strong>恭喜你，到此为止，你已经学会了FFT</strong>
<strong>撒花✿✿ヽ(°▽°)ノ✿</strong>

<div class="footnotes" role="doc-endnotes">
<hr />
<ol>

<li id="fn-248-1" role="doc-endnote">
这一段抄自<a href="https://www.cnblogs.com/RabbitHu/p/FFT.html">胡小兔dalao的博客</a>&#160;<a href="#fnref-248-1" class="footnote-backref" role="doc-backlink">&#8617;&#xFE0E;</a> <a href="#fnref2:248-1" class="footnote-backref" role="doc-backlink">&#8617;&#xFE0E;</a> <a href="#fnref3:248-1" class="footnote-backref" role="doc-backlink">&#8617;&#xFE0E;</a>
</li>

</ol>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>248</wp:post_id>
		<wp:post_date><![CDATA[2019-03-01 06:50:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-01 06:50:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%bf%ab%e9%80%9f%e5%82%85%e9%87%8c%e5%8f%b6%e5%8f%98%e6%8d%a2%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%ef%bc%88fft%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="fft-ntt"><![CDATA[FFT/NTT]]></category>
		<category domain="category" nicename="%e5%a4%9a%e9%a1%b9%e5%bc%8f"><![CDATA[多项式]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[441]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3338] [ZJOI2014]力</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p3338-zjoi2014%e5%8a%9b/</link>
		<pubDate>Fri, 01 Mar 2019 06:54:13 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=250</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：

<ul>
<li><a href="https://www.luogu.org/problemnew/show/P3338">洛咕</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3527">BZOJ</a></li>
</ul>

<hr />

<h1>Solution</h1>

<del>写到脑壳疼，我好菜啊</del>

我们来颓柿子吧
$F_j=\sum_{i&lt;j}\frac{q_i&#42;q_j}{(i-j)^2}-\sum_{i>j}\frac{q_i&#42;q_j}{(i-j)^2}$

$q_j$与$i$没有半毛钱关系，提到外面去
$F_j=q_j&#42;\sum_{i&lt;j}\frac{q_i}{(i-j)^2}-q_j&#42;\sum_{i>j}\frac{q_i}{(i-j)^2}$

左右同时除以$q_j$
$E_j=\sum_{i=1}^{j-1}\frac{q_i}{(i-j)^2}-\sum_{i=j+1}^{n}\frac{q_i}{(i-j)^2}$

我们设$f(i)=q(i),g(i)=\frac{1}{i^2}$，有
$E_j=\sum_{i=1}^{j-1}f(i)&#42;g(i-j)-\sum_{i=j+1}^{n}f(i)&#42;g(i-j)$

因为$g(i)$是个偶函数，因此有：
$E_j=\sum_{i=1}^{j-1}f(i)&#42;g(j-i)-\sum_{i=j+1}^{n}f(i)&#42;g(i-j)$

这时候，我们显然可以发现左边那个式子是个卷积，右边的这样一波化简就也变成了卷积形式：
<img src="https://img2018.cnblogs.com/blog/1316999/201901/1316999-20190118160422690-423540635.jpg" alt="" />

卷积用FFT快速计算即可

<strong>时间复杂度$O(nlogn)$</strong>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P3338 [ZJOI2014]力
//Jan,18th,2019
//FFT加速卷积
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;complex&gt;
using namespace std;
typedef complex &lt;double&gt; cp;
const double PI=acos(-1);
const int M=100000+100;
const int N=8\*M;
inline cp omega(int K,int n)
{
    return cp(cos(2\*PI\*K/n),sin(2\*PI\*K/n));
}
void FFT(cp a[],int n,bool type)
{
    static int len=0,num=n-1,t[N];
    while(num!=0) len++,num/=2;
    for(int i=0,j;i&lt;=n;i++)
    {
        for(j=0,num=i;j&lt;len;j++)
            t[j]=num%2,num/=2;
        reverse(t,t+len);
        for(j=0,num=0;j&lt;len;j++)
            num+=t[j]\*(1&lt;&lt;j);
        if(i&lt;num) swap(a[i],a[num]);
    }
    for(int l=2;l&lt;=n;l\*=2)
    {
        int m=l/2;
        cp x0=omega(1,l);
        if(type==true) x0=conj(x0);
        for(int j=0;j&lt;n;j+=l)
        {
            cp x=cp(1,0);
            for(int k=0;k&lt;m;k++,x\*=x0)
            {
                cp temp=x\*a[j+k+m];
                a[j+k+m]=a[j+k]-temp;
                a[j+k]=a[j+k]+temp;
            }
        }
    }
}
int n,m;
double q[N];
cp f[N],g[N],f2[N];
int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf("%lf",&amp;q[i]);

    for(int i=1;i&lt;=n;i++)
        g[i]=(1.0/i/i);
    m=1;
    while(m&lt;2\*n) m\*=2;
    for(int i=1;i&lt;m;i++)
        f[i]=q[i],f2[i]=q[i];

    FFT(g,m,false);
    FFT(f,m,false);
    reverse(f2+1,f2+n+1);
    FFT(f2,m,false);
    for(int i=0;i&lt;m;i++)
        f[i]\*=g[i],f2[i]\*=g[i];
    FFT(f,m,true);
    FFT(f2,m,true);

    for(int i=1;i&lt;=n;i++)
        printf("%lf\n",(f[i].real()-f2[n-i+1].real())/m);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>250</wp:post_id>
		<wp:post_date><![CDATA[2019-03-01 06:54:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-01 06:54:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3338-zjoi2014%e5%8a%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="fft-ntt"><![CDATA[FFT/NTT]]></category>
		<category domain="category" nicename="%e5%8d%b7%e7%a7%af"><![CDATA[卷积]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[371]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4173]残缺的字符串</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p4173%e6%ae%8b%e7%bc%ba%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2/</link>
		<pubDate>Fri, 01 Mar 2019 06:55:43 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=253</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P4173">洛咕</a>

<hr />

<h1>Solution</h1>

<del>这题我写得脑壳疼，我好菜啊</del>

好吧，我们来说正题。
这题.....emmmmmmm
显然KMP类的字符串<del>神仙</del>算法在这里没法用了。

那咋搞啊（或者说这题和数学有半毛钱关系啊）
我们考虑把两个字符相同强行变为一个数学关系，怎么搞呢？
考虑这题是带通配符的，我们可以这样设:
$C(x,y)=(A[x]-B[y])^2&#42;A[x]&#42;B[y]$
因此，我们可以看出两个字符一样当且仅当$C(x,y)=0$

因此，我们再设一个函数$P(x)$表示$B$串以第$x$项为结尾的长度为$m$的子串是否与$A$串匹配，显然有：
$P(x)=\sum_{i=0}^{m-1}C(i,x-m+i+1)$
$P(x)=\sum_{i=0}^{m-1}(A[i]-B[x-m+i+1])^2&#42;A[i]&#42;B[x-m+i+1]$

后面那个式子写的太蛋疼了，我们把$x-m+i+1$设为$j$吧。
$P(x)=\sum_{i=0}^{m-1}(A[i]-B[j])^2&#42;A[i]&#42;B[j]$

大力展开得：
$P(x)=\sum_{i=0}^{m-1}A[i]^3B[j]-2A[i]^2B[j]^2+A[i]B[j]^3$

然后.....我们试着把$\sum$展开？
$P(x)=\sum_{i=0}^{m-1}A[i]^3B[j]-\sum_{i=0}^{m-1}2A[i]^2B[j]^2+\sum_{i=0}^{m-1}A[i]B[j]^3$

还是没法算啊......
诶，等下，如果我们把$A$串反转为$A'$,肯定有$A[i]=A'[m-i-1]$
然后这个$(m-i-1)+(j)$......不就是等于$x$嘛。
所以说我们马上就有：
$P(x)=\sum_{i+j=x}A[i]^3B[j]-\sum_{i+j=x}2A[i]^2B[j]^2+\sum_{i+j=x}A[i]B[j]^3$

哦豁，卷积，搞定~
时间复杂度$O(nlogn)$

搞定个鬼，这题要做7次FFT，常数爆大，<del>我卡不进去</del>
还请各位dalao赐教。

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;complex&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int M=300000+100;
const int N=M*4;
const double PI=acos(-1);
const double eps=1e-1;
typedef complex &lt;double&gt; cp;
cp omega(int K,int n)
{
    return cp(cos(2*PI*K/n),sin(2*PI*K/n));
}
inline void FFT(cp a[],int n,bool type)
{
    static int tmp[N],num=n-1,len;
    while(num!=0) num/=2,len++;
    for(int i=0,j;i&lt;=n;i++)
    {
        for(j=0,num=i;j&lt;len;j++)
            tmp[j]=num%2,num/=2;
        reverse(tmp,tmp+len);
        for(j=0,num=0;j&lt;len;j++)
            num+=tmp[j]*(1&lt;&lt;j);
        if(i&lt;num) swap(a[i],a[num]);
    }
    for(int l=2;l&lt;=n;l*=2)
    {
        int m=l/2;
        cp x0=omega(1,l);
        if(type==true) x0=conj(x0);
        for(int i=0;i&lt;n;i+=l)
        {
            cp x(1,0);
            for(int j=0;j&lt;m;j++,x*=x0)
            {
                cp temp=x*a[i+j+m];
                a[i+j+m]=a[i+j]-temp;
                a[i+j]=a[i+j]+temp;
            }
        }
    }
}
char A[N],B[N];
int m,n,t=1;
cp S1[N],S2[N],S3[N],B1[N],B2[N],B3[N];
bool OK[N];
int main()
{
    scanf("%d%d%s%s",&amp;m,&amp;n,A,B);

    while(t&lt;=(n+m)) t*=2;
    reverse(A,A+m); 
    for(int i=0;i&lt;t;i++)
        A[i]=(A[i]=='*' or A[i]&lt;'a' or A[i]&gt;'z'?0:A[i]-'a'+1),
        B[i]=(B[i]=='*' or B[i]&lt;'a' or B[i]&gt;'z'?0:B[i]-'a'+1);
    for(int i=0;i&lt;t;i++)
        S1[i]=A[i],S2[i]=A[i]*A[i],S3[i]=A[i]*A[i]*A[i];
    for(int i=0;i&lt;t;i++)
        B1[i]=B[i],B2[i]=B[i]*B[i],B3[i]=B[i]*B[i]*B[i];
    FFT(S1,t,false);
    FFT(S2,t,false);
    FFT(S3,t,false);
    FFT(B1,t,false);
    FFT(B2,t,false);
    FFT(B3,t,false);

    for(int i=0;i&lt;t;i++)
        S3[i]*=B1[i];
    for(int i=0;i&lt;t;i++)
        S1[i]*=B3[i];
    for(int i=0;i&lt;t;i++)
        S2[i]*=B2[i];
    for(int i=0;i&lt;t;i++)
        S3[i]+=S1[i]-2.0*S2[i];
    FFT(S3,t,true);
    int cnt=0;
    for(int i=m-1;i&lt;n;i++)
        if(fabs(S3[i].real()/t)&lt;eps)
            OK[i]=true,cnt++;

    printf("%d\n",cnt);
    for(int i=m-1;i&lt;n;i++)
        if(OK[i]==true)
            printf("%d ",i-m+1+1);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>253</wp:post_id>
		<wp:post_date><![CDATA[2019-03-01 06:55:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-01 06:55:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4173%e6%ae%8b%e7%bc%ba%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="fft-ntt"><![CDATA[FFT/NTT]]></category>
		<category domain="category" nicename="%e5%8d%b7%e7%a7%af"><![CDATA[卷积]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[330]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3723] [AH2017/HNOI2017]礼物</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p3723-ah2017-hnoi2017%e7%a4%bc%e7%89%a9/</link>
		<pubDate>Fri, 01 Mar 2019 06:56:45 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=255</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3723">洛咕</a>

<hr />

<h1>Solution</h1>

<del>调得我头大，我好菜啊</del>

好吧，我们来颓柿子吧：
我们可以只旋转其中一个手环。对于亮度的问题，因为可以在两个串上增加亮度，我们也可以看做是可以为负数的。

所以说，我们可以假设我们旋转$B$串，上下要加上的亮度差为$p$,可以直接拍出一个最暴力的柿子：
设$f(x)$表示$B$串以$x$为开头的差异值，有：
$f(x)=\sum_{i=0}^{x-1}(B[i]-A[i+n-x]+p)^2+\sum_{i=x}^{n-1}(B[i]-A[i-x]+p)^2$

大力展开化简后有：
$f(x)=\sum_{i=0}^{n-1}A[i]^2+\sum_{i=0}^{n-1}B[i]^2+n&#42;p^2-2p\sum_{i=0}^{n-1}(A[i]-B[i])-2\sum_{i=0}^{x-1}(B[i]&#42;A[i+n-x])-2\sum_{i=x}^{n-1}(B[i]&#42;A[i-x])$

前两项$\sum_{i=0}^{n-1}A[i]^2+\sum_{i=0}^{n-1}B[i]^2$显然$O(n)预处理出来$
中间两项$n&#42;p^2-2p\sum_{i=0}^{n-1}(A[i]-B[i])$是一个关于$p$的二次函数，我们找最小值就好。（因为这题$m$非常小，我们也可以暴力枚举），复杂度$O(1)$或$O(m)$。
最后两项$-2\sum_{i=0}^{x-1}(B[i]&#42;A[i+n-x])-2\sum_{i=x}^{n-1}(B[i]&#42;A[i-x])$看起来非常像卷积，但是并不是，因此我们得做点处♂理。

蒟蒻本人是这样处理的：
首先，后面那个循环范围是肯定没法卷的，因此我们先把后面的循环处理一下得：
$-2\sum_{i=0}^{x-1}(B[i]&#42;A[i+n-x])-2\sum_{i=0}^{n-x-1}(A[i]&#42;B[i+x])$
然后我们可以考虑把前面那项的$A$反转(这样可以处理掉$n$来方便卷积)，把后面那项的$B$反转(这样可以制造$n$与$\sum$对应)
$-2\sum_{i=0}^{x-1}(B[i]&#42;A'[x-1-i])-2\sum_{i=0}^{n-x-1}(A[i]&#42;B'[n-1-i-x])$

哦豁，卷积，搞定。
时间复杂度$O(n&#42;logn)$

<hr />

<h1>Code</h1>

<del>我什么时候才能一次性写对FFT啊</del>

<pre><code class="language-cpp ">//Luogu P3723 [AH2017/HNOI2017]礼物
//Jan,20th,2019
//颓柿子+FFT加速计算
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;complex&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x\*10+c-'0';c=getchar();}
    return x\*f;
}
const int M=50000+100;
const int N=M\*4;
const double PI=acos(-1);
typedef complex &lt;double&gt; cp;
inline cp omega(int K,int n)
{
    return cp(cos(2\*PI\*K/n),sin(2\*PI\*K/n));
}
void FFT(cp a[],int n,bool type)
{
    static int tmp[N],num=n-1,len=0;
    while(num!=0) num/=2,len++;
    for(int i=0,j;i&lt;=n;i++)
    {
        for(j=0,num=i;j&lt;len;j++)
            tmp[j]=num%2,num/=2;
        reverse(tmp,tmp+len);
        for(j=0,num=0;j&lt;len;j++)
            num+=tmp[j]\*(1&lt;&lt;j);
        if(i&lt;num) swap(a[i],a[num]);
    }
    for(int l=2;l&lt;=n;l\*=2)
    {
        cp x0=omega(1,l);
        if(type==true) x0=conj(x0);
        int m=l/2;
        for(int j=0;j&lt;n;j+=l)
        {
            cp x(1,0);
            for(int k=0;k&lt;m;k++,x\*=x0)
            {
                cp temp=x\*a[j+k+m];
                a[j+k+m]=a[j+k]-temp;
                a[j+k]=a[j+k]+temp;
            }
        }
    }
}
int n,m,a[N],b[N];
cp B1[N],A1[N],B2[N],A2[N];
long long ans;
int main()
{
    freopen("3723.in","r",stdin);

    n=read(),m=read();
    for(int i=0;i&lt;n;i++)
        a[i]=read();
    for(int i=0;i&lt;n;i++)
        b[i]=read();

    long long dif=0;
    for(int i=0;i&lt;n;i++)
        ans+=a[i]\*a[i]+b[i]\*b[i],dif+=a[i]-b[i];
    long long t_ans=0x3f3f3f3f\*0x3f3f3f3f;
    for(int i=-m;i&lt;=m;i++)
        t_ans=min(t_ans,n\*i\*i-2\*i\*dif);
    ans+=t_ans;

    int t=1;
    while(t&lt;2\*n) t\*=2;
    reverse(a,a+n);
    for(int i=0;i&lt;n;i++)
        A1[i]=a[i],B1[i]=b[i];
    FFT(A1,t,false);
    FFT(B1,t,false);
    for(int i=0;i&lt;t;i++)
        A1[i]\*=B1[i];
    FFT(A1,t,true);
    for(int i=0;i&lt;t;i++)
        A1[i].real()/=t;

    reverse(a,a+n);
    reverse(b,b+n);
    for(int i=0;i&lt;n;i++)
        A2[i]=a[i],B2[i]=b[i];
    FFT(A2,t,false);
    FFT(B2,t,false);
    for(int i=0;i&lt;t;i++)
        A2[i]\*=B2[i];
    FFT(A2,t,true);
    for(int i=0;i&lt;t;i++)
        A2[i].real()/=t;

    t_ans=(long long)(2\*floor(A2[n-1].real()+0.5));
    for(int i=1;i&lt;n;i++)
        t_ans=max(t_ans,(long long)(2\*floor(A1[i-1].real()+A2[n-i-1].real()+0.5)));
    ans-=t_ans;
    printf("%lld",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>255</wp:post_id>
		<wp:post_date><![CDATA[2019-03-01 06:56:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-01 06:56:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3723-ah2017-hnoi2017%e7%a4%bc%e7%89%a9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="fft-ntt"><![CDATA[FFT/NTT]]></category>
		<category domain="category" nicename="%e5%8d%b7%e7%a7%af"><![CDATA[卷积]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[367]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>欧拉函数学习笔记</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Fri, 01 Mar 2019 06:59:15 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=257</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是欧拉函数</h1>

记欧拉函数为$\varphi(x)$表示比$x$小且与$x$互质的数的个数。

<hr />

<h1>怎么算欧拉函数</h1>

通项公式:$\varphi(x)=x&#42;\prod(1-\frac{1}{p_i})$ ($p_i$为$x$的质因数)

因为欧拉函数是一个<strong>积性函数</strong>，因此我们可以用欧拉筛(线性筛)在$O(n)$的时间内预处理出来：具体证明请见后文

<pre><code class="language-cpp ">void GetPrime()
{
    memset(IsPrime,1,sizeof IsPrime);
    IsPrime[1]=false;
    phi[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(IsPrime[i]==true)
            prime[++prime_tot]=i,phi[i]=i-1;
        for(int j=1;j&lt;=prime_tot and i\*prime[j]&lt;=n;j++)
        {
            IsPrime[i\*prime[j]]=false;
            if(i%prime[j]==0)
            {
                phi[i\*prime[j]]=phi[i]\*prime[j];//性质二
                break;
            }
            phi[i\*prime[j]]=phi[i]\*phi[prime[j]];//性质一
        }
    }
}

</code></pre>

<hr />

<h1>欧拉函数的性质</h1>

<ol>
<li>欧拉函数是一个积性函数，因此我们有若$gcd(p,i/p)=1$，则$\varphi(i)=\varphi(i/p)&#42;\varphi(p)$ <del>（我不会证）</del></li>
<li>若$gcd(p,i/p)!=1$，且$p$为质数，则$\varphi(i)=\varphi(i/p)&#42;p$</li>
</ol>

<blockquote>
  证明：
  因为$gcd(p,i/p)!=1$而且$p$为质数，所以$i$一定由至少两个$p$组成。
  所以说$\varphi(i/p)=\varphi(i)/p$(因为对累乘没有影响，只对最前面的$x$有影响($x$指的是通项式中的$x$))
  证毕
</blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>257</wp:post_id>
		<wp:post_date><![CDATA[2019-03-01 06:59:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-01 06:59:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[378]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>狄利克雷卷积学习笔记</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/%e7%8b%84%e5%88%a9%e5%85%8b%e9%9b%b7%e5%8d%b7%e7%a7%af%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Mon, 04 Mar 2019 05:26:29 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=260</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>
  蒟蒻尚在学习，请各位dalao不要相信本文的任何一个字，包括标点符号。
</blockquote>

<hr />

<h1>什么是狄利克雷卷积</h1>

狄利克雷卷积定义式如下：
$\large f&#42;g(n)=\sum_{d|n}f(d)&#42;g(\frac{n}{d})$
也可以写作：
$\large f&#42;g(n)=\sum_{i&#42;j=n}f(i)&#42;g(j)$

<hr />

<h1>怎么算狄利克雷卷积</h1>

<h3>单独计算$f&#42;g(n)$</h3>

显然我们可以根据定义式暴力计算，枚举$i$即可，复杂度$O(\sqrt{n})$
这里就不上代码了，跟暴力枚举质数长得基本上一模一样。

<h3>计算$f&#42;g$</h3>

如果再像暴力计算那样，复杂度将达到恐怖的$O(n\sqrt{n})$。
但是我们可以从质数筛（埃塞）的想法入手，我们可以直接枚举一个$i$，再为它的倍数上的值加上对应的贡献就好。时间复杂度$O(nlogn)$。
代码大概长这样w

<pre><code class="language-cpp line-numbers">void Dirichlet(int f[],int g[],int ans[],int n)
{
    memset(ans,0,sizeof ans);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;i\*j&lt;=n;j++)
            ans[i\*j]+=f[i]\*g[j];
}
</code></pre>

<del>怎么样，是不是比FFT容易一千万倍？</del>

<hr />

<h1>狄利克雷卷积有什么性质</h1>

满足：
1. 交换律
2. 结合律
3. 分配率]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>260</wp:post_id>
		<wp:post_date><![CDATA[2019-03-04 05:26:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-04 05:26:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%8b%84%e5%88%a9%e5%85%8b%e9%9b%b7%e5%8d%b7%e7%a7%af%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8d%b7%e7%a7%af"><![CDATA[卷积]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[449]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2257] YY的GCD</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p2257-yy%e7%9a%84gcd/</link>
		<pubDate>Mon, 04 Mar 2019 05:28:35 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=262</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2257">洛咕</a>

<hr />

<h1>Solution</h1>

<del>推到自闭，我好菜啊</del>

显然，这题让我们求：
$\large \sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)\in prime]$

根据套路，我们可以把判断是否为质数改为枚举这个质数，有：
为了方便枚举，我们在这里假设有$m>n$
$\large \sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k\in prime}^{n}[gcd(i,j)= k]$
显然，要让$gcd(i,j)=k$，必须要有$i,j$均为$k$的倍数，因此有：
$\large \sum_{k\in prime}^{n}\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}[gcd(i,j)= 1]$ (在这里除号指向下取整)

根据套路，我们要去掉这里的判断符号。因为我们的莫比乌斯函数有这个性质：$[x=1]=\sum_{d|x}\mu(d)$，我们这里可以直接把$gcd(i,j)$作为$x$带入这个性质里面，有：
$\large \sum_{k\in prime}^{n}\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}\sum_{d|gcd(i,j)}\mu(d)$

然后根据套路，我们直接枚举这里的$d$，有：
$\large \sum_{k\in prime}^{n}\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}\sum_{d=1}^{n/k}μ(d)[d|gcd(i,j)]$ （因为前面$i,j$中最小的是$n/k$,所以说我们这里$d$的最大值也为$n/k$）
然后我们这里的$\sum_{d=1}^{n/k}$显然可以直接往前提
$\large \sum_{k\in prime}^{n}\sum_{d=1}^{n/k}\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}μ(d)[d|gcd(i,j)]$
这时候$\mu(d)$显然也可以往前提
$\large \sum_{k\in prime}^{n}\sum_{d=1}^{n/k}μ(d)\sum_{i=1}^{n/k}\sum_{j=1}^{m/k}[d|gcd(i,j)]$

这时候，我们可以发现后面那个判断式为1当且仅当$i,j$均为$d$的倍数，所以我们可以直接把那两个$\sum$简化掉
$\large \sum_{k\in prime}^{n}\sum_{d=1}^{n/k}μ(d)\frac{n}{k&#42;d}\frac{m}{k&#42;d}$

这时候，我们已经可以在$O(logn&#42;\sqrt n)$的时间内算一次答案了（这里的$log$为质数个数），很可惜，这样的复杂度并不能通过这一题。

事实上，我们还有一个常见的套路来优化这里：
我们可以设$T=k&#42;d$，于是我们有：
$\large \sum_{k\in prime}^{n}\sum_{d=1}^{n/k}μ(\frac{T}{k})\frac{n}{T}\frac{m}{T}$
然后可以把后面那个和式提前，枚举T，有：
$\large \sum_{T=1}^{n}\frac{n}{T}\frac{m}{T}\sum_{(k\in prime,k|T)}μ(\frac{T}{k})$

搞定，到这里为止，我们一切东西都可以算了。
前面的$\frac{n}{T}\frac{m}{T}$可以整除分块来搞，后面那个$μ$可以在$O(n)$的时间预处理，然后算的时候前缀和一搞就ok啦。
如何预处理呢？我们可以考虑这样做：我们先枚举每一个质数$x$，再考虑这个$x$对它的整数倍$t$的贡献为$\mu(t)$

酱紫，我们就可以在$O(\sqrt n)$的时间内处理每一个询问了。
完结撒花✿✿ヽ(°▽°)ノ✿

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P2257 YY的GCD
//Jan,22ed,2019
//莫比乌斯反演
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x\*10+c-'0';c=getchar();}
    return x\*f;
}
const int N=10000000+1000;
const int M=10000000;
int mu[N],prime[N],cnt_p;
bool noPrime[N];
void GetPrime(int n)
{
    mu[1]=1;
    noPrime[1]=true;
    for(int i=2;i&lt;=n;i++)
    {
        if(noPrime[i]==false)
            prime[++cnt_p]=i,mu[i]=-1;
        for(int j=1;j&lt;=cnt_p and i\*prime[j]&lt;=n;j++)
        {
            noPrime[i\*prime[j]]=true;
            if(i%prime[j]==0)
            {
                mu[i\*prime[j]]=0;
                break;
            }
            mu[i\*prime[j]]=mu[i]\*mu[prime[j]];
        }
    }
}
long long f[N],pre_f[N];
int main()
{
    int t=clock();
    GetPrime(M);
    for(int i=1;i&lt;=cnt_p;i++)
        for(int j=1;prime[i]\*j&lt;=M;j++)
            f[prime[i]\*j]+=mu[j];
    for(int i=1;i&lt;=M;i++)
        pre_f[i]=pre_f[i-1]+f[i];

    int T=read();
    for(;T&gt;0;T--)
    {
        long long n=read(),m=read();
        if(n&gt;m) swap(n,m);

        int l=1,r=1;
        long long ans=0;
        for(;l&lt;=n;l=r+1)
        {
            r=min(n/(n/l),m/(m/l));
            ans+=(pre_f[r]-pre_f[l-1])\*(n/l)\*(m/l);
        }

        printf("%lld\n",ans);
    }
    cerr&lt;&lt;clock()-t;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>262</wp:post_id>
		<wp:post_date><![CDATA[2019-03-04 05:28:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-04 05:28:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2257-yy%e7%9a%84gcd]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8f%8d%e6%bc%94"><![CDATA[反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[343]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu  P3455] [POI2007]ZAP-Queries</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p3455-poi2007zap-queries/</link>
		<pubDate>Mon, 04 Mar 2019 05:31:43 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=264</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3455">洛咕</a>

<hr />

<h1>Solution</h1>

<del>这题比<a href="https://www.cnblogs.com/GoldenPotato/p/10302839.html">这题</a>不懂简单到哪里去了</del>

好吧，我们来颓柿子。
<strong>为了防止重名，以下所有柿子中的$x$既是题目中的$d$</strong>
<strong>为了方便讨论，以下柿子均假设$b>=a$</strong>
<strong>为了方便书写，以下除号均为向下取整</strong>
题目要求的显然是：
$\large \sum_{i=1}^{a}\sum_{j=1}^{b}[gcd(i,j)=x]$

<del>根据套路，</del>我们这里要先把这个$x$除掉
$\large \sum_{i=1}^{a/x}\sum_{j=1}^{b/x}[gcd(i,j)=1]$

<del>再根据套路</del>，根据莫比乌斯函数中$[x=1]=\sum_{d|x}\mu(d)$的性质，我们把这个$gcd(i,j)$略作转换：
$\large \sum_{i=1}^{a/x}\sum_{j=1}^{b/x}\sum_{d|gcd(i,j)}\mu(d)$

<del>再次根据套路</del>，我们把$d$的和号改成枚举$d$的形式：
$\large \sum_{i=1}^{a/x}\sum_{j=1}^{b/x}\sum_{d=1}^{a/x}\mu(d)&#42;[d|gcd(i,j)]$
显然，我们可以把$\mu(d)$和它前面的和号提到前面去
$\large \sum_{d=1}^{a/x}\mu(d)\sum_{i=1}^{a/x}\sum_{j=1}^{b/x}[d|gcd(i,j)]$
显然，若要$[d|gcd(i,j)]=1$，则$i,j$都必须为$d$的倍数
$\large \sum_{d=1}^{a/x}\mu(d)\frac{a}{x&#42;d}\frac{b}{x&#42;d}$

OK,到此为止，我们所有东西都可以算了。
前面那个$\mu(d)$可以配上后面的两个和号用整除分块的方法前缀和计算即可。如果不是很清楚的话可以看一下代码。
时间复杂度$O(m&#42;\sqrt n)$

完结撒花✿✿ヽ(°▽°)ノ✿0

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu P3455 [POI2007]ZAP-Queries
//Jan,22ed,2019
//莫比乌斯反演
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x\*10+c-'0';c=getchar();}
    return x\*f;
}
const int N=50000+100;
const int M=50000;
int cnt_p,prime[N],mu[N];
bool noPrime[N];
void GetPrime(int n)
{
    noPrime[1]=true,mu[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(noPrime[i]==false)
            prime[++cnt_p]=i,mu[i]=-1;
        for(int j=1;j&lt;=cnt_p and i\*prime[j]&lt;=n;j++)
        {
            noPrime[i\*prime[j]]=true;
            if(i%prime[j]==0)
            {
                mu[i\*prime[j]]=0;
                break;
            }
            mu[i\*prime[j]]=mu[i]\*mu[prime[j]];
        }
    }
}
long long pre_mu[N];
int main()
{
    GetPrime(M);
    for(int i=1;i&lt;=M;i++)
        pre_mu[i]=pre_mu[i-1]+mu[i];

    int T=read();
    for(;T&gt;0;T--)
    {
        long long a=read(),b=read(),x=read();

        long long ans=0;
        if(a&gt;b) swap(a,b);
        a/=x,b/=x;
        for(int l=1,r;l&lt;=a;l=r+1)
        {
            r=min(a/(a/l),b/(b/l));
            ans+=(pre_mu[r]-pre_mu[l-1])\*(a/l)\*(b/l);
        }

        printf("%lld\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>264</wp:post_id>
		<wp:post_date><![CDATA[2019-03-04 05:31:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-04 05:31:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3455-poi2007zap-queries]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8f%8d%e6%bc%94"><![CDATA[反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[305]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3327] [SDOI2015]约数个数和</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p3327-sdoi2015%e7%ba%a6%e6%95%b0%e4%b8%aa%e6%95%b0%e5%92%8c/</link>
		<pubDate>Tue, 05 Mar 2019 06:57:16 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=294</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面：</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P3327">洛咕</a>

<hr />

<h1>Solution</h1>

首先，我们需要一个结论：
$\large d(i,j)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$

<blockquote>
  证明
  理性证明请看<a href="https://www.luogu.org/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">这篇博客</a>的例五
  本蒟蒻提供一个感性证明的方法：如果$x&#42;y$是$i&#42;j$的因数，我们必须有$x|i,y|j$，而后面那个$gcd(x,y)$是用来去重的
</blockquote>

有了这个柿子之后，我们之后的推导就比较套路了：
<strong>为了方便讨论，之后的柿子均默认$m>n$</strong>
<strong>为了方便书写，之后的除法默认向下取整</strong>
原式：
$\large \sum_{i=1}^n\sum_{j=1}^md(i&#42;j)$

把我们上面的结论代进去
$\large \sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$

<del>根据套路</del>，这里的$x|i$与$y|j$应该写成枚举的形式：
$\large \sum_{i=1}^n\sum_{j=1}^m\sum_{x=1}^{n}[x|i]\sum_{y=1}^{m}[y|j][gcd(x,y)=1]$

这里显然可以把$x,y$的和式写到最前面去：
$\large \sum_{x=1}^{n}[x|i]\sum_{y=1}^{m}[y|j]\sum_{i=1}^n\sum_{j=1}^m[gcd(x,y)=1]$
然后就可以去掉$x,y$后面的那两个判断式啦
$\large \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{i=1}^{n/x}\sum_{j=1}^{m/y}[gcd(x,y)=1]$

然后我们再去套路后面那个$gcd$，根据莫比乌斯函数的性质$[x=1]=\sum_{d|x}\mu(d)$，我们就把$gcd$带入得
$\large \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{i=1}^{n/x}\sum_{j=1}^{m/y}\sum_{d|gcd(x,y)}\mu(d)$
然后去枚举$d$
$\large \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{i=1}^{n/x}\sum_{j=1}^{m/y}\sum_{d=1}^{n}\mu(d)[d|gcd(x,y)]$
套路地把$\mu$的和式丢到最前面，化简一下就有：
$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\sum_{y=1}^{m/d}\sum_{i=1}^{n/(x&#42;d)}\sum_{j=1}^{m/(y&#42;d)}1$
然后有
$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\sum_{y=1}^{m/d}\frac{n}{x&#42;d}\frac{m}{y&#42;d}$

移项整理一下：
$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\frac{n}{x&#42;d}\sum_{y=1}^{m/d}\frac{m}{y&#42;d}$

<del>好了，到这里我就不会推了</del>
<img src="https://s2.ax1x.com/2019/01/23/kAl7Ct.jpg" alt="kAl7Ct.jpg" />

之后的内容感谢@Maxwei_wzj的教学
事实上，这个柿子我们已经可以算了。
$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\frac{n}{x&#42;d}\sum_{y=1}^{m/d}\frac{m}{y&#42;d}$
首先，我们有一个结论<del>(我不会证)</del>
$\large x/(y&#42;z)=(x/y)/z$ (这里的除法<strong>向下取整</strong>)

我们的柿子就可以变为
$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\frac{\frac{n}{d}}{x}\sum_{y=1}^{m/d}\frac{\frac{m}{d}}{y}$

然后我们再设一个方程:
$f(x)=\sum_{i=1}^x\frac{x}{i}$
我们柿子就可以写为：
$\large \sum_{d=1}^{n}\mu(d)f(\frac{n}{d})f(\frac{m}{d})$

诶？我们好像又能整除分块了。
没错，我们只需要先用$O(n&#42;\sqrt n)$的整除分块预处理出$f$
然后再每次$O(\sqrt n)$整除分块算出那个柿子就好。

时间复杂度$O(n&#42;\sqrt n)$
完结撒花✿✿ヽ(°▽°)ノ✿

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">//Luogu  P3327 [SDOI2015]约数个数和
//Jan,22ed,2019
//莫比乌斯反演
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x\*10+c-'0';c=getchar();}
    return x\*f;
}
const int N=50000+1000;
const int M=50000;
int prime[N],p_cnt,mu[N];
bool noPrime[N];
void GetPrime(int n)
{
    noPrime[1]=true,mu[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(noPrime[i]==false)
            prime[++p_cnt]=i,mu[i]=-1;
        for(int j=1;j&lt;=p_cnt and i\*prime[j]&lt;=n;j++)
        {
            noPrime[i\*prime[j]]=true;
            if(i%prime[j]==0)
            {
                mu[i\*prime[j]]=0;
                break;
            }
            mu[i\*prime[j]]=mu[i]\*mu[prime[j]];
        }
    }
}
long long f[N],pre_mu[N];
int main()
{
    GetPrime(M);
    for(int i=1;i&lt;=M;i++)
        for(int l=1,r;l&lt;=i;l=r+1)
        {
            r=i/(i/l);
            f[i]+=(r-l+1)\*(i/l);
        }
    for(int i=1;i&lt;=M;i++)
        pre_mu[i]=pre_mu[i-1]+mu[i];

    int T=read();
    for(;T&gt;0;T--)
    {
        long long n=read(),m=read();
        if(n&gt;m) swap(n,m);

        long long ans=0;
        for(int l=1,r;l&lt;=n;l=r+1)
        {
            r=min(n/(n/l),m/(m/l));
            ans+=(pre_mu[r]-pre_mu[l-1])\*f[n/l]\*f[m/l];
        }

        printf("%lld\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>294</wp:post_id>
		<wp:post_date><![CDATA[2019-03-05 06:57:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-05 06:57:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3327-sdoi2015%e7%ba%a6%e6%95%b0%e4%b8%aa%e6%95%b0%e5%92%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8f%8d%e6%bc%94"><![CDATA[反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[381]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[67]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2522] [HAOI2011]Problem b</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p2522-haoi2011problem-b/</link>
		<pubDate>Tue, 05 Mar 2019 06:58:14 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=295</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2522">洛咕</a>

<hr />

<h1>Solution</h1>

<del>我怎么只会刷水题</del>

<a href="https://www.cnblogs.com/GoldenPotato/p/10304040.html">这题</a>的双倍经验题，不多说啥了。

啥？范围不一样？
那根据我们写数位DP及二维前缀和的经验，我们容斥一下......

然后就没有然后了。
时间复杂度$O(m*\sqrt n)$

<hr />

<h1>Code</h1>

<del>人傻自带大常数,不开O2 T一个点</del>
事实上这题可以把一些不必要的$longlong$改成$int$，刚好能过。<del>可惜我太颓，不想改了</del>

<pre><code class="language-cpp ">//Luogu P2522 [HAOI2011]Problem b
//Jan,23rd,2019
//莫比乌斯函数双倍经验题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50000+1000;
const int M=50000;
int prime[N],p_cnt,mu[N];
bool noPrime[M];
void GetPrime(int n)
{
    noPrime[1]=true,mu[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(noPrime[i]==false)
            prime[++p_cnt]=i,mu[i]=-1;
        for(int j=1;j&lt;=p_cnt and i*prime[j]&lt;=n;j++)
        {
            noPrime[i*prime[j]]=true;
            if(i%prime[j]==0)
            {
                mu[i*prime[j]]=0;
                break;
            }
            mu[i*prime[j]]=mu[i]*mu[prime[j]];
        }
    }
}
long long pre_mu[N];
long long GetAns(long long n,long long m,int K)
{
    long long t_ans=0;
    if(n&gt;m) swap(n,m);
    n/=K,m/=K;
    for(int l=1,r;l&lt;=n;l=r+1)
    {
        r=min(n/(n/l),m/(m/l));
        t_ans+=(pre_mu[r]-pre_mu[l-1])*(n/l)*(m/l);
    }
    return t_ans;
}
int main()
{
    GetPrime(M);
    for(int i=1;i&lt;=M;i++)
        pre_mu[i]=pre_mu[i-1]+mu[i];

    int T=read();
    for(;T&gt;0;T--)
    {
        long long a=read(),b=read(),c=read(),d=read(),K=read();
        long long ans=GetAns(b,d,K)-GetAns(a-1,d,K)-GetAns(b,c-1,K)+GetAns(a-1,c-1,K);
        printf("%lld\n",ans);
    }

    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>295</wp:post_id>
		<wp:post_date><![CDATA[2019-03-05 06:58:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-05 06:58:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2522-haoi2011problem-b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8f%8d%e6%bc%94"><![CDATA[反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[332]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1829] [国家集训队]Crash的数字表格 / JZPTAB</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e5%ad%a6/luogu-p1829-%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9fcrash%e7%9a%84%e6%95%b0%e5%ad%97%e8%a1%a8%e6%a0%bc-jzptab/</link>
		<pubDate>Tue, 05 Mar 2019 07:02:01 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=296</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P1829">洛咕</a>

<hr />

<h1>Solution</h1>

<del>调到自闭，我好菜啊</del>
<strong>为了方便讨论，以下式子$m>=n$</strong>
<strong>为了方便书写，以下式子中的除号均为向下取整</strong>

我们来颓柿子吧qwq
显然，题目让我们求：
$\large \sum_{i=1}^n\sum_{j=1}^m lcm(i,j)$

$lcm$没法玩，我们转到$gcd$形式：
$\large \sum_{i=1}^n\sum_{j=1}^m \frac{i&#42;j}{gcd(i,j)}$

根据套路，我们去枚举$gcd$
$\large \sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^{n} \frac{i&#42;j}{d}[gcd(i,j)=d]$
然后可以把$d$的和号移到前面去
$\large \sum_{d=1}^{n}\sum_{i=1}^n\sum_{j=1}^m \frac{i&#42;j}{d}[gcd(i,j)=d]$

要让$gcd(i,j)=d$，$i,j$都必须要为$d$的倍数，我们可以将原来的$i&#42;d,j&#42;d$映射为$i,j$,有：
$\large \sum_{d=1}^{n}\sum_{i=1}^{n/d}\sum_{j=1}^{m/d} {i&#42;j}&#42;d[gcd(i,j)=1]$
把$d$移到前面去
$\large \sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d} {i&#42;j}[gcd(i,j)=1]$

然后我们可以套路地根据$[x=1]=\sum_{d|x}\mu(d)$这个柿子把$gcd(i,j)$处理掉：
$\large \sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d} {i&#42;j}\sum_{k|gcd(i,j)}\mu(k)$

根据套路，我们把这种奇奇怪怪的和式变为枚举的形式
$\large \sum_{d=1}^{n}d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d} {i&#42;j}\sum_{k=1}^{n/d}[k|gcd(i,j)]\mu(k)$
然后就可以把$k$往前提了
$\large \sum_{d=1}^{n}d\sum_{k=1}^{n/d}\sum_{i=1}^{n/d}\sum_{j=1}^{m/d} {i&#42;j}&#42;[k|gcd(i,j)]\mu(k)$
要有$k|gcd(i,j)$，$i,j$一定要为$k$的倍数
$\large \sum_{d=1}^{n}d\sum_{k=1}^{n/d}\sum_{i=1}^{\frac{n}{d&#42;k}}\sum_{j=1}^{\frac{m}{d&#42;k}} {i&#42;j&#42;k^2}&#42;\mu(k)$

然后我们简单的移一下项方便处理
$\large \sum_{d=1}^{n}d\sum_{k=1}^{n/d}&#42;\mu(k)&#42;k^2\sum_{i=1}^{\frac{n}{d&#42;k}}i\sum_{j=1}^{\frac{m}{d&#42;k}} j$
后面的$j$与$i$没有半毛钱关系，我们可以把它分离开来
$\large \sum_{d=1}^{n}d\sum_{k=1}^{n/d}&#42;\mu(k)&#42;k^2(\sum_{i=1}^{\frac{n}{d&#42;k}}i)(\sum_{j=1}^{\frac{m}{d&#42;k}} j)$

搞定，到这里为止，我们所有东西都可以求了。
对于前面的$d$的和式，我们可以发现当$n/d,m/d$不变的时候，后面的柿子计算出来的结果是一样的，因此我们可以$O(\sqrt n)$来整除分块掉前面那个和式。
后面的那个柿子我们可以再来一次整数除法来计算：最后面的两个和式都是等差数列，前面的$\mu(k)&#42;k^2$可以前缀和直接计算。

总复杂度$O(\sqrt n &#42; \sqrt n)=O(n)$

<del>但是这题还有一个$O(\sqrt n)$的做法，蒟蒻太菜了不会，就不说了</del>

<hr />

<h1>Code</h1>

<strong>这题细节繁多，请注意多膜以防乘爆</strong>
<strong>预处理中的$i^2$会爆int，请注意</strong>

<pre><code class="language-cpp ">//Luogu  P1829 [国家集训队]Crash的数字表格 / JZPTAB
//Jan,23rd,2019
//莫比乌斯反演
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x\*10+c-'0';c=getchar();}
    return x\*f;
}
const int N=10000000+1000;
const int M=10000000;
const int poi=20101009;
int prime[N],cnt_p,mu[N];
bool noPrime[N];
void GetPrime(int n)
{
    noPrime[1]=true,mu[1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        if(noPrime[i]==false)
            prime[++cnt_p]=i,mu[i]=-1;
        for(int j=1;j&lt;=cnt_p and i\*prime[j]&lt;=n;j++)
        {
            noPrime[i\*prime[j]]=true;
            if(i%prime[j]==0)
            {
                mu[i\*prime[j]]=0;
                break;
            }
            mu[i\*prime[j]]=mu[i]\*mu[prime[j]];
        }
    }
}
long long n,m,pre_mu[N];
long long f(int d)
{
    long long t_ans=0;
    for(long long l=1,r;l&lt;=n/d;l=r+1)
    {
        r=min((n/d)/((n/d)/l),(m/d)/((m/d)/l));
        t_ans=(t_ans+(pre_mu[r]-pre_mu[l-1])\*(((1+n/d/l)\*(n/d/l)/2)%poi)%poi\*(((1+m/d/l)\*(m/d/l)/2)%poi))%poi;
    }
    return (t_ans%poi+poi)%poi;
}
int main()
{
    n=read(),m=read();
    if(n&gt;m) swap(n,m);

    GetPrime(m);
    for(long long i=1;i&lt;=m;i++)
        pre_mu[i]=((pre_mu[i-1]+mu[i]\*i\*i)%poi+poi)%poi;
    long long ans=0;
    for(long long l=1,r;l&lt;=n;l=r+1)
    {
        r=min(n/(n/l),m/(m/l));
        ans=((ans+(l+r)\*(r-l+1)/2%poi\*f(l))%poi+poi)%poi;
    }

    printf("%lld",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>296</wp:post_id>
		<wp:post_date><![CDATA[2019-03-05 07:02:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-05 07:02:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1829-%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9fcrash%e7%9a%84%e6%95%b0%e5%ad%97%e8%a1%a8%e6%a0%bc-jzptab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%8f%8d%e6%bc%94"><![CDATA[反演]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[292]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4168] [Violet]蒲公英</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p4168-violet%e8%92%b2%e5%85%ac%e8%8b%b1/</link>
		<pubDate>Tue, 05 Mar 2019 07:04:20 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=297</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4168">洛咕</a>

<hr />

<h1>Solution</h1>

题目要求求出区间众数，强制在线。

区间众数是一个比较尴尬的问题，我们无法用区间数据结构来处理这个问题，因为我们没法很好的合并区间众数的答案。

既然区间数据结构解决不了这个问题，我们可以考虑一下使用基于分块的算法，例如莫队。
这题用莫队非常好处理，不幸的是，这题要求强制在线。
因此我们考虑使用分块算法。

分块算法的核心在于把一整个块的信息压缩起来以便快速处理。
我们要查询一段区间的众数，我们可以考虑这样搞：<strong>对于这个区间内连续的块，我们先快速地查询这个连续的块中的众数，然后我们暴力处理这个区间剩余的左右两个零散的点，开一个桶暴力维护这些零散的点每个颜色出现的次数，每新加入一个点，就与整个区间的答案比较一下，如果更优就替换答案。</strong>

为了实现上面那个思路，我们必须要实现两点：<strong>快速求出一段连续块的每个颜色出现的次数，快速求出一段连续块的众数。</strong>
对于第一个问题，解决方法很简单，我们暴力做<strong>前缀和</strong>即可，复杂度$O(n*\sqrt n)$

<pre><code class="language-cpp ">for(int i=1;i&lt;=cnt_block;i++)
    {
        for(int j=1;j&lt;=to;j++)
            pre[i][j]=pre[i-1][j];
        for(int j=(i-1)*size;j&lt;i*size;j++)
            pre[i][a[j]]++;
    }
</code></pre>

对于第二个问题，我们可以考虑把每段连续块的答案预处理出来。
具体做法是：我们枚举每个块，然后我们暴力往后扫描，每扫到一个块的结尾就记录答案。

<pre><code class="language-cpp ">cnt[0]=-0x3f3f3f3f;
    for(int i=1;i&lt;=cnt_block;i++)
    {
        int t_ans=0;
        for(int j=(i-1)*size;j&lt;=n;j++)
        {
            cnt[a[j]]++;
            if(cnt[a[j]]&gt;cnt[t_ans] or (cnt[a[j]]==cnt[t_ans] and a[j]&lt;t_ans)) 
                t_ans=a[j];
            if((j+1)%size==0)
                f[i][j/size+1]=t_ans;
        }
        memset(cnt,0,sizeof cnt);
        cnt[0]=-0x3f3f3f3f;
    }
</code></pre>

就酱，这题就被我们搞定啦~
复杂度$O(n\sqrt n)$

<hr />

<h1>Code</h1>

<strong>本题实现上有较多细节要处理，请小心</strong>

<pre><code class="language-cpp ">//Luogu P4168 [Violet]蒲公英
//Feb,4th,2019
//分块套路题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=40000+1000;
const int M=200+10;
int n,m,a[N],b[N],t_n,mmap[N];//离散值-&gt;原值
int f[M][M],pre[M][N];//f[i][j]:块i到j的众数，pre[i][j]：到i块为止，颜色j的出现次数前缀和
int cnt[N];//零时记录每个元素出现次数
int main()
{
    //freopen("testdata.in","r",stdin);
    //freopen("4168.out","w",stdout);

    t_n=n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read(),b[i]=a[i];

    sort(b+1,b+1+n);
    int to=0,last=0;
    for(int i=1;i&lt;=n;i++)
        if(b[i]!=last)
            last=b[i],b[++to]=b[i];
    for(int i=1;i&lt;=n;i++)
    {
        int t=lower_bound(b+1,b+1+to,a[i])-b;
        mmap[t]=a[i],a[i]=t;
    }
    int size=int(sqrt(n)),cnt_block=n/size+1;
    n=cnt_block*size-1;
    for(int i=1;i&lt;=cnt_block;i++)
    {
        for(int j=1;j&lt;=to;j++)
            pre[i][j]=pre[i-1][j];
        for(int j=(i-1)*size;j&lt;i*size;j++)
            pre[i][a[j]]++;
    }
    cnt[0]=-0x3f3f3f3f;
    for(int i=1;i&lt;=cnt_block;i++)
    {
        int t_ans=0;
        for(int j=(i-1)*size;j&lt;=n;j++)
        {
            cnt[a[j]]++;
            if(cnt[a[j]]&gt;cnt[t_ans] or (cnt[a[j]]==cnt[t_ans] and a[j]&lt;t_ans)) 
                t_ans=a[j];
            if((j+1)%size==0)
                f[i][j/size+1]=t_ans;
        }
        memset(cnt,0,sizeof cnt);
        cnt[0]=-0x3f3f3f3f;
    }

    int ans=0;
    for(int i=1;i&lt;=m;i++)
    {
        int l=read(),r=read();
        l=(l+ans-1)%t_n+1,r=(r+ans-1)%t_n+1;
        if(l&gt;r) swap(l,r);

        int bl=l/size+1,br=r/size+1;
        ans=0;
        if(bl+1&lt;=br-1)
            ans=f[bl+1][br-1];
        for(int j=l;j&lt;bl*size and j&lt;=r;j++)
        {
            cnt[a[j]]++;
            int tmp1=cnt[a[j]],tmp2=cnt[ans];
            if(bl+1&lt;=br-1)
                tmp1+=pre[br-1][a[j]]-pre[bl][a[j]],
                tmp2+=pre[br-1][ans]-pre[bl][ans];
            if(tmp1&gt;tmp2 or (tmp1==tmp2 and a[j]&lt;ans)) 
                ans=a[j];
        }
        if(bl!=br)
            for(int j=(br-1)*size;j&lt;=r;j++)
            {
                cnt[a[j]]++;
                int tmp1=cnt[a[j]],tmp2=cnt[ans];
                if(bl+1&lt;=br-1)
                    tmp1+=pre[br-1][a[j]]-pre[bl][a[j]],
                    tmp2+=pre[br-1][ans]-pre[bl][ans];
                if(tmp1&gt;tmp2 or (tmp1==tmp2 and a[j]&lt;ans)) 
                    ans=a[j];
            }

        for(int j=l;j&lt;bl*size and j&lt;=r;j++)
            cnt[a[j]]--;
        if(bl!=br)
            for(int j=(br-1)*size;j&lt;=r;j++)
                cnt[a[j]]--;
        cnt[0]=-0x3f3f3f3f;

        ans=mmap[ans];
        printf("%d\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>297</wp:post_id>
		<wp:post_date><![CDATA[2019-03-05 07:04:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-05 07:04:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4168-violet%e8%92%b2%e5%85%ac%e8%8b%b1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[342]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>可并堆(左偏树)学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e5%8f%af%e5%b9%b6%e5%a0%86%e5%b7%a6%e5%81%8f%e6%a0%91%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Tue, 05 Mar 2019 23:26:21 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=304</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>为什么要学左偏树</h1>

有时候，某些题目要求我们合并两个堆。

合并两个堆，大家都知道可以用splay暴力启发式合并处理。很不幸的是，这玩意的复杂度是$O(nlog^2n)$的，在一些<del>毒瘤题目</del>专门考可并堆的题目中，是注定要被卡的。

可并堆系列算法可以很优雅的解决这系列的算法，她们可以在$O(nlogn)$的时间内处理两个堆合并的问题。而我现在要讲的左偏树就是可并堆中的一种。

<hr />

<h1>什么是左偏树</h1>

正如她字面意思一样，是一颗向左“偏”的树。什么叫“向左偏”呢？我们知道，平衡树的时间复杂度比二叉查找树优秀，是因为平衡树的左右子树深度尽可能平衡以保证每次大小/2。在这里呢，我们左偏树故意让左子树比右子树大一点来维护平衡性。

<hr />

<h1>左偏树咋写啊</h1>

左偏树是通过维护一个深度变量$dis[x]$来保证左孩子比右孩子略大的。$dis$的定义是：$dis[x]=min(dis[lson],dis[rson])$，考虑到我们的左偏树中每个节点都满足这个性质，易得：$dis[x]=dis[rson]+1$

<strong>以下内容默认左偏树为大根堆，小根堆请读者自行类比</strong>

<h3>Merge</h3>

明白$dis$的定义之后，左偏树就很好写了。假设我们现在要合并两颗左偏树，显然，新的树根一定是两棵树根权值较大的那个。然后我们把权值较大那棵树的树根作为新的树根，新的树的左孩子为权值较大的那棵树的左孩子，右孩子则递归合并另外那颗树与权值较大的树的右孩子。

代码大概长这样：

<pre><code class="language-cpp ">int Merge(int x,int y)//x,y为堆顶
{
    if(x==0 or y==0) return x+y;//若其中某颗子树为空则直接返回
    if(a[x]&lt;a[y]) swap(x,y);//保证x的权值&gt;y,方便接下来的讨论
    son[x][1]=Merge(son[x][1],y);//右孩子递归合并
    fa[son[x][0]]=fa[son[x][1]]=x;//设置左右孩子的fa
    if(dis[son[x][0]]&lt;dis[son[x][1]]) swap(son[x][0],son[x][1]);//维护左偏性质
    dis[x]=dis[son[x][1]]+1;//维护dis
    return x;
}
</code></pre>

<h3>Delete</h3>

左偏树作为一个堆，那自然要能删除堆顶元素。删除操作很好处理，我们把根去掉，然后Merge其孩子即可。
<strong>因为我们要对fa做路径压缩（如同并查集一样），我们这里必须把旧的根的fa设为新的根，以保证之后能正确的找到新的树的树根</strong>

<pre><code class="language-cpp ">void Delete(int x)//x为堆顶
{
    fa[son[x][0]]=fa[son[x][1]]=0;//重设孩子的fa
    fa[x]=Merge(son[x][0],son[x][1]);//Merge孩子并把旧根的fa设为新的根
}
</code></pre>

<hr />

<h1>有啥题目做啊</h1>

模板题：<a href="https://www.luogu.org/problemnew/show/P3377">P3377 【模板】左偏树（可并堆</a>
神题：<a href="https://www.luogu.org/problemnew/show/P3273">P3273 SCOI2011棘手的操作</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>304</wp:post_id>
		<wp:post_date><![CDATA[2019-03-05 23:26:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-05 23:26:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8f%af%e5%b9%b6%e5%a0%86%e5%b7%a6%e5%81%8f%e6%a0%91%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[477]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>基数排序学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Wed, 06 Mar 2019 00:08:31 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=305</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是基数排序</h1>

基数排序是一个时间复杂度为：$O(n*MAXNUM/base)$，空间复杂度为$O(base+n)$的优秀排序算法。

<hr />

<h1>基数排序有什么用</h1>

我们知道，桶排序可以在$O(MAXNUM)$的时间内，$O(MAXNUM)$的空间内排序一个数组，快速排序可以在$O(nlogn)$的时间内，$O(n)$的空间内排序一个数组。

如果有一个排序任务的最大数字比桶大，而数字数量又爆多怎么办？这时候，时空复杂度基于这两者之间的优秀排序：基数排序就闪亮登场啦~。

她一般会在以下场景使用：
1. 神题：<a href="https://www.luogu.org/problemnew/show/P4604">WC[2017]挑战</a>
2. 对于排序复杂度比较敏感而数字又不怎么大的算法，如：<strong>后缀数组</strong>

<hr />

<h1>基数排序怎么做</h1>

<h3>基数排序的原理</h3>

首先，我们可以先来了解以下基数排序的原理：如果给你一堆二位数，他们已经按个位数的大小排好了序，就像这样：<img src="https://s2.ax1x.com/2019/03/06/kjcfxg.png" alt="kjcfxg.png" />
想象一下：如果我们按十位数大小排序，如果十位数大小一样，则按原有的顺序(之前已按个位数大小拍好的序)来排序，这个序列会变成什么样？
没错，这个数组最后会被我们排好序！

在刚刚的推导过程中，我们显然可以发现：<strong>基数排序是一个不稳定的排序</strong>

<h3>基数排序的具体做法</h3>

按照刚刚的原理，我们可以发现基数排序相当于把原数拆为base进制数(base为我们选定的一个基数，在刚刚的例子中，base=10)，然后按位排序。
那我们具体怎么实现呢？

我们可以考虑用桶排序来实现每位排序的功能。
我们先<strong>把每个数在当前位下的那个数全部丢到一个桶里面，然后对这个桶做前缀和</strong>。

<pre><code class="language-cpp ">int cnt[10]={0};
for(int i=1;i&lt;=n;i++)
    cnt[(a[i]/exp)%10]++;
for(int i=0;i&lt;=9;i++)
    cnt[i]+=cnt[i-1];
</code></pre>

然后，我们从后往前去把所有的数看一遍，这个数当前的排名即为他所在的桶的值，然后把这个桶的值-1。（因为我们可以保证之前的排序中在前面的数一定比在后面的数小）

<pre><code class="language-cpp ">for(int i=n;i&gt;=1;i--)
    b[cnt[(a[i]/exp)%10]--]=a[i];
for(int i=1;i&lt;=n;i++)
    a[i]=b[i];
</code></pre>

然后，我们在外面再套一层枚举位数的就搞定啦~

<pre><code class="language-cpp ">void count_sort(int a[],int n,int exp)
{
    int cnt[10]={0};
    for(int i=1;i&lt;=n;i++)
        cnt[(a[i]/exp)%10]++;
    for(int i=0;i&lt;=9;i++)
        cnt[i]+=cnt[i-1];
    for(int i=n;i&gt;=1;i--)
        b[cnt[(a[i]/exp)%10]--]=a[i];
    for(int i=1;i&lt;=n;i++)
        a[i]=b[i];
}
void radix_sort(int a[],int n)
{
    int MAX=0;
    for(int i=1;i&lt;=n;i++)
        MAX=max(a[i],MAX);
    for(int i=1;i&lt;=MAX;i*=10)
        count_sort(a,n,i);
}
</code></pre>

<hr />

<h1>有啥题目练啊</h1>

<del>WC2017 挑战的第一个subtask</del>
后缀数组]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>305</wp:post_id>
		<wp:post_date><![CDATA[2019-03-06 00:08:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-06 00:08:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[324]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[78]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>后缀数组(SA)学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%97%e7%ac%a6%e4%b8%b2/%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84sa%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Wed, 06 Mar 2019 03:06:37 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=306</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>为什么要学后缀数组</h1>

为了解决一类字符串<del>神题</del>妙题。

<hr />

<h1>什么是后缀数组</h1>

<h3>什么是后缀</h3>

要理解什么是后缀数组，首先要明白什么是后缀。
一个字符串$[S_1:S_n]$的后缀为:$[S_i:S_n],i∈[1,n]$
用人话来说，就是从每个字符开始到这个字符串的结尾所组成的串均为这个字符串的后缀。

<blockquote>
  <strong>例如：</strong>假设我现在有一个字符串“abaaba”,那么。她的后缀有：a,ba,aba,aaba,baaba,abaaba。
</blockquote>

<h3>什么是后缀数组</h3>

把所有后缀按<strong>字典序</strong>排序之后所构成的数组。

<blockquote>
  <strong>例如：</strong>假设我现在有一个字符串“abaaba”,那么。她的后缀有：a,ba,aba,aaba,baaba,abaaba。她的后缀数组为：a,aaba,aba,abaaba,ba,baaba
</blockquote>

<hr />

<h1>后缀数组怎么求</h1>

<strong>FBI warning：本文并不会讲解为什么能这样求，但是她的证明并不难，感兴趣的读者可以自行拿出草稿纸感性理解一下，或百度一下以获得理性证明</strong>

这是一张极其著名的图片 (图出自<a href="https://baike.baidu.com/item/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/8989867?fr=aladdin">百度百科</a>)
<img src="https://s2.ax1x.com/2019/03/06/kjgVQe.png" alt="kjgVQe.png" />
<strong>这里的rank是我们要求的SA的“反数组”，rank指的是每个下标对应的后缀的排名，SA就是我们的后缀数组了：每个排名对应的后缀的下标</strong>

我想各位读者看这个图片已经能略懂一二，我们每次对求出来的东西离散化，然后按照类似于倍增的方法把前后两个数字拼起来，多次排序，直到rank的值互不相同为止。

<h3>如何排序</h3>

在这里，我们可以使用快速排序，那么求后缀数组的总复杂度为$O(nlog^2n)$，但是，如果我们在这里使用<a href="https://www.goldenpotato.cn/%E5%85%B6%E4%BB%96/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">基数排序</a>，单次排序的复杂度即可接近$O(n)$,总复杂度$O(nlogn)$

当然，在这里我们要对基数排序做一点微小的工作，按照正常的基数排序，是不能找到排序后每个值对应的原下标的。魔改的办法也很简单，我们只需要在每次排序的时候传入当前情况下每个值对应的原下标即可：

<pre><code class="language-cpp ">int n,sa[N],id[N];
void count_sort(long long a[],int n,int Exp,int m)
{
    static long long b[N],cnt[N];
    memset(cnt,0,sizeof cnt);
    for(int i=1;i&lt;=n;i++)
        cnt[(a[i]/Exp)%m]++;
    for(int i=1;i&lt;=m;i++)
        cnt[i]+=cnt[i-1];
    for(int i=n;i&gt;=1;i--)
    {
        b[cnt[(a[i]/Exp)%m]]=a[i];
        //我们这里相当于只排两位数，排第一位的时候我们将映射关系零时储存一下
        if(Exp==1) id[cnt[(a[i]/Exp)%m]--]=i;
        //事实上来说，我们第二次求出来的映射关系，本质上就是我们要求的SA数组
        else sa[cnt[(a[i]/Exp)%m]--]=id[i];
    }
    for(int i=1;i&lt;=n;i++)
        a[i]=b[i];
}
void radix_sort(long long a[],int n,int m)
{
    count_sort(a,n,1,m);
    count_sort(a,n,m,m);
}
void GetSA()
{
    for(int i=1;i&lt;=n;i++)
        t[i]=s[i],rank[i]=s[i];
    long long m='z'+1;
    for(int i=0;i&lt;=n;i++)
    { 
        for(int j=1;j&lt;=n;j++)
            rank[j]=t[j]=rank[j]*m+((j+(1&lt;&lt;i)&lt;=n)?rank[j+(1&lt;&lt;i)]:0);//把前后两个数拼起来
        radix_sort(t,n,m);//排序
        m=0;
        //离散化
        for(int j=1;j&lt;=n;j++)
        {
            if(t[j]!=t[j-1])
                ++m;
            rank[sa[j]]=m;
        }
        if(m==n) break;
        m++;
    }
}
</code></pre>

<hr />

<h1>后缀数组的进一步应用</h1>

显然，我们单纯的求出后缀数组是没有什么Egg用的，我们要发掘一下我们求出来的这玩意的性质。其中，最有用的即是后缀数组的LCP了。

<h2>LCP</h2>

lcp，即最长公共前缀，后缀数组的height[i]指的是SA[i]与SA[i-1]的LCP。
<img src="https://s2.ax1x.com/2019/03/06/kjgYLj.png" alt="kjgYLj.png" />

<strong>FBI warning：本文并不会讲解为什么能这样求，<del>因为我太菜了并不会</del>，请感兴趣的同学自行百度一下以获得理性证明</strong>

要求LCP，我们只需要一个性质<strong>height[rank[i]]]]><![CDATA[>=height[rank[i-1]]-1</strong>
然后，我们接下来暴力枚举即可，总复杂度$O(n)$

<pre><code class="language-cpp ">for(int i=1;i&lt;=n;i++)
{
    if(rank[i]==1) continue;
    int to=max(0,height[rank[i-1]]-1);
    for(;sa[rank[i]]+to&lt;=n and sa[rank[i]-1]+to&lt;=n;to++)
        if(s[sa[rank[i]]+to]!=s[sa[rank[i]-1]+to])
            break;
    height[rank[i]]=to;
}
</code></pre>

我们可以发现一个比较显然的性质：
<strong>两个后缀的$LCP[SA[i],SA[j]]=min(height[i+1,j])$</strong>

<h3>LCP的应用</h3>

我们思考一下：一个串的后缀的前缀是啥.......

emmmmmmmmmm？这不就<strong>是一个原串的子串</strong>吗？

OK，由这个性质我们就可以做很多事情了，我们在具体的题中再慢慢讲。
T1:<a href="https://www.goldenpotato.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2/luogu-p2852-usaco06dec%E7%89%9B%E5%A5%B6%E6%A8%A1%E5%BC%8Fmilk-patterns/">[USACO06DEC]牛奶模式Milk Patterns</a>
T2：<a href="https://www.goldenpotato.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2/luogu-p2743-usaco5-1%E4%B9%90%E6%9B%B2%E4%B8%BB%E9%A2%98musical-themes/">[USACO5.1]乐曲主题Musical Themes</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>306</wp:post_id>
		<wp:post_date><![CDATA[2019-03-06 03:06:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-06 03:06:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84sa%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[400]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[332]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2852] [USACO06DEC]牛奶模式Milk Patterns</title>
		<link>https://www.goldenpotato.cn/%e5%ad%97%e7%ac%a6%e4%b8%b2/luogu-p2852-usaco06dec%e7%89%9b%e5%a5%b6%e6%a8%a1%e5%bc%8fmilk-patterns/</link>
		<pubDate>Wed, 06 Mar 2019 03:44:45 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=333</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.luogu.org/problemnew/show/P2852">洛谷P2852</a>

<hr />

<h1>Solution</h1>

首先，我们阅读题面可以发现题目让我们求出一个<strong>出现次数>k的可重复的子串</strong>。

这玩意我们可以用SA求，也可以用SAM求。

<h3>SA</h3>

这题用SA做就比较妙，首先我们显然要求把SA及height求出来。
因为<strong>两个后缀的LCP是它们之间的height的min</strong>，我们可以利用这个性质。

考虑一个子串，它所能“控制”的区间的所有的height都必须比它大。
因此，我们可以找出一个height所影响的左右范围，这个我们使用单调栈可以很轻松地求出。

<pre><code class="language-cpp ">for(int i=1;i&lt;=n;i++)
{
    while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--;
    L[i]=mstack[top]+1;
    mstack[++top]=i;
}
mstack[top=0]=n+1;
for(int i=n;i&gt;=1;i--)
{
    while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--;
    R[i]=mstack[top]-1;
    mstack[++top]=i;
}
</code></pre>

然后我们可以发现一个height所“控制”的区间中，这个串被“引用”的次数一定是$R[i]-(L[i]-1)+1$，下面这个图可以简单的说明这一点：
<a href="https://imgchr.com/i/kjv0bR"><img src="https://s2.ax1x.com/2019/03/06/kjv0bR.md.png" alt="kjv0bR.md.png" /></a>

这样，我们只需要二分一个答案，然后一路扫过去检查就完事啦(～￣▽￣)～ 
时间复杂度$O(nlogn)$,空间复杂度$O(n)$

<h3>SAM</h3>

这题用SAM做就非常显然了。<strong>根据fail树的性质：fail树中的每个节点所代表的串都必然是它的孩子节点的后缀</strong>。我们可以得到一个比较显然的性质：每个叶子节点所代表的子串在原串中只出现了1次，而每个节点所代表的子串在原串中出现的次数必然为它的孩子的出现次数的总和，如果这个点不是被复制出来的，次数还要+1（它自己所代表的串）；

然后，我们只需要便利一遍SAM，把所有出现次数>K的节点的len取个max即可。

时间复杂度$O(n)$，空间复杂度$O(n\ *10)$

<hr />

<h1>Code</h1>

我只写了SA的做法，SAM的做法还请自行yy

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int M=1000000+100;
const int N=20000+100;
int s[N],sa[N],id[N],height[N];
long long rank[N];
void CountSort(long long a[],int n,int Exp,int m)
{
    static long long cnt[M],b[N];
    memset(cnt,0,sizeof cnt);
    for(int i=1;i&lt;=n;i++)
        cnt[(a[i]/Exp)%m]++;
    for(int i=1;i&lt;=m;i++)
        cnt[i]+=cnt[i-1];
    for(int i=n;i&gt;=1;i--)
    {
        b[cnt[(a[i]/Exp)%m]]=a[i];
        if(Exp==1)
            id[cnt[(a[i]/Exp)%m]--]=i;
        else
            sa[cnt[(a[i]/Exp)%m]--]=id[i];
    }
    for(int i=1;i&lt;=n;i++)
        a[i]=b[i];
}
void RadixSort(long long a[],int n,int m)
{   
    CountSort(a,n,1,m);
    CountSort(a,n,m,m);
}
int n,K,L[N],R[N];
void GetSA()
{   
    static long long t[N];
    for(int i=1;i&lt;=n;i++)
        rank[i]=t[i]=s[i];
    int m=1000000+1;
    for(int k=1;;k=k&lt;&lt;1)
    {
        for(int i=1;i&lt;=n;i++)
            rank[i]=t[i]=rank[i]*m+(i+k&lt;=n?rank[i+k]:0);
        RadixSort(t,n,m);
        m=0;
        for(int i=1;i&lt;=n;i++)
        {
            if(t[i]!=t[i-1])
                m++;
            rank[sa[i]]=m;
        }
        if(m==n) break;
        m++;
    }

    for(int i=1;i&lt;=n;i++)
    {
        if(rank[i]==1) continue;
        int to=max(0,height[rank[i-1]]-1);
        for(;sa[rank[i]]+to&lt;=n and sa[rank[i]-1]+to&lt;=n;to++)
            if(s[sa[rank[i]]+to]!=s[sa[rank[i]-1]+to])
                break;
        height[rank[i]]=to;
    }
}
int mstack[N],top;//记录从哪来，单调严格上升栈
bool Check(int x)
{
    for(int i=1;i&lt;=n;i++)
        if(height[i]&gt;=x and (R[i]-(L[i]-1)+1)&gt;=K)
            return true;
    return false;
}
int main()
{
    n=read(),K=read();
    for(int i=1;i&lt;=n;i++)
        s[i]=read();

    GetSA();
    for(int i=1;i&lt;=n;i++)
    {
        while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--;
        L[i]=mstack[top]+1;
        mstack[++top]=i;
    }
    mstack[top=0]=n+1;
    for(int i=n;i&gt;=1;i--)
    {
        while(top&gt;0 and height[i]&lt;=height[mstack[top]]) top--;
        R[i]=mstack[top]-1;
        mstack[++top]=i;
    }

    int ans=0,l=0,r=n,mid;
    while(l&lt;=r)
    {
        mid=(l+r)/2;
        if(Check(mid)==true)
            l=mid+1,ans=max(ans,mid);
        else
            r=mid-1;
    }

    printf("%d",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>333</wp:post_id>
		<wp:post_date><![CDATA[2019-03-06 03:44:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-06 03:44:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2852-usaco06dec%e7%89%9b%e5%a5%b6%e6%a8%a1%e5%bc%8fmilk-patterns]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[368]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[327]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2743] [USACO5.1]乐曲主题Musical Themes</title>
		<link>https://www.goldenpotato.cn/%e5%ad%97%e7%ac%a6%e4%b8%b2/luogu-p2743-usaco5-1%e4%b9%90%e6%9b%b2%e4%b8%bb%e9%a2%98musical-themes/</link>
		<pubDate>Wed, 06 Mar 2019 04:28:22 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=335</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P2743">洛谷 P2743</a>

<hr />

<h1>Solution</h1>

这题可以用哈希做，也可以用SA做。下面我们分别讲一下两种做法。

<h3>哈希</h3>

首先，我们把转掉的问题处理掉。我们考虑把原串做差分数组，即用后面那一个减去前面那一个。这样子，我们直接在新的串上找完全相同的两个不可重叠子串即可。

这个，我们考虑先在外面二分一个答案的长度，然后暴力做，从后往前扫，把所有子串都丢到哈希表里面，插入一个新的串之前，就检查一下之前是否有这个串，如果有的话，就检查一下是否满足相隔长度是否大于mid即可。

时间复杂度$O(nlogn)$

<h3>后缀数组</h3>

这题的后缀数组做法就比较妙了。

首先，我们还是要做差分数组的。
然后，我们还是要求出SA及height的(不会SA的小伙伴可以看<a href="https://www.goldenpotato.cn/字符串/后缀数组sa学习笔记/">这里</a>)
然后，我们仍然是在外面二分答案，然后考虑怎么检查。

因为每个串不可重复，我们可以考虑把height数组分组，我们希望一个组尽可能长，并且组内所有元素的$height>=mid$，这样子，如果这个组里面有两个原数的sa相隔超过mid，则说明这个结果是正确的。

时间复杂度$O(nlogn)$

<hr />

<h1>Code</h1>

我写的双模hash，而且没有使用哈希表，用的是set，总复杂度$O(nlog^2n)$

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
const int N=20000+100;
const int E=233;
const int P2=2333333333;
int n;
unsigned long long POW[N];
long long POW2[N],c[N];
void Init()
{
    POW2[0]=POW[0]=1;
    for(int i=1;i&lt;=n;i++)
        POW[i]=POW[i-1]*E,
        POW2[i]=(POW2[i-1]*E)%P2;
}
struct rec
{
    unsigned long long hash;
    long long hash2;
    int t;
    friend bool operator &lt; (rec a,rec b)
    {
        if(a.hash==b.hash)
            return a.hash2&lt;b.hash2;
        return a.hash&lt;b.hash;
    }
};
set &lt;rec&gt; record;
bool Check(int ans)
{
    record.clear();
    unsigned long long hash=0;
    long long hash2=0;
    for(int i=1;i&lt;=ans;i++)
    {
        hash=hash+c[i]*POW[ans-i+1];
        hash2=(hash2+c[i]*POW2[ans-i+1])%P2;    
    }
    record.insert((rec){hash,hash2,ans});
    for(register int i=ans+1;i&lt;n;i++)
    {
        hash=(hash-c[i-ans]*POW[ans])*E+c[i]*E;
        hash2=((((hash2-c[i-ans]*POW2[ans])*E+c[i]*E)%P2)+P2)%P2;
        set &lt;rec&gt; :: iterator p=record.lower_bound((rec){hash,hash2,0});
        if((*p).hash==hash and (*p).hash2==hash2)
        {
            if(i-(*p).t&gt;=ans)
                return true;
        }
        else
            record.insert((rec){hash,hash2,i});
    }       
    return false;
}
int main()
{
    scanf("%d",&amp;n);
    for(register int i=1;i&lt;=n;i++)
        scanf("%lld",&amp;c[i]);
    for(register int i=1;i&lt;n;i++)
        c[i]=c[i+1]-c[i];
    Init();

    int L=4,R=n,mid,ans=0;
    while(L&lt;=R)
    {
        mid=(L+R)&gt;&gt;1;
        if(Check(mid)==true)
            ans=mid+1,L=mid+1;
        else
            R=mid-1;
    }

    if(ans==6) ans++;
    printf("%d",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>335</wp:post_id>
		<wp:post_date><![CDATA[2019-03-06 04:28:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-06 04:28:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2743-usaco5-1%e4%b9%90%e6%9b%b2%e4%b8%bb%e9%a2%98musical-themes]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="category" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[355]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[SPOJ694] DISUBSTR - Distinct Substrings</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/spoj694-disubstr-distinct-substrings/</link>
		<pubDate>Wed, 06 Mar 2019 15:32:09 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=337</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

传送门：<a href="https://www.spoj.com/problems/DISUBSTR/">SPOJ 694</a>

<hr />

<h1>Solution</h1>

这题可以用SAM来搞，也可以用SA来搞。但无论是哪种搞法，都是基本操作。下面我们来分别讲解一下怎么搞。

<h3>SAM</h3>

这题用SAM来求就十分粗暴简单。不会SAM的小伙伴可以戳<a href="https://www.goldenpotato.cn/uncategorized/后缀自动机sam学习笔记/">这里</a>

首先，我们先把SAM建出来。根据SAM的性质，我们从出发点随着SAM任意走，走到哪里都是一个完全不同的子串。因此，我们只需要对SAM做一个拓扑序DP/记忆化搜索即可求出SAM上的路径总数，既不同子串的数量。

<h3>SA</h3>

这题我们显然还是要把后缀数组和height建出来的，不会SA的小伙伴可以戳<a href="https://www.goldenpotato.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84sa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">这里</a>

我们可以发现，<strong>对于原串的一个后缀，它的每一个前缀都是原串中的子串</strong>。因此，如果我们把所有后缀长度加起来，得到的就是子串的总数量。

如何去重呢？我们可以发现任意两个后缀，它们会造成重复的子串一定是它们的公共前缀。因此，重复的子串的数量即为$\sum_{i=0}^nheight[i]$，<strong>答案既是后缀总长度减去重复子串的数量</strong>

<hr />

<h1>Code</h1>

本题我用SA来实现，用SAM的小伙伴还请自行yy一下w。

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1000+10;
int id[N],sa[N],height[N];
long long rank[N];
void CountSort(long long a[],int n,int exp,int m)
{
    static long long cnt[N],b[N];
    memset(cnt,0,sizeof cnt);
    for(int i=1;i&lt;=n;i++)
        cnt[(a[i]/exp)%m]++;
    for(int i=1;i&lt;=m;i++)
        cnt[i]+=cnt[i-1];
    for(int i=n;i&gt;=1;i--)
    {
        b[cnt[(a[i]/exp)%m]]=a[i];
        if(exp==1)
            id[cnt[(a[i]/exp)%m]--]=i;
        else
            sa[cnt[(a[i]/exp)%m]--]=id[i];
    }
    for(int i=1;i&lt;=n;i++)
        a[i]=b[i];
}
void RadixSort(long long a[],int n,int m)
{
    CountSort(a,n,1,m);
    CountSort(a,n,m,m);
}
char s[N];
int n;
void GetSA()
{
    static long long t[N];
    for(int i=1;i&lt;=n;i++)
        rank[i]=t[i]=s[i];
    int m=1000+1;
    for(int k=1;;k=(k&lt;&lt;1))
    {
        for(int i=1;i&lt;=n;i++)
            rank[i]=t[i]=rank[i]*m+(i+k&lt;=n?rank[i+k]:0);
        RadixSort(t,n,m);
        m=0;
        for(int i=1;i&lt;=n;i++)
        {
            if(t[i]!=t[i-1]) m++;
            rank[sa[i]]=m;
        }
        if(m==n) break;
        m++;
    }

    for(int i=1;i&lt;=n;i++)
    {
        if(rank[i]==1) continue;
        int to=max(0,height[rank[i-1]]-1);
        for(;sa[rank[i]]+to&lt;=n and sa[rank[i]-1]+to&lt;=n;to++)
            if(s[sa[rank[i]]+to]!=s[sa[rank[i]-1]+to])
                break;
        height[rank[i]]=to;
    }
}
int main()
{
    int T;
    scanf("%d",&amp;T);

    for(;T&gt;0;T--)
    {
        scanf("%s",s+1);

        n=strlen(s+1);
        memset(rank,0,sizeof rank);
        GetSA();
        long long ans=0;
        for(int i=1;i&lt;=n;i++)
            ans+=n-sa[i]+1-height[i];

        printf("%lld\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>337</wp:post_id>
		<wp:post_date><![CDATA[2019-03-06 15:32:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-06 15:32:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[spoj694-disubstr-distinct-substrings]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="dag-dp"><![CDATA[DAG DP]]></category>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="category" nicename="%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[后缀自动机]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[474]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3302] [SDOI2013]森林</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3302-sdoi2013%e6%a3%ae%e6%9e%97/</link>
		<pubDate>Thu, 07 Mar 2019 03:34:51 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=340</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3302">洛谷P3302</a>

<hr />

<h1>Solution</h1>

拿到这道题，我们不妨先想一下静态的树上K大怎么搞。
静态树上K大有两种办法，一是树链剖分+平衡树，二是主席树做链前缀和。前者的复杂度是$O(log^2n)$的，而后者只有$O(logn)$。

我们考虑把数字全部离散化，然后开权值主席树，每颗主席树记录从它出发到根的路上每个数字出现了多少个。接下来，我们只需要找到LCA。因为数字出现个数满足可减性，因此，我们是可以“扣”出从这个点到LCA的路径的，我们把两条路径合并到一颗主席树上，做树上二分即可。

接下来考虑如何处理边合并的问题。考虑启发式暴力合并。我们把小的那棵树合并到大的那棵树上，暴力重构小的那棵树的每个点的主席树，也暴力重构每个点的depth，fa来计算LCA即可。

启发式合并中，每个点的重构次数期望为$logn$次，因此，我们的总复杂度为$O(nlog^2n)$

就酱，这题我们就切掉啦(～￣▽￣)～

<hr />

<h1>Code</h1>

<strong>细节繁多，请各位dalao小心</strong>

<pre><code class="language-cpp ">//Luogu P3302 [SDOI2013]森林
//Mar,6th,2019
//主席树启发式合并维护动态树树链K大
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=80000+2000;
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    static const int M=400*N;
    int son[M][2],size[M],to;
    inline void update(int now)
    {
        size[now]+=size[son[now][0]]+size[son[now][1]];
    }
    inline void Add(int now,int pre,int x,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            size[now]=size[pre]+1;
            return;
        }
        if(x&lt;=mid) 
        {
            Add(son[now][0]=++to,son[pre][0],x,now_l,mid);
            son[now][1]=son[pre][1];
        }
        else
        {
            Add(son[now][1]=++to,son[pre][1],x,mid+1,now_r);
            son[now][0]=son[pre][0];
        }
        update(now);
    }
    int Query(int now1,int now2,int pre1,int pre2,int x,int now_l,int now_r)
    {
        if(now_l==now_r) return now_l;
        if(x&lt;=size[son[now1][0]]-size[son[pre1][0]]+size[son[now2][0]]-size[son[pre2][0]])
            return Query(son[now1][0],son[now2][0],son[pre1][0],son[pre2][0],x,now_l,mid);
        else
            return Query(son[now1][1],son[now2][1],son[pre1][1],son[pre2][1],x-(size[son[now1][0]]-size[son[pre1][0]]+size[son[now2][0]]-size[son[pre2][0]]),mid+1,now_r);
    }
    void Print(int now,int now_l,int now_r)
    {
        cerr&lt;&lt;"no."&lt;&lt;now&lt;&lt;" l&amp;r:"&lt;&lt;now_l&lt;&lt;" "&lt;&lt;now_r&lt;&lt;" sonl&amp;r:"&lt;&lt;son[now][0]&lt;&lt;" "&lt;&lt;son[now][1]&lt;&lt;" size:"&lt;&lt;size[now]&lt;&lt;endl;
        if(now_l!=now_r)
            Print(son[now][0],now_l,mid),
            Print(son[now][1],mid+1,now_r);
    }
    #undef mid
}sgt;
vector &lt;int&gt; e[N];
int n,m,q,w[N],mmap[N];//mmap:离散值-&gt;真实值
int fa[N][21],size[N],depth[N],root[N];
bool vis[N];
void dfs(int now)
{
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    vis[now]=true;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            depth[e[now][i]]=depth[now]+1;
            fa[e[now][i]][0]=now;
            root[e[now][i]]=++sgt.to;
            sgt.Add(root[e[now][i]],root[now],w[e[now][i]],1,m);
            //sgt.Print(root[e[now][i]],1,m);
            //cerr&lt;&lt;endl;
            dfs(e[now][i]);
        }
    vis[now]=false;
}
void Merge(int x,int y)
{
    if(size[fa[x][20]]&gt;size[fa[y][20]]) swap(x,y);
    size[fa[y][20]]+=size[fa[x][20]];
    depth[x]=depth[y]+1;
    fa[x][0]=y;
    root[x]=++sgt.to;
    sgt.Add(root[x],root[y],w[x],1,m);
    //sgt.Print(root[x],1,m);
    //cerr&lt;&lt;endl;
    dfs(x);
    e[x].push_back(y);
    e[y].push_back(x);
}
int LCA(int x,int y)
{
    if(depth[x]&lt;depth[y]) swap(x,y);
    for(int i=20;i&gt;=0;i--)
        if(depth[fa[x][i]]&gt;=depth[y])
            x=fa[x][i];
    if(x==y) return x;
    for(int i=20;i&gt;=0;i--)
        if(fa[x][i]!=fa[y][i])
            x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
int Query(int x,int y,int K)
{
    if(depth[x]&lt;depth[y]) swap(x,y);
    int lca=LCA(x,y);
    if(lca==y)
        return mmap[sgt.Query(root[x],0,(fa[lca][0]==lca?0:root[fa[lca][0]]),0,K,1,m)];
    else
        return mmap[sgt.Query(root[x],root[y],root[lca],(fa[lca][0]==lca?0:root[fa[lca][0]]),K,1,m)];
}
void Init()
{
    for(int i=0;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;=n;i++)
    {
        root[i]=++sgt.to;
        sgt.Add(root[i],0,w[i],1,m);
    }
    for(int i=1;i&lt;=n;i++)
        size[i]=1,depth[i]=1;
    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;=21;j++)
            fa[i][j]=i;
}
int m2;
int main()
{
    static int tmp[N];
    n=read(),n=read(),m2=read(),q=read();
    for(int i=1;i&lt;=n;i++)
        tmp[i]=w[i]=read();

    sort(tmp+1,tmp+1+n);
    m=unique(tmp+1,tmp+1+n)-tmp-1;
    for(int i=1;i&lt;=n;i++)
    {
        int temp=lower_bound(tmp+1,tmp+1+m,w[i])-tmp;
        mmap[temp]=w[i];
        w[i]=temp;
    }
    Init();

    for(int i=1;i&lt;=m2;i++)
    {
        int x=read(),y=read();
        Merge(x,y);
    }

    int ans=0;
    char OP[5];
    for(int i=1;i&lt;=q;i++)
    {
        scanf("%s",OP+1);
        if(OP[1]=='Q')
        {
            int x=read()^ans,y=read()^ans,K=read()^ans;
            printf("%d\n",ans=Query(x,y,K));
        }
        else
        {
            int x=read()^ans,y=read()^ans;
            Merge(x,y);
        }
        //ans=0;
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>340</wp:post_id>
		<wp:post_date><![CDATA[2019-03-07 03:34:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-07 03:34:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3302-sdoi2013%e6%a3%ae%e6%9e%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[362]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4197] Peaks</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p4197-peaks/</link>
		<pubDate>Thu, 07 Mar 2019 03:43:01 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=341</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4197">洛谷P4197</a>

<hr />

<h1>Solution</h1>

这题的确是可以用库鲁斯卡尔重构树+主席树来搞，<del>但是本蒟蒻太菜了并不会</del>，因此只能给大家讲讲离线+splay启发式合并的搞法。

首先，我们考虑把询问离线下来并按限制从小到大排序。然后我们可以考虑把边一条一条插入到图里面去，直到某个询问的限制。这样子，问题就变为了询问某一个连通块的K小值，连通块可以合并。

这个问题就肥肠简单了，我们可以用各种各样的数据结构来处理，线段树合并，splay启发式合并都可以。

考虑到每个点期望加入$logn$次，时间复杂度为$O(nlogn)$

<hr />

<h1>Code</h1>

<strong>我这题因为TLE调了很久，原因是我在查询的时候没有splay，导致势能分析失效，请各位读者引以为戒</strong>

<pre><code class="language-cpp ">//Luogu P4197 Peaks
//Mar,7th,2019
//splay启发式合并
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int M=50*N;
struct SPLAY
{
    #define root son[r][1]
    int son[M][2],size[M],cnt[M],fa[M],w[M],to,toUse[M],top;
    inline void update(int x)
    {
        size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x];
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        fa[x]=z,son[z][y==son[z][1]]=x;
        fa[son[x][type]]=y,son[y][!type]=son[x][type];
        fa[y]=x,son[x][type]=y;
        update(y),update(x);
    }
    void splay(int x,int to)
    {
        while(fa[x]!=to)
        {
            if(fa[fa[x]]!=to and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])
                rotate(fa[x],x==son[fa[x]][0]),
                rotate(x,x==son[fa[x]][0]);
            else
                rotate(x,x==son[fa[x]][0]);
        }
    }
    int newNode()
    {
        if(top!=0)
        {
            son[toUse[top]][0]=son[toUse[top]][1]=0;
            size[toUse[top]]=fa[toUse[top]]=cnt[toUse[top]]=w[toUse[top]]=0;
            return toUse[top--];
        }
        return ++to;
    }
    void Insert(int num,int r)
    {
        if(root==0)
        {
            root=newNode(),fa[root]=r;
            w[root]=num,cnt[root]=1;
            update(root);
            return;
        }
        int now=root,last=r;
        while(now!=0)
        {
            if(w[now]==num)
            {
                cnt[now]++,update(now);
                splay(now,r);
                return;
            }
            last=now,now=son[now][num&gt;w[now]];
        }
        now=newNode();
        fa[now]=last,son[last][num&gt;w[last]]=now;
        w[now]=num,cnt[now]=1,update(now);
        splay(now,r);
    }
    int Query(int now,int r,int K)
    {
        if(size[son[now][1]]&gt;=K)
            return Query(son[now][1],r,K);
        K-=(cnt[now]+size[son[now][1]]);
        if(K&lt;=0)
        {
            splay(now,r);
            return w[now]; 
        }
        return Query(son[now][0],r,K);
    }
    void dfs(int now,int r)
    {
        if(now==0) return;
        for(int i=1;i&lt;=cnt[now];i++)//有可能一个点上有多个数字
            Insert(w[now],r);
        dfs(son[now][0],r);
        dfs(son[now][1],r);
        toUse[++top]=now;
    }
    #undef root
}splay;
int fa[N],size[N],root[N];
int FindFather(int x)
{
    if(fa[x]==0) return x;
    return fa[x]=FindFather(fa[x]);
}
void Merge(int x,int y)
{
    if(FindFather(x)==FindFather(y)) return;
    if(size[FindFather(x)]&gt;size[FindFather(y)]) swap(x,y);
    splay.dfs(splay.son[root[FindFather(x)]][1],root[FindFather(y)]);
    //cerr&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;" "&lt;&lt;size[FindFather(x)]&lt;&lt;" "&lt;&lt;size[FindFather(y)]&lt;&lt;" "&lt;&lt;splay.size[splay.son[root[FindFather(y)]][1]]&lt;&lt;endl;
    size[FindFather(y)]+=size[FindFather(x)];
    fa[FindFather(x)]=FindFather(y);
}
struct edge
{
    int s,t,w;
    friend bool operator &lt; (edge x,edge y)
    {
        return x.w&lt;y.w;
    }
}e[M];
struct Query
{
    int x,K,w,ans,no;
    friend bool operator &lt; (Query a,Query b)
    {
        return a.w&lt;b.w;
    }
}query[M];
bool cmp(Query a,Query b)
{
    return a.no&lt;b.no;
}
int Ask(int x,int K)
{
    if(size[FindFather(x)]&lt;K) return -1;
    return splay.Query(splay.son[root[FindFather(x)]][1],root[FindFather(x)],K);
}
int n,m,q,h[N];
int main()
{
    int t=clock();
    freopen("4197.in","r",stdin);
    freopen("4197.out","w",stdout);

    n=read(),m=read(),q=read();
    for(int i=1;i&lt;=n;i++)
        h[i]=read();

    for(int i=1;i&lt;=n;i++)
        root[i]=splay.newNode(),size[i]=1;
    for(int i=1;i&lt;=n;i++)
        splay.Insert(h[i],root[i]);
    for(int i=1;i&lt;=m;i++)
        e[i].s=read(),e[i].t=read(),e[i].w=read();
    for(int i=1;i&lt;=q;i++)
        query[i].x=read(),query[i].w=read(),query[i].K=read(),query[i].no=i;

    sort(e+1,e+1+m);
    sort(query+1,query+1+q);

    int w_to=1;
    for(int i=1;i&lt;=q;i++)
    {
        //cerr&lt;&lt;i&lt;&lt;endl;
        for(;e[w_to].w&lt;=query[i].w and w_to&lt;=m;w_to++)
            Merge(e[w_to].s,e[w_to].t);
        query[i].ans=Ask(query[i].x,query[i].K);
    }

    sort(query+1,query+1+q,cmp);
    for(int i=1;i&lt;=q;i++)
        printf("%d\n",query[i].ans);
    cerr&lt;&lt;clock()-t&lt;&lt;endl;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>341</wp:post_id>
		<wp:post_date><![CDATA[2019-03-07 03:43:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-07 03:43:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4197-peaks]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="splay"><![CDATA[splay]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[430]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3567] [POI2014]KUR-Couriers</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3567-poi2014kur-couriers/</link>
		<pubDate>Thu, 07 Mar 2019 03:50:57 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=343</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3567">洛谷P3567</a>

<hr />

<h1>Solution</h1>

<del>大水题啊，真没什么好讲的</del>

我们考虑建一颗权值主席树，从左往右逐个插入。因为个数满足可减性，因此我们可以很方便的“扣”出$[L,R]$区间构成的主席树。接下来只需要在树上二分看一下有没有出现次数超过$K$的即可。

时间复杂度$O(nlogn)$
就酱，这题就被我们切掉啦︿(￣︶￣)︿

<hr />

<h1>Solution</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=500000+100;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    static const int M=25*N;
    int size[M],son[M][2],to;
    inline void update(int now)
    {
        size[now]=size[son[now][0]]+size[son[now][1]];
    }
    void Add(int now,int pre,int x,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            size[now]=size[pre]+1;
            return;
        }
        if(x&lt;=mid)
        {
            son[now][1]=son[pre][1];
            Add(son[now][0]=++to,son[pre][0],x,now_l,mid);
        }
        else
        {
            son[now][0]=son[pre][0];
            Add(son[now][1]=++to,son[pre][1],x,mid+1,now_r);
        }
        update(now);
    }
    int Query(int now,int pre,int x,int now_l,int now_r)
    {
        if(now_l==now_r)
            return now_l;
        if(size[son[now][0]]-size[son[pre][0]]&gt;=x)
            return Query(son[now][0],son[pre][0],x,now_l,mid);
        else if(size[son[now][1]]-size[son[pre][1]]&gt;=x)
            return Query(son[now][1],son[pre][1],x,mid+1,now_r);
        return 0;
    }
    #undef mid
}sgt;
int root[N],n,m;
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
    {
        int tmp=read();
        sgt.Add(root[i]=++sgt.to,root[i-1],tmp,1,n);
    }

    for(int i=1;i&lt;=m;i++)
    {
        int l=read(),r=read(),mid=(r-l+1)/2+1;
        printf("%d\n",sgt.Query(root[r],root[l-1],mid,1,n));
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>343</wp:post_id>
		<wp:post_date><![CDATA[2019-03-07 03:50:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-07 03:50:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3567-poi2014kur-couriers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[395]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Kruskal重构树学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/kruskal%e9%87%8d%e6%9e%84%e6%a0%91%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Thu, 07 Mar 2019 09:43:16 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=344</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>为什么要学Kruskal重构树</h1>

有时候，题目让我们多次求一个图的两点路径上最小值最大/最大值最小是多少。这种时候，根据一个比较显然的结论，我们可以把问题搬到一颗最小/最大生成树里面去做。

这个时候，我们当然可以倍增来搞这个问题。但在这里，我想向大家引入一种新的数据结构，它是基于kruskal求生成树的算法改来的，因此被称为Kruskal重构树。

<hr />

<h1>什么是Kruskal重构树</h1>

这张图可以一目了然的介绍Kruskal重构树：
图出自<a href="https://blog.csdn.net/wu_tongtong/article/details/77601523">https://blog.csdn.net/wu_tongtong/article/details/77601523</a>
<a href="https://imgchr.com/i/kxUrsx"><img src="https://s2.ax1x.com/2019/03/07/kxUrsx.md.png" alt="kxUrsx.md.png" /></a>

<hr />

<h1>怎么建Kruskal重构树</h1>

肥肠简单，我们在做Krusckal算法的时候，当我们要连边的时候，我们把这两个点连向一个新构建的点(在图中以方点表示)，然后把这两个点的fa设为那个方点，方点的权值为这条边的权值，继续做Kruskal即可。

代码可能更优表现力：

<pre><code class="language-cpp ">bool cmp(edge x,edge y)
{
    return x.w&lt;y.w;
}
int fa[N],w[N],to;
int FindFather(int x)
{
    if(fa[x]==0) return x;
    return fa[x]=FindFather(fa[x]);
}
vector &lt;int&gt; e2[N];
void Kruskal()
{
    sort(e+1,e+1+m,cmp);
    to=n;
    for(int i=n+1;i&lt;=2*n;i++)
        e2[i].reserve(4);
    for(int i=1;i&lt;=m;i++)
    {
        int fa1=FindFather(e[i].s),fa2=FindFather(e[i].t);
        if(fa1==fa2) continue;
        w[++to]=e[i].w,fa[fa1]=to,fa[fa2]=to;
        e2[to].push_back(fa1),e2[to].push_back(fa2);
    }
}
</code></pre>

<hr />

<h1>Kruskal重构树有什么性质</h1>

<ol>
<li><strong>两个点在原图中的所有路径上某条路径中的最小值最大/最大值最小即为他们在Kruskal重构树上这两个点的LCA的权值</strong></li>
<li>这是一个<strong>二叉树</strong></li>
<li>树上权值满足<strong>堆</strong>的性质 (从我们构建过程中可以很简单的证明)</li>
</ol>

<hr />

<h1>Kruskal重构树相关题目</h1>

1.<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3732">BZOJ 3732</a> 真*模板题
2.<a href="https://www.luogu.org/problemnew/show/P4768">NOI2018 归程</a> 相关性质的简单应用

<hr />

注：肥肠感谢julao lbc的教学]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>344</wp:post_id>
		<wp:post_date><![CDATA[2019-03-07 09:43:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-07 09:43:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[kruskal%e9%87%8d%e6%9e%84%e6%a0%91%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kruskal%e9%87%8d%e6%9e%84%e6%a0%91"><![CDATA[Kruskal重构树]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[308]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[447]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4768] [NOI2018]归程</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p4768-noi2018%e5%bd%92%e7%a8%8b/</link>
		<pubDate>Thu, 07 Mar 2019 09:55:50 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=345</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4768">[Luogu P4768] [NOI2018]归程</a>

<hr />

<h1>Solution</h1>

这题可能要用到Kruskal重构树的相关知识，如果有需求的同学可以<a href="https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kruskal%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">看这里</a>

首先，根据我们之前在运输计划那道题的经验，我们会发现我们开车能经过的边一定在<strong>以海拔为关键字的最大生成树上</strong>。

根据Kruskal重构树的性质：<strong>Kruskal重构树是一个堆</strong>，我们可以考虑这样做：
我们先把Kruskal重构树按每条路的海拔从大到小建出来，那么<strong>从某个点出发能开车到达的点一定是这个点的某个祖先的子树内的所有的点</strong>，这个很好理解，因为Kruskal重构树是一个堆，那么堆之内的点的路一定>堆顶，堆外的点一定&lt;=堆顶

所以说，我们只需要先把每个点到<strong>1号节点的最短路</strong>先求出来，每次我们<strong>从出发点向上倍增</strong>，找到刚好>积水线的点，然后找到这个点的子树内距离1最短的点即可，这个用简单的树形DP即可完成。

时间复杂度$O(mlogn)$
就酱，这题就被我们切掉啦~(*´ﾟ∀ﾟ｀)ﾉ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2*200000+2000;
const int M=400000+1000;
struct EDGE
{
    int s,to,l,h;
}e1[M];
vector &lt;EDGE&gt; e2[N];//e2需要初始化
int n,m;
long long dis[N];
struct SIT
{
    int to;
    long long w;
    SIT (int x,long long y)
    {
        to=x,w=y;
    }
    friend bool operator &lt; (SIT x,SIT y)
    {
        return x.w&gt;y.w;
    }
};
priority_queue &lt;SIT&gt; mqueue;
void dj()
{
    static bool vis[N];
    memset(vis,0,sizeof vis);
    memset(dis,0x3f,sizeof dis);
    dis[1]=0,mqueue.push(SIT(1,0));
    while(mqueue.empty()==false)
    {
        int now=mqueue.top().to;
        mqueue.pop();
        if(vis[now]==true) continue;
        vis[now]=true;
        for(int i=0;i&lt;int(e2[now].size());i++)
            if(dis[e2[now][i].to] &gt; dis[now]+e2[now][i].l)
            {
                dis[e2[now][i].to]=dis[now]+e2[now][i].l;
                mqueue.push(SIT(e2[now][i].to,dis[e2[now][i].to]));
            }
    }
}
int fa[N][21],depth[N],cnt;//fa需要初始化
vector &lt;int&gt; e3[N];//e3需要初始化
int MIN[N],sl[N];//存放距离最小值位置
bool cmp(EDGE x,EDGE y)
{
    return x.h&gt;y.h;
}
int FindFather(int x)
{
    if(fa[x][0]==0) return x;
    return fa[x][0]=FindFather(fa[x][0]);
}
void Kruskal()
{
    for(int i=1;i&lt;=n;i++)
        MIN[i]=i;
    sort(e1+1,e1+1+m,cmp);
    cnt=n;
    for(int i=1;i&lt;=m;i++)
    {
        int fa1=FindFather(e1[i].s),fa2=FindFather(e1[i].to);
        if(fa1==fa2) continue;
        fa[fa1][0]=fa[fa2][0]=++cnt;
        sl[cnt]=e1[i].h,MIN[cnt]=cnt;
        e3[cnt].push_back(fa1),e3[cnt].push_back(fa2);
    }
    fa[cnt][0]=cnt;
}
void dfs(int now)
{
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i&lt;int(e3[now].size());i++)
    {
        depth[e3[now][i]]=depth[now]+1;
        fa[e3[now][i]][0]=now;
        dfs(e3[now][i]);
        if(dis[MIN[e3[now][i]]]&lt;dis[MIN[now]])
            MIN[now]=MIN[e3[now][i]];
    }
}
int Query(int x,int h)
{
    for(int i=20;i&gt;=0;i--)
        if(sl[fa[x][i]]&gt;h)
            x=fa[x][i];
    return dis[MIN[x]];
}
int main()
{
    int T=read();
    for(;T&gt;0;T--)
    {
        n=read(),m=read();

        for(int i=0;i&lt;=2*n+10;i++)
            e2[i].clear(),e2[i].reserve(4);
        memset(fa,0,sizeof fa);
        for(int i=0;i&lt;=2*n+10;i++)
            e3[i].clear(),e3[i].reserve(4);

        for(int i=1;i&lt;=m;i++)
        {
            e1[i].s=read(),e1[i].to=read(),e1[i].l=read(),e1[i].h=read();
            e2[e1[i].s].push_back(e1[i]);
            swap(e1[i].s,e1[i].to);
            e2[e1[i].s].push_back(e1[i]);
        }

        dj();
        Kruskal();
        dfs(cnt);

        long long ans=0,q=read(),K=read(),S=read();
        for(int i=1;i&lt;=q;i++)
        {
            long long v=read(),p=read();
            v=(v+K*ans-1)%n+1,p=(p+K*ans)%(S+1);
            printf("%lld\n",ans=Query(v,p));
        }
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>345</wp:post_id>
		<wp:post_date><![CDATA[2019-03-07 09:55:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-07 09:55:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4768-noi2018%e5%bd%92%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kruskal%e9%87%8d%e6%9e%84%e6%a0%91"><![CDATA[Kruskal重构树]]></category>
		<category domain="category" nicename="%e5%80%8d%e5%a2%9e"><![CDATA[倍增]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[365]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1110] [ZJOI2007]报表统计</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p1110-zjoi2007%e6%8a%a5%e8%a1%a8%e7%bb%9f%e8%ae%a1/</link>
		<pubDate>Fri, 08 Mar 2019 04:08:55 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=346</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P1110">洛谷P1110</a>

<hr />

<h1>Solution</h1>

我们看到这道题，我们不妨想<strong>把处于同一个点的骑士全部丢到一个小根堆左偏树里面</strong>。这样子，我们<strong>从下往上合并，合并完就去检查一下根是否满足当前城市的要求，一直弹根弹到满足要求为止</strong>。

至于能力的变化，这里的操作要求无外乎乘法和加法。因此，我们可以像线段树II那道题那样做两个标记，处理一下即可。每次合并、弹根之前都pushdown标记。

就酱，这题就被我们切掉啦~(*´ﾟ∀ﾟ｀)ﾉ 
时间复杂度$O(nlogm)$

<hr />

<h1>Code</h1>

<h3>数据生成器</h3>

<pre><code class="language-cpp ">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
const int N=10;
const int MAX=10;
using namespace std;
int mrand()
{
    int x=rand()%MAX,f=rand()%2;
    if(f==0) f=-1;
    return x*f;
}
int main()
{
    srand(time(NULL));
    freopen("3261.in","w",stdout);

    int n=N,m=N;
    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++)
        cout&lt;&lt;mrand()&lt;&lt;" ";
    cout&lt;&lt;endl;

    for(int i=2;i&lt;=n;i++)
    {
        int to=rand()%i;
        if(to==0) to=1;
        cout&lt;&lt;to&lt;&lt;" "&lt;&lt;rand()%2&lt;&lt;" "&lt;&lt;mrand()&lt;&lt;endl;
    }

    for(int i=1;i&lt;=m;i++)
        cout&lt;&lt;mrand()&lt;&lt;" "&lt;&lt;rand()%n+1&lt;&lt;endl;
    return 0;
}

</code></pre>

<h3>正解</h3>

<del>我因为用了vector存边常数爆大，不吸氧会T一个点</del>

<pre><code class="language-cpp ">//Luogu P3261 [JLOI2015]城池攻占
//Mar,8th,2019
//左偏树+线段树II
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=300000+1000;
struct LST
{
    long long plus[N],take[N],w[N],son[N][2],dis[N],fa[N];
    inline void pushdown(int x)//传入位置
    {
        if(son[x][0]!=0)
        {
            w[son[x][0]]=w[son[x][0]]*take[x]+plus[x];
            take[son[x][0]]*=take[x];
            plus[son[x][0]]=plus[son[x][0]]*take[x]+plus[x];
        }
        if(son[x][1]!=0)
        {
            w[son[x][1]]=w[son[x][1]]*take[x]+plus[x];
            take[son[x][1]]*=take[x];
            plus[son[x][1]]=plus[son[x][1]]*take[x]+plus[x];
        }
        plus[x]=0,take[x]=1;
    }
    int findFather(int x)//传入位置
    {
        if(fa[x]==0) return x;
        return fa[x]=findFather(fa[x]);
    }
    int Merge(int x,int y)//传入根的位置
    {
        if(x==0 or y==0) return x+y;
        if(w[x]&lt;w[y]) swap(x,y);
        pushdown(x),pushdown(y);
        son[y][1]=Merge(x,son[y][1]),fa[son[y][1]]=y;
        if(dis[son[y][0]]&lt;dis[son[y][1]]) 
            swap(son[y][0],son[y][1]);
        dis[y]=dis[son[y][1]]+1;    
        return y;
    }
    int Pop(int x)//返回新的根的位置
    {
        pushdown(x);
        fa[x]=Merge(son[x][0],son[x][1]);
        return fa[x];
    }
    void Mark(int x,long long ntake,long long nplus)
    {
        pushdown(x);
        w[x]=w[x]*ntake+nplus;
        take[x]=ntake,plus[x]=nplus;
    }
}lst;
int n,m,root[N],ans1[N],ans2[N];
long long a[N],v[N],h[N];
vector &lt;int&gt; e[N];
int depth[N],from[N];
void dfs(int now)
{
    for(int i=0;i&lt;int(e[now].size());i++)
    {
        depth[e[now][i]]=depth[now]+1;
        dfs(e[now][i]);
        if(root[e[now][i]]!=0)
            root[now]=lst.Merge(root[now],root[e[now][i]]);
    }
    while(root[now]!=0 and lst.w[root[now]]&lt;h[now])
    {
        ans1[now]++,ans2[root[now]]=depth[from[root[now]]]-depth[now];
        root[now]=lst.Pop(root[now]);
    }
    if(v[now]==0)
        lst.Mark(root[now],1,a[now]);
    else
        lst.Mark(root[now],a[now],0);
}
int main()
{
    int t=clock();
    freopen("3261.in","r",stdin);
    freopen("3261.out","w",stdout);

    int size = 256 &lt;&lt; 20;
    char *p = (char*)malloc(size) + size;
    __asm__("movl %0, %%esp\n" :: "r"(p));

    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        h[i]=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=2;i&lt;=n;i++)
    {
        e[read()].push_back(i);
        v[i]=read(),a[i]=read();
    }
    for(int i=1;i&lt;=m;i++)
    {
        long long w=read();
        from[i]=read();
        lst.w[i]=w;
        if(root[from[i]]==0)
            root[from[i]]=i;
        else
            root[from[i]]=lst.Merge(root[from[i]],i);
    }

    depth[1]=1;
    dfs(1);
    while(root[1]!=0)
    {
        ans2[root[1]]=depth[from[root[1]]];
        root[1]=lst.Pop(root[1]);
    }

    for(int i=1;i&lt;=n;i++)
        printf("%d\n",ans1[i]);
    for(int i=1;i&lt;=m;i++)
        printf("%d\n",ans2[i]);
    cerr&lt;&lt;clock()-t;
    return 0;
}


</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>346</wp:post_id>
		<wp:post_date><![CDATA[2019-03-08 04:08:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-08 04:08:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1110-zjoi2007%e6%8a%a5%e8%a1%a8%e7%bb%9f%e8%ae%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[352]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1501] [国家集训队]Tree II</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p1501-%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9ftree-ii/</link>
		<pubDate>Mon, 11 Mar 2019 04:18:23 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=347</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P1501">洛谷 P1501</a>

<hr />

<h1>Solution</h1>

这是一道肥肠考验LCT基本功的一道题。

口胡起来是很容易的：<strong>对于每一个加/乘操作，我们把对应的链split出来，然后打标记即可；Link/Cut是基本操作；查询的话我们也是把对应的链split出来，然后直接输出根的sum即可</strong>。
这里的打标记和线段树II那道题非常像，<del>不会的同学可以先去做线段树II</del>。 <del>都在写LCT了，怎么可能没打过线段树II</del>。我们只需要像线段树II那样pushdown并处理sum即可。

<strong>口胡是口胡，打起来就是另外一码事了</strong>
这里列出我写出的锅，大家写的时候可以考虑注意以下几点：
1. $(5w*5w)$会爆int的，请开longlong 。
2. 我们在$pushdown$算各种标记、sum的时候一定要注意膜$p$，小心爆longlong。
3. LCT的rotate和正常的splay的rotate不一样，我们要特判一下z是否是另外一颗splay的，不能直接无脑rotate。<del>当然，这种锅也只有我这种蒟蒻才会错</del>
4. 先cut再link，避免连出环来。
5. <del>没了</del>

<hr />

<h1>Code</h1>

<h3>数据生成器</h3>

<strong>不包含link,cut操作</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int N=10;
const int MAX=50000;
int main()
{
    srand(time(NULL));
    freopen("1501.in","w",stdout);

    int n=N,m=10*N;
    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
    for(int i=2;i&lt;=n;i++)
    {
        int to=rand()%i;
        if(to==0) to=1;
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;to&lt;&lt;endl;
    }

    for(int i=1;i&lt;=m;i++)
    {
        int op=rand()%3;
        if(op==0)
            cout&lt;&lt;"+ "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%MAX+1&lt;&lt;endl;
        else if(op==1)
            cout&lt;&lt;"* "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%MAX+1&lt;&lt;endl;
        else
            cout&lt;&lt;"/ "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%n+1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>

<h3>正解</h3>

<pre><code class="language-cpp line-numbers">//Luogu P1501 [国家集训队]Tree II 
//Mar,10th,2019
//LCT+线段树II
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
using namespace std;
const int N=100000+1000;
const long long poi=51061;
struct LCT
{
    long long son[N][2],fa[N],w[N],sum[N],plus[N],take[N],lazy[N],size[N];
    inline void Mirror(int x)
    {
        lazy[x]=!lazy[x];
        swap(son[x][0],son[x][1]);
    }
    inline void pushdown(int x)
    {
        if(lazy[x]==true)
        {
            Mirror(son[x][0]);
            Mirror(son[x][1]);
            lazy[x]=false;
        }
        if(son[x][0]!=0)
        {
            w[son[x][0]]=(w[son[x][0]]*take[x]+plus[x])%poi;
            take[son[x][0]]=take[son[x][0]]*take[x]%poi;
            plus[son[x][0]]=(plus[son[x][0]]*take[x]+plus[x])%poi;
            sum[son[x][0]]=(sum[son[x][0]]*take[x]+size[son[x][0]]*plus[x])%poi;
        }
        if(son[x][1]!=0)
        {
            w[son[x][1]]=(w[son[x][1]]*take[x]+plus[x])%poi;
            take[son[x][1]]=(take[son[x][1]]*take[x])%poi;
            plus[son[x][1]]=(plus[son[x][1]]*take[x]+plus[x])%poi;
            sum[son[x][1]]=(sum[son[x][1]]*take[x]+size[son[x][1]]*plus[x])%poi;
        }
        plus[x]=0,take[x]=1;
    }
    inline void update(int x)
    {
        size[0]=sum[0]=0;
        sum[x]=(sum[son[x][0]]+sum[son[x][1]]+w[x])%poi;
        size[x]=(size[son[x][0]]+size[son[x][1]]+1);
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        fa[x]=z;
        if(IsRoot(y)==false)
            son[z][y==son[z][1]]=x;
        fa[son[x][type]]=y,son[y][!type]=son[x][type];
        fa[y]=x,son[x][type]=y;
        update(y),update(x);
    }
    bool IsRoot(int x)
    {
        return (x!=son[fa[x]][0] and x!=son[fa[x]][1]);
    }
    int mstack[N],top;
    void splay(int x)
    {
        mstack[top=1]=x;
        for(int now=x;IsRoot(now)==false;now=fa[now])
            mstack[++top]=fa[now];
        for(;top&gt;0;top--)
            pushdown(mstack[top]);
        while(IsRoot(x)==false)
        {
            if(IsRoot(fa[x])==false and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])
                rotate(fa[x],x==son[fa[x]][0]),
                rotate(x,x==son[fa[x]][0]);
            else
                rotate(x,x==son[fa[x]][0]);
        }
    }
    void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            splay(x),son[x][1]=t,fa[t]=x,update(x);
    }
    int GetRoot(int x)
    {
        Access(x),splay(x);
        while(son[x][0]!=0)
            pushdown(x),x=son[x][0];
        splay(x);
        return x;
    }
    void MakeRoot(int x)
    {
        Access(x);
        splay(x);
        Mirror(x);
    }
    void Link(int x,int y)
    {
        if(GetRoot(x)==GetRoot(y)) return;
        MakeRoot(x);
        fa[x]=y;
    }
    void Split(int x,int y)
    {
        MakeRoot(y);
        Access(x),splay(x);
    }
    void Cut(int x,int y)
    {
        Split(x,y);
        if(y!=son[x][0] or fa[y]!=x) return;
        son[x][0]=0,fa[y]=0;
        update(x);
    }
    void Add(int x,int y,long long num)
    {
        Split(x,y);
        plus[x]=num%poi,w[x]=(w[x]+num)%poi,sum[x]=(sum[x]+size[x]*num)%poi;
    }
    void Take(int x,int y,long long num)
    {
        Split(x,y);
        take[x]=num%poi,w[x]=(w[x]*num)%poi,sum[x]=sum[x]*num%poi;
    }
    long long Query(int x,int y)
    {
        Split(x,y);
        return sum[x]%poi;
    }
}lct;
int n,q;
int main()
{
    n=read(),q=read();
    for(int i=1;i&lt;=n;i++)
        lct.take[i]=lct.w[i]=lct.sum[i]=lct.size[i]=1;
    for(int i=1;i&lt;n;i++)
    {
        int s=read(),t=read();
        lct.Link(s,t);
    }

    char OP[5];
    for(int i=1;i&lt;=q;i++)
    {
        scanf("%s",OP+1);
        if(OP[1]=='+')
        {
            long long u=read(),v=read(),x=read()%poi;
            lct.Add(u,v,x);
        }
        else if(OP[1]=='-')
        {
            long long u1=read(),v1=read(),u2=read(),v2=read();
            lct.Cut(u1,v1);
            lct.Link(u2,v2);
        }
        else if(OP[1]=='*')
        {
            long long u=read(),v=read(),x=read()%poi;
            lct.Take(u,v,x);
        }
        else
        {
            long long u=read(),v=read();
            printf("%lld\n",lct.Query(u,v));
        }
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>347</wp:post_id>
		<wp:post_date><![CDATA[2019-03-11 04:18:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-11 04:18:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1501-%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9ftree-ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[352]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3174] [HAOI2009]毛毛虫</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p3174-haoi2009%e6%af%9b%e6%af%9b%e8%99%ab/</link>
		<pubDate>Mon, 11 Mar 2019 06:47:01 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=348</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3174">洛谷P3174</a>

<hr />

<h1>Solution</h1>

我们不难发现，一条“毛毛虫”一定是由一条主链外加主链的点所连到的点构成的。
那既然是一条链，它的形态无外乎以下两种：
<img src="https://s2.ax1x.com/2019/03/11/ACQopn.png" alt="ACQopn.png" />
因此，我们可以<strong>直接枚举最上面的那个点，他做为根会产生的最大的答案即为其孩子的最大答案与次大答案之和再减去多算的一小部分即可</strong>。(具体转移可以看看代码，要做点简单的分类讨论)

时间复杂度$O(n)$
就酱，这题我们就切掉啦(*´ﾟ∀ﾟ｀)ﾉ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P3174 [HAOI2009]毛毛虫
//Mar,10th,2019
//树形DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=300000+100;
vector &lt;int&gt; e[N];
int n,m;
bool vis[N];
int f1[N],f2[N],ans;
void dfs(int now)
{
    vis[now]=true;
    f1[now]=e[now].size()+1;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            dfs(e[now][i]);
            if(f1[e[now][i]]+int(e[now].size())-1 &gt;= f1[now])
            {
                f2[now]=f1[now];
                f1[now]=f1[e[now][i]]+e[now].size()-1;
            }
            else if(f1[e[now][i]]+int(e[now].size())-1 &gt; f2[now])
                f2[now]=f1[e[now][i]]+e[now].size()-1;
        }

    if(f2[now]==0)
        ans=max(ans,f1[now]);
    else
        ans=max(ans,f1[now]+f2[now]-int(e[now].size())-1);
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    dfs(1);

    printf("%d",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>348</wp:post_id>
		<wp:post_date><![CDATA[2019-03-11 06:47:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-11 06:47:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3174-haoi2009%e6%af%9b%e6%af%9b%e8%99%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%95%b0%e4%bd%8ddp"><![CDATA[数位DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[330]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[558]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu  P3285][SCOI2014]方伯伯的OJ</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3285scoi2014%e6%96%b9%e4%bc%af%e4%bc%af%e7%9a%84oj/</link>
		<pubDate>Mon, 11 Mar 2019 06:59:29 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=349</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3285">洛谷P3285</a>

<hr />

<h1>Solution</h1>

这是一道数据结构大暴力题。

我们可以很显然的发现对于询问排名，<strong>维护排名的操作，我们可以直接上一个维护下标的splay</strong>。
因为点的数量奇多，这让我们回想起NOIP2017 列队，<strong>我们可以用“splay 动态开点”这样的操作来解决</strong>，即一开始我们把所有信息全部压到一个点里面去（即一个点代表一段区间），需要的时候再用“拆点”把点拆开。

问题是这破题很让人讨厌地出了两个基于编号的操作。因为我们的splay是以下标做为权值来的，失去了维护编号的能力。
怎么办呢？我们可以考虑直接记录每个编号的点在splay中的下标。很不幸的是，这里的点的编号十分巨大，没法直接开桶来存。
但是，因为我们splay维护的是一个一个区间，我们可以考虑<strong>开一颗动态开点的线段树，然后在拆点/改编号的时候暴力区间维护一下即可。</strong>

时间复杂度$O(mlogn)$
就酱，这题我们就切掉啦٩(๑>◡&lt;๑)۶

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P3285 [SCOI2014]方伯伯的OJ
//Mar,11th,2019
//动态开点splay+动态开点线段树鬼畜题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000*2+100;
const int M=200000000;
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    int son[N*20][2],w[N*20],to;
    void Change(int l,int r,int num,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            w[now]=num;
            return;
        }
        if(l&lt;=mid)
        {
            if(son[now][0]==0) son[now][0]=++to,w[to]=w[now];
            Change(l,r,num,son[now][0],now_l,mid);
        }
        if(r&gt;mid)
        {
            if(son[now][1]==0) son[now][1]=++to,w[to]=w[now];
            Change(l,r,num,son[now][1],mid+1,now_r);
        }
    }
    int Query(int x,int now,int now_l,int now_r)
    {
        if(now_l==now_r) return w[now];
        if(x&lt;=mid)
        {
            if(son[now][0]==0) return w[now];
            else return Query(x,son[now][0],now_l,mid);
        }
        else
        {
            if(son[now][1]==0) return w[now];
            else return Query(x,son[now][1],mid+1,now_r);
        }
    }
    #undef mid
}sgt;//编号-&gt;下标
struct SPLAY
{
    #define root son[0][1]
    int son[N][2],fa[N],cnt[N],no[N],size[N],to;
    inline void update(int x)
    {
        size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x];
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        fa[x]=z,son[z][y==son[z][1]]=x;
        fa[son[x][type]]=y,son[y][!type]=son[x][type];
        fa[y]=x,son[x][type]=y;
        update(y),update(x);
    }
    void splay(int x,int to)
    {
        while(fa[x]!=to)
        {
            if(fa[fa[x]]!=to and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])
                rotate(fa[x],x==son[fa[x]][0]);
            rotate(x,x==son[fa[x]][0]);
        }
    }
    void split(int x,int K)//传入下标
    {
        splay(x,0);
        int t1=son[x][0],t2=son[x][1];
        while(son[t1][1]!=0) t1=son[t1][1];
        while(son[t2][0]!=0) t2=son[t2][0];
        splay(t1,0);
        splay(t2,root);

        if(K!=1)
        {
            son[x][0]=++to,fa[to]=x;
            no[to]=no[x],size[to]=cnt[to]=K-1;
            sgt.Change(no[to],no[to]+cnt[to]-1,to,1,1,M);
        }
        if(K!=cnt[x])
        {
            son[x][1]=++to,fa[to]=x;
            no[to]=no[x]+K,size[to]=cnt[to]=cnt[x]-K;
            sgt.Change(no[to],no[to]+cnt[to]-1,to,1,1,M);
        }
        no[x]=no[x]+K-1,cnt[x]=1;
    }
    int GetKth(int x,int K)//返回下标
    {
        if(size[son[x][0]]&gt;=K) 
            return GetKth(son[x][0],K);
        K-=size[son[x][0]];
        if(K&lt;=cnt[x])
        {
            if(cnt[x]==1)
            {
                splay(x,0);
                return x;
            }
            split(x,K);
            splay(x,0);
            return x;
        }
        K-=cnt[x];
        return GetKth(son[x][1],K);
    }
    int Change(int x,bool type)//传入编号
    {
        int t=sgt.Query(x,1,1,M),ans;
        splay(t,0);
        ans=size[son[t][0]]+x-no[t]+1;
        split(t,x-no[t]+1);
        if(son[t][0]!=0 or son[t][1]!=0)
            split(t,1);
        if(type==0)
        {
            son[fa[t]][t==son[fa[t]][1]]=0;
            update(fa[t]);
            splay(1,0);
            int now=son[root][1];
            while(son[now][0]!=0) now=son[now][0];
            son[now][0]=t,fa[t]=now;
            update(now),splay(now,0);
        }
        else
        {
            son[fa[t]][t==son[fa[t]][1]]=0;
            update(fa[t]);
            splay(3,0);
            int now=son[root][0];
            while(son[now][1]!=0) now=son[now][1];
            son[now][1]=t,fa[t]=now;
            update(now),splay(now,0);
        }
        return ans;
    }
    int Change2(int x,int y)//传入编号
    {
        int t=sgt.Query(x,1,1,M);
        split(t,x-no[t]+1);
        sgt.Change(y,y,t,1,1,M);
        no[t]=y;
        splay(t,0);
        return size[son[t][0]]+1;
    }
    int Query(int K)
    {
        return no[GetKth(root,K)];
    }
    void Init(int n)
    {
        root=++to,fa[root]=0;
        son[root][1]=++to,fa[to]=root,cnt[to]=size[to]=n,no[to]=1;
        sgt.to=1;
        sgt.Change(1,n,to,1,1,M);
        son[to][1]=to+1,fa[to+1]=to,to++;
        update(to),update(to-1),update(root);
    }
    void Print(int now)
    {
        if(now==0) return;
        Print(son[now][0]);
        cout&lt;&lt;"no:"&lt;&lt;now&lt;&lt;" ["&lt;&lt;no[now]&lt;&lt;","&lt;&lt;no[now]+cnt[now]-1&lt;&lt;"] "&lt;&lt;"size:"&lt;&lt;size[now]&lt;&lt;" cnt:"&lt;&lt;cnt[now]&lt;&lt;" sonl&amp;r:"&lt;&lt;son[now][0]&lt;&lt;" "&lt;&lt;son[now][1]&lt;&lt;endl;
        Print(son[now][1]);
    }
    #undef root
}splay;
int n,m;
int main()
{
    n=read(),m=read();

    splay.Init(n);
    int ans=0;
    for(int i=1;i&lt;=m;i++)
    {
        int op=read(),x=read()-ans;
        if(op==1)
        {
            int y=read()-ans;
            printf("%d\n",ans=splay.Change2(x,y));
        }
        else if(op==2)
            printf("%d\n",ans=splay.Change(x,0));
        else if(op==3)
            printf("%d\n",ans=splay.Change(x,1));
        else
            printf("%d\n",ans=splay.Query(x));
        //ans=0;//RTC
        //splay.Print(splay.son[0][1]);
        //cerr&lt;&lt;endl;
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>349</wp:post_id>
		<wp:post_date><![CDATA[2019-03-11 06:59:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-11 06:59:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3285scoi2014%e6%96%b9%e4%bc%af%e4%bc%af%e7%9a%84oj]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="splay"><![CDATA[splay]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[559]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>57</wp:comment_id>
			<wp:comment_author><![CDATA[Sharyn]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[jeannalampungmeiua@gawab.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://salesforcegadget.com/gosports-slammo-game-set/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[78.154.180.12]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-07-02 08:34:52]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-07-02 08:34:52]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thanks  for every other informative blog. The place else may just I get that kind of information written in such a perfect method?
I've a venture that I'm simply now working on, and I have been at the 
glance out for such info.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P2173] [ZJOI2012]网络</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p2173-zjoi2012%e7%bd%91%e7%bb%9c/</link>
		<pubDate>Mon, 11 Mar 2019 10:58:09 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=350</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P2173">洛谷P2173</a>

<hr />

<h1>Solution</h1>

首先，我们可以发现颜色总数特别的少，再考虑到有改变边的颜色的操作，可以考虑用LCT来解决。

我们建$c$颗LCT，每颗LCT存每个颜色对应的边，splay记录每颗splay的MAX_w。
对于修改权值，考虑直接暴力修改每个颜色的LCT里对应的点的权值
对于修改颜色，我们可以暴力在每一颗LCT里面枚举来找一下有没有这条边，有的话就断掉，然后在对应的LCT里面连上。
对于查询，我们只需要把对应的LCT中对应的链split出来，然后直接输出MAX即可。
对于每个点同色连边不超过2，我们可以直接记录每个点每种颜色连了多少条边，在link和cut中维护一下即可。

时间复杂度$O(c\cdot n \cdot logm)$
就酱，这题我们就切掉啦٩(๑>◡&lt;๑)۶

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P2173 [ZJOI2012]网络
//Mar,11th,2019
//LCT暴力题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long read()
{
    long long x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=10000+100;
const int M=10+2;
int cnt[N][M];//记录每个点连出去的边的颜色数
struct LCT
{
    int son[N][2],fa[N],lazy[N],MAX[N],w[N];
    inline void update(int x)
    {
        MAX[x]=max(MAX[son[x][0]],MAX[son[x][1]]);
        MAX[x]=max(MAX[x],w[x]);
    }
    inline void mirror(int x)
    {
        lazy[x]=!lazy[x];
        swap(son[x][0],son[x][1]);
    }
    inline void pushdown(int x)
    {
        if(lazy[x]==true)
        {
            mirror(son[x][0]);
            mirror(son[x][1]);
            lazy[x]=false;
        }
    }
    inline bool isRoot(int x)
    {
        return (x!=son[fa[x]][0] and x!=son[fa[x]][1]);
    }
    inline void rotate(int x,int type)
    {
        int y=fa[x],z=fa[y];
        fa[x]=z;
        if(isRoot(y)==false)
            son[z][y==son[z][1]]=x;
        fa[son[x][type]]=y,son[y][!type]=son[x][type];
        fa[y]=x,son[x][type]=y;
        update(y),update(x);
    }
    int mstack[N],top;
    void splay(int x)
    {
        mstack[top=1]=x;
        for(int i=x;isRoot(i)==false;i=fa[i])
            mstack[++top]=fa[i];
        for(int i=top;i&gt;=1;i--)
            pushdown(mstack[i]);
        while(isRoot(x)==false)
        {
            if(isRoot(fa[x])==false and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])
                rotate(fa[x],x==son[fa[x]][0]);
            rotate(x,x==son[fa[x]][0]);
        }
    }
    void Access(int x)
    {
        for(int t=0;x!=0;t=x,x=fa[x])
            splay(x),son[x][1]=t,fa[t]=x,update(x);
    }
    int GetRoot(int x)
    {
        Access(x),splay(x);
        while(son[x][0]!=0) x=son[x][0];
        return x;
    }
    void MakeRoot(int x)
    {
        Access(x),splay(x);
        mirror(x);
    }
    int Link(int x,int y,int c)
    {
        if(cnt[x][c]==2 or cnt[y][c]==2) return 2;
        if(GetRoot(x)==GetRoot(y)) return 1;
        cnt[x][c]++,cnt[y][c]++;
        MakeRoot(x);
        fa[x]=y;
        return 0;
    }
    void split(int x,int y)//y做原根，x作为LCT根
    {
        MakeRoot(y);
        Access(x);
        splay(x);
    }
    int Cut(int x,int y,int w)
    {
        split(x,y);
        if(y!=son[x][0] or fa[y]!=x or son[y][1]!=0) return 1;
        son[x][0]=fa[y]=0;
        update(x);
        cnt[x][w]--,cnt[y][w]--;
        return 0;
    }
    void Change(int x,int num)
    {
        split(x,x);
        w[x]=MAX[x]=num;
    }
    int Query(int x,int y)
    {
        split(x,y);
        if(GetRoot(x)!=y) return -1;
        return MAX[x];
    }
}lct[M]; 
int n,m,c,K;
void Change1(int x,int num)
{
    for(int i=0;i&lt;c;i++)
        lct[i].Change(x,num);
}
int Change2(int x,int y,int w)
{
    int statu=3;
    for(int i=0;i&lt;c;i++)
        if(lct[i].Cut(x,y,i)==0)
        {
            statu=lct[w].Link(x,y,w);
            if(statu!=0)
                lct[i].Link(x,y,i);
            break;
        }
    return statu;
}
int Query(int x,int y,int w)
{
    return lct[w].Query(x,y);
}
int main()
{
    //freopen("2173.in","r",stdin);
    //freopen("2173.out","w",stdout);

    n=read(),m=read(),c=read(),K=read();
    for(int i=1;i&lt;=n;i++)
        Change1(i,read());
    for(int i=1;i&lt;=m;i++)
    {
        int x=read(),y=read(),w=read();
        lct[w].Link(x,y,w);
    }

    for(int i=1;i&lt;=K;i++)
    {
        int op=read();
        if(op==0)
        {
            int x=read(),num=read();
            Change1(x,num);
        }
        else if(op==1)
        {
            int x=read(),y=read(),w=read(),t=Change2(x,y,w);
            if(t==0)
                printf("Success.\n");
            else if(t==1)
                printf("Error 2.\n");
            else if(t==2)
                printf("Error 1.\n");
            else
                printf("No such edge.\n");
        }
        else
        {
            int w=read(),x=read(),y=read();
            printf("%d\n",Query(x,y,w));
        }
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>350</wp:post_id>
		<wp:post_date><![CDATA[2019-03-11 10:58:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-11 10:58:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2173-zjoi2012%e7%bd%91%e7%bb%9c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[439]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P2157][SDOI2009]学校食堂</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p2157sdoi2009%e5%ad%a6%e6%a0%a1%e9%a3%9f%e5%a0%82/</link>
		<pubDate>Tue, 12 Mar 2019 02:09:07 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=352</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P2157">SDOI2009 学校食堂</a>

<hr />

<h1>Solution</h1>

这是一道状压妙题。

首先，因为后面的东西能提到前面来做，导致了严重的后效性。为了消除这个后效性，考虑用状压来处理这个问题。
我们可以发现最多的提前量很小，只有7，考虑这样设：
设$f[i][j][k]$表示$[1,i-1]$已经完成了，从$i$开始往后7个的完成状态为$j$，上一个完成的相对$i-1$的位置为k。
转移比较正常：我们枚举一下下一个选哪一个，如果$[i,x]$会被新完成，就进到下$x$位。
我们这里的枚举要非常小心：这里枚举下一个能不能选有一个重要的限制：一路过来，一定要检查当前要选的这个能否提到没有选过的前面。

就酱，我们及就可以<del>在理论上</del> AC这道题啦(*´ﾟ∀ﾟ｀)ﾉ 
<del>当然，我们很有可能因为众多的细节调个半天</del>

<hr />

<h1>Code</h1>

<strong>本题细节较多，具体细节请看代码</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=1000+10;
const int M=(1&lt;&lt;8)+50;
const int K=20;
int f[N][M][K],a[N],b[N];
int n,m;
inline int real(int x,int k)
{
    return x+k-8;
}
inline int w(int x,int y)
{
    if(x==0) return 0;//要专门特判第一个转移
    return a[x]^a[y];
}
int main()
{
    //freopen("2157.in","r",stdin);
    //freopen("2157.out","w",stdout);
    //freopen("err.out","w",stderr);

    int T=read();
    for(;T&gt;0;T--)
    {
        memset(f,0x3f,sizeof f);

        n=read();
        for(int i=1;i&lt;=n;i++)
            a[i]=read(),b[i]=read();

        m=1&lt;&lt;8;
        b[0]=0x3f3f3f3f;
        f[1][0][8]=0;
        for(int i=1;i&lt;=n;i++)
            for(int j=0;j&lt;m;j++)
                for(int k=0;k&lt;=16;k++)
                    if(real(i-1,k)&gt;=0)
                    {
                        //cerr&lt;&lt;i-1&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;k-8&lt;&lt;" :"&lt;&lt;f[i][j][k]&lt;&lt;endl;
                        int t=b[i];
                        for(int o=1;o&lt;=1+t and i-1+o&lt;=n;o++)
                        {
                            if((j&gt;&gt;(o-1))%2==1) continue;//这个已经选过了
                            t=min(t,o-1+b[i-1+o]);//限制能取到的最大范围
                            int tmp=j+(1&lt;&lt;(o-1)),py=0;
                            while(tmp%2==1) tmp/=2,py++;//计算进位
                            /*if(f[i+py][tmp][8+o-py]&gt;f[i][j][k]+w(real(i-1,k),i-1+o))
                                cerr&lt;&lt;i+py-1&lt;&lt;" "&lt;&lt;tmp&lt;&lt;" "&lt;&lt;o-py&lt;&lt;" "&lt;&lt;f[i][j][k]+w(real(i-1,k),i-1+o)&lt;&lt;endl;*/
                            f[i+py][tmp][8+o-py]=min(f[i+py][tmp][8+o-py],f[i][j][k]+w(real(i-1,k),i-1+o));
                        }
                        //cerr&lt;&lt;endl;
                    }

        int ans=0x3f3f3f3f;
        for(int i=0;i&lt;=16;i++)
            ans=min(ans,f[n+1][0][i]);
        printf("%d\n",ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>352</wp:post_id>
		<wp:post_date><![CDATA[2019-03-12 02:09:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-12 02:09:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2157sdoi2009%e5%ad%a6%e6%a0%a1%e9%a3%9f%e5%a0%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e7%8a%b6%e5%8e%8bdp"><![CDATA[状压DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[463]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P1552] [APIO2012]派遣</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p1552-apio2012%e6%b4%be%e9%81%a3/</link>
		<pubDate>Fri, 15 Mar 2019 01:47:38 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=353</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P1552">APIO2012 派遣</a>

<hr />

<h1>Solution</h1>

这是一道左偏树的模板题，不会左偏树的可以<a href="https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%AF%E5%B9%B6%E5%A0%86%E5%B7%A6%E5%81%8F%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">戳这里</a>

显然，我们可以发现对于同一颗子树，我们想让取的人尽可能便宜，如果说目前为止取的价格超过$C$,就优先把贵的人先丢掉。

因此，我们考虑用左偏树来维护这个东西。对于每一个人，我们都建一颗以价格为关键字的大根堆。考虑从下往上合并，一旦堆的元素总和超过$C$就不断弹栈，弹到合法为止。然后我们算一下$l_i*sum$，取个最大值就好。

时间复杂度$O(nlogn)$
就酱，我们就可以把这道题切掉啦(ﾉﾟ∀ﾟ)ﾉ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu  P1552 [APIO2012]派遣
//Mar,15th,2019
//左偏树水题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
struct LST
{
    int fa[N],son[N][2],dis[N],w[N];
    long long sum[N],size[N];
    inline void update(int x)
    {
        sum[x]=sum[son[x][0]]+sum[son[x][1]]+w[x];
        size[x]=size[son[x][0]]+size[son[x][1]]+1;
    }
    int Merge(int x,int y)
    {
        if(x==0 or y==0) return x+y;
        if(w[x]&gt;w[y]) swap(x,y);
        son[y][1]=Merge(x,son[y][1]);
        fa[son[y][1]]=y;
        update(y);
        if(dis[son[y][1]]&gt;dis[son[y][0]]) 
            swap(son[y][0],son[y][1]);
        dis[y]=dis[son[y][1]]+1;
        return y;
    }
    int Pop(int x)
    {
        fa[x]=Merge(son[x][0],son[x][1]);
        return fa[x];
    }
}lst;
vector &lt;int&gt; e[N];
long long c[N],l[N],size[N],n,m;
int root[N];
long long ans;
void dfs(int now)
{
    for(int i=0;i&lt;int(e[now].size());i++)
    {
        dfs(e[now][i]);
        root[now]=lst.Merge(root[now],root[e[now][i]]);
    }
    while(root[now]!=0 and lst.sum[root[now]]&gt;m)
        root[now]=lst.Pop(root[now]);
    if(root[now]!=0)
        ans=max(ans,l[now]*lst.size[root[now]]);
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;=n;i++)
    {
        int fa=read();c[i]=read(),l[i]=read();
        e[fa].push_back(i);
        size[i]=1;
        root[i]=i,lst.w[i]=lst.sum[i]=c[i],lst.size[i]=1;
    }

    dfs(1);

    printf("%lld",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>353</wp:post_id>
		<wp:post_date><![CDATA[2019-03-15 01:47:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-15 01:47:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p1552-apio2012%e6%b4%be%e9%81%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%b7%a6%e5%81%8f%e6%a0%91"><![CDATA[左偏树]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[359]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[NNEZ Monthly Round 5 T2] 文件系统 题解</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e6%a8%a1%e6%8b%9f/nnez-monthly-round-5-t2-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f-%e9%a2%98%e8%a7%a3/</link>
		<pubDate>Tue, 19 Mar 2019 04:02:37 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=355</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/T72049">洛谷团队题（尚未入团的请尽快加入团队）</a>

<hr />

<h1>梗</h1>

$\huge μ'sic\ Forever!$
<del>114514.avi.zip 1919810 （(懂的人自然懂(确信))</del>
<a href="https://zh.moegirl.org/%E5%88%AB%E5%BD%93%E6%AC%A7%E5%B0%BC%E9%85%B1%E4%BA%86">真寻酱实在是太可爱了</a>
⑨个样例<del>(我够良心吧)</del>

<hr />

<h1>真*Solution</h1>

<del>稍有常识的人都可以看出</del>,<strong>一个文件目录在任意时刻都是一个树的形式</strong><del>（如果没有快捷方式的话）</del>。
像这样：（样例）
<img src="https://s2.ax1x.com/2019/03/19/AnDGBd.png" alt="AnDGBd.png" />

<h3>解法一</h3>

我们来看看type=1啥意思....
op!=3 and op!=5 and 名字为数字?

emmmm？
因为OP！=5，树上已经插入的边是不会变的，因此，我们考虑用vector/链式前向星/领接表把这棵树存下来。
首先，我们要记录每个点的信息：<strong>它的size，是文件还是文件夹,它的父亲是什么</strong>
每次我们查询size的时候直接dfs遍历一遍子树来计算即可。

啥？你说怎么处理Error？<del>大力分类讨论，请。</del> 其实很是很好讨论的qwq。
啥？你不会输入？一时数字一时字符串怎么办？<strong>那请全部使用字符串的形式读入，再检测是否为数字，如果为数字的话，手动计算成数字即可。</strong> 
啥？你说不会读入字符串？<del>爆零,请。</del><a href="https://www.luogu.org/problemnew/show/P5015">NOIp2018 普及组T1 标题统计</a>，请

时间复杂度$O(n^2)$

恭喜你，获得了10分的好成绩

.

<h3>解法二</h3>

emmm，少了个op!=3，用人话来说，就是允许改名了。

emmm？这分简直就是送出去的啊喂。
我们思考一下，改名会造成什么问题：
1. <strong>因为我们用名字来作为记录孩子的关键字，因此会导致孩子发生改变->直接修改vector/领接表/链式前向星的对应的边即可</strong>
2. <strong>要对应地创造出一个新的点并且复制原有的信息，把原有的点删除掉（删除掉标记即可）。->4遍赋值：赋值fa，size，type，vis</strong>
3. 没了

时间复杂度$O(n^2)$

恭喜你，获得了20分的好成绩

.

<h3>解法三</h3>

emmm，这次不改名了.....但是TM的要改父亲。

这就肥肠尴尬了.......改父亲涉及到某个点删除某个孩子，很不幸的是，这种操作在vector/链式前向星中是很难做到的，即使强行做了，时间复杂度也很高。

怎么办呢？我们不妨换个思路：<strong>我们在每次插入一个新的文件的时候，计算它的“贡献”</strong>。
什么叫贡献呢？下面这个图可以很清晰的说明：
<img src="https://s2.ax1x.com/2019/03/19/AncpSP.png" alt="AncpSP.png" />
也就是说，我们插入一个大小为$x$的文件，会导致它的父亲及祖先在查询$size$的时候，查询出来的答案增加$x$（因为多了这一个文件嘛）

因此，我们可以直接记录查询某个节点时的答案（$size,cnt$），<strong>每次查询的时候直接输出它的答案。每次插入新的文件的时候，我们直接暴力向上更新他的父亲及祖先的答案。修改的时候，我们也是先暴力修改他的父亲及祖先的答案，然后改变$fa$，再暴力修改新的父亲及祖先的答案</strong>

这样，我们就只用记录每个点的父亲，而无需记录它的孩子是什么，解决了无法处理链式前向星/vector不方便删除的问题。

时间复杂度$O(n^2)$

恭喜你，获得了40分的好成绩。

.

<h3>解法四</h3>

改名和改父亲一起上.......

emmmmmm？这分也是送的啊喂。
我们这里有两种做法，一是把上面两个做法拼接到一起$O(n^2)$，二是我们把原来的每个点做一层“映射”。在这里，我主要讲第二个做法，因为后面可能要用到。

什么叫再做一次映射呢？考虑这么做：<strong>我们给每一次加文件/文件夹操作产生的新文件再赋予一个编号，对于这个点的所有记录全部在这个编号下标下的数组操作。</strong>这样子，即使我们改变了一个点的名字，也仅仅只是改变点的名字->编号的映射关系而已，我们只要把旧的名字->编号的映射关系先删掉，然后再新增一个新的名字->编号的映射关系即可。

比如说，原来有一个文件夹叫"192608"，它所对应的点的编号为17，我们称这种关系为"192608"->17的映射。那如果我们把这个文件夹名字修改为"114514"，我们只需要把原有的映射关系删除，然后再新添加一条"114514"->17的映射即可。

文件名长度不超过6，因此<strong>这个映射关系可以直接使用一个数组来存</strong>。

时间复杂度$O(n \cdot 100)$（树是随机的，最多只有100层）

恭喜你，获得了75分的好成绩。

.

<h3>解法五</h3>

这次文件名不全是数字了.......

这......
这不是直接换成字符串就好了吗？
之前我们提到的映射关系是数字到数字的映射，<strong>这里我们只用改为字符串到数字的映射即可</strong>。

因为文件名长度不超过25，因此<strong>这个映射关系可以用char[N][25]</strong>的方式来存。
每次输入一个文件名我们暴力匹配即可。

期望时间复杂度$O(n \cdot 100)$

干得不错，你又成功A掉了一道水题！

<hr />

<h1>End？</h1>

<img src="https://s2.ax1x.com/2019/03/19/An2bLT.png" alt="An2bLT.png" />

.

.

.

.

<h3>解法五</h3>

你是不是觉得这是一道辣鸡题，数据点分布毫无意义？

.

<img src="https://s2.ax1x.com/2019/03/19/AnRhnK.png" alt="AnRhnK.png" />

<img src="https://s2.ax1x.com/2019/03/19/AnR57D.png" alt="AnR57D.png" />

没错，这个菜鸡故意卡了暴力匹配。那四个点全部都是字符集只有“a,b”的串，导致失配长度都特别长，直接TLE。

所以说，时间复杂度为$O(n\cdot 100 \cdot 25)$
恭喜你，拿到了80分的好成绩！

<hr />

<h3>解法六</h3>

所以说这毒瘤出题人出的毒瘤数据怎么处理啊啊啊啊
<img src="https://s2.ax1x.com/2019/03/19/AnRq1I.png" alt="AnRq1I.png" />

OK，我们来回忆一下字符串匹配算法有什么？暴力匹配，Trie树，KMP，哈希，<del>AC自动机，后缀自动机</del>
考虑到我们这里是多模式串，多匹配串，KMP，AC自动机失去了用处。

因此，这题我们可以考虑用Trie树来处理匹配问题。
当然，这个菜鸡出题者作为暴力党，肯定是不会写一个Trie树来干这种破事的。因此，我们考虑用hash来解决这个问题。

我们直接对每个串大力hash，算出来的hash结果再用刚刚的映射方法映射到编号。酱紫，我们可以用两层映射来解决这个破问题。

怎么存哈希值->原编号这个映射呢？这就是个技术活了。因为我们这里的hash值很大，很难用一个数组存下来。
这时候，我们有两种解决办法：
1. 哈希表
2. map

菜鸡出题人作为暴力主义的一份子，是懒得写hash表的。因此我们直接用map存每个字符串到编号的映射即可。

啥？map怎么用？<a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">看这个</a>

时间复杂度$O(n*100)$
干的不错，你又成功地A掉了一道水题。

<strong>代码在这里</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N=100000+1000;
map &lt;string,int&gt; emap;
int n,m;
string str[N];
int to,fa[N],type[N],cnt[N];//type:0:文件夹；1：文件
long long size[N];
void update(int now,int x,int x2)
{
    do
    {
        now=fa[now];
        size[now]+=x;
        cnt[now]+=x2;
    }while(now!=0);
}
bool Check(int x1,int x2)//检验x2是否为x1的子文件夹
{
    do
    {
        x2=fa[x2];
        if(x1==x2) 
            return true;
    }while(x2!=0);
    return false;
}
int main()
{
//  freopen("file7.in","r",stdin);
//  freopen("file7a.out","w",stdout);

    scanf("%d%d",&amp;n,&amp;m);

    emap["root"]=0;
    str[0]="root";
    for(int i=1;i&lt;=n;i++)
    {
        //cerr&lt;&lt;i&lt;&lt;endl;
        int op; 
        scanf("%d",&amp;op);

        if(op==1)
        {
            string s1,s2;
            cin&gt;&gt;s1&gt;&gt;s2;
            if(emap.count(s1)==0 or type[emap[s1]]==1 or emap.count(s2)!=0)
            {
                printf("Error\n");
                continue;
            }
            emap[s2]=++to,type[to]=0,fa[to]=emap[s1];
            str[to]=s2;
            printf("Success\n");
        }

        if(op==2)
        {
            string s1,s2;
            int x;
            cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;x;
            if(emap.count(s1)==0 or type[emap[s1]]==1 or emap.count(s2)!=0)
            {
                printf("Error\n");
                continue;
            }
            emap[s2]=++to,type[to]=1,fa[to]=emap[s1],size[to]=x,cnt[to]=1;
            str[to]=s2;
            update(to,size[to],1);
            printf("Success\n");
        }

        if(op==3)
        {
            string s1,s2;
            cin&gt;&gt;s1&gt;&gt;s2;
            if(emap.count(s1)==0 or emap.count(s2)!=0)
            {
                printf("Error\n");
                continue;
            }
            emap[s2]=emap[s1];
            emap.erase(s1);
            str[emap[s2]]=s2;
            printf("Success\n");
        }

        if(op==4)
        {
            string s1;
            cin&gt;&gt;s1;
            if(emap.count(s1)==0 or type[emap[s1]]==1)
            {
                printf("Error\n");
                continue;
            }
            printf("%d\n",cnt[emap[s1]]);
        }

        if(op==5)
        {
            string s1,s2;
            cin&gt;&gt;s1&gt;&gt;s2;
            if(emap.count(s1)==0 or emap.count(s2)==0 or type[emap[s2]]==1 or s1==s2 or Check(emap[s1],emap[s2])==true)
            {
                printf("Error\n");
                continue;
            }
            update(emap[s1],-size[emap[s1]],-cnt[emap[s1]]);
            fa[emap[s1]]=emap[s2];
            update(emap[s1],size[emap[s1]],cnt[emap[s1]]);
            printf("Success\n");
        }

        if(op==6)
        {
            string s1;
            cin&gt;&gt;s1;
            if(emap.count(s1)==0 or type[emap[s1]]==1)
            {
                printf("Error\n");
                continue;
            }
            printf("%lld\n",size[emap[s1]]);
        }

        if(op==7)
        {
            string s1;
            cin&gt;&gt;s1;
            if(emap.count(s1)==0 or type[emap[s1]]==0)
            {
                printf("Error\n");
                continue;
            }
            cout&lt;&lt;str[fa[emap[s1]]]&lt;&lt;endl;
        }
    }

    return 0;
}
</code></pre>

<hr />

<h1>True End？</h1>

事实上，上面的那个做法已经可以成功的A掉这道题了。

但是，这题的数据是随机的，总让人有水题的感觉，那我们加强一下？我们数据不随机。

....

<h3>解法七</h3>

这里需要用到高级数据结构的知识，NOIp选手们请绕道行车/小心驾驶。<del>翻车了也不要紧，我敢打包票NOIp绝对不会考这种数据结构（5年内）</del>

我们发现，这里动态连边是不是让人有一种LCT的感觉？
对了！这题的确可以用LCT来解决.......吗？

这题维护子树？LCT能维护子树？

LCT当然不能维护子树啊。问题是，这题看上去需要维护子树，实际上真的需要吗？
考虑我们维护贡献的时候，是维护它到根的一条链的。

诶？因此，LCT是可以通过维护链来间接解决这道题的。我们直接在每个点上对应的维护它的$size,cnt$,连边的时候暴力打标记，暴力pushdown标记即可。

啥？你说你不会LCT？如果你会splay并且把NOIp的芝士都差不多过了一遍，可以<a href="https://www.goldenpotato.cn/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lct%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">戳这里</a>

时间复杂度：真·$O(nlogn)$（但是因为splay常数巨大，这里的复杂度我们基本上可以再乘上一个$logn$）

<hr />

<h1>True End</h1>

事实上呢，这题的确比NOIp中的模拟题稍微难那么一点点，但是把我们学过的知识综合起来，还是勉强可以做的。如果你仔细观察数据点的分布，你会发现送了很多很多的部分分，<strong>而且数据点的数据范围是对你的解题有引导作用的，它会逐步带领你走向正解</strong>。

以及，真寻酱很感谢你帮她写的文件系统，并奖励了你一瓶神秘小♂药♂水

<img src="https://s2.ax1x.com/2019/03/19/Anfcsx.png" alt="Anfcsx.png" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>355</wp:post_id>
		<wp:post_date><![CDATA[2019-03-19 04:02:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-19 04:02:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[nnez-monthly-round-5-t2-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f-%e9%a2%98%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[noipexcited]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="lct"><![CDATA[LCT]]></category>
		<category domain="category" nicename="nnez"><![CDATA[NNEZ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%a8%a1%e6%8b%9f"><![CDATA[模拟]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[532]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[327]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>16</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.139.214.69]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-19 04:07:33]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-19 04:07:33]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[密码我会在考完试后给大家 :huaji:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[被GoldenPotato137摁在地上疯狂摩擦到熔化的蒟蒻lizbaka]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[58.210.184.138]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-23 05:40:41]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-23 05:40:41]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[%%% Orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>18</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[121.14.67.226]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-03-23 12:22:41]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-03-23 12:22:41]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[您太fAKe了，Orz]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>17</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P3247] [HNOI2016]最小公倍数</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3247-hnoi2016%e6%9c%80%e5%b0%8f%e5%85%ac%e5%80%8d%e6%95%b0/</link>
		<pubDate>Tue, 19 Mar 2019 11:24:56 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=356</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3247">P3247 [HNOI2016]最小公倍数</a>

<hr />

<h1>Solution</h1>

这是一道妙题。

首先，<del>根据常识</del>，题面要我们求的是找一条从s,t的路径，使得路径上$max\ a=a,max\ b=b$。

这咋求呢？我们会发现，<strong>我们要求的路径本质上是一个连通块，连通块可以考虑用并查集处理</strong>。
接下来考虑对a分块，先把所有的边按照$a$来排序，再分块，每个块里连的所有边保证$&lt;=a_{[size*x]}$，如下图所示：
<img src="https://s2.ax1x.com/2019/03/19/AuMb0e.png" alt="AuMb0e.png" />

接下来，我们考虑把所有询问按照<strong>b从小到大</strong>排序去一个个计算，每计算一个询问之前，把$b&lt;=q[i].b$的边全部都对应地塞到联通快里面去(根据我们之前分块的定义，每条边说要塞入的并查集一定为从某个连通块开始一直往后到最后一个块为止)。

接下来，我们对应的去找最大的$a&lt;=q[i].a$的连通块，然后把一些还零散在外面的边全部塞到那个连通块里面，<strong>这个连通块里面所有的边一定能保证$a&lt;=q[i].a,b&lt;=q[i].b$</strong>，我们只需要对应的看看$u,v$是否联通，它们所在的连通块的$max&#95;a,max&#95;b$是否满足要求即可。

我们每做完一个操作后，必须把之前连的零散的边给撤销掉。因此，我们这里必须用<strong>按秩合并的并查集</strong>。我们可以通过用一个栈/队列记录所有的修改操作(改fa/改max)一个一个改回去即可。

因为我们这里有$\sqrt m$个块，每次操作的零散边不超过$\sqrt m$条，因此总复杂度应该是$O(n \cdot \sqrt m)$

<hr />

<h1>Code</h1>

<strong>数据生成器</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int N=30;
const int M=80;
const int MAX=16;
bool vis[MAX+50];
long long mrand()
{
    long long temp=(1ll*rand()*rand())%MAX,op=rand()%4;
    /*while(op==0 and vis[temp]==false)
        temp=(1ll*rand()*rand())%MAX;*/
    vis[temp]=true;
    return temp;
}
int main()
{
    srand(time(NULL));
    freopen("3247.in","w",stdout);

    int n=N,m=M;
    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
    for(int i=1;i&lt;=m;i++)
        cout&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;mrand()&lt;&lt;" "&lt;&lt;mrand()&lt;&lt;endl;

    int q=N;
    cout&lt;&lt;q&lt;&lt;endl;
    for(int i=1;i&lt;=q;i++)
        cout&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;mrand()&lt;&lt;" "&lt;&lt;mrand()&lt;&lt;endl;
    return 0; 
}

</code></pre>

<strong>请注意特判(0,0)边构成自环的情况，我因为这个破事WA了半天</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50000+100;
const int M=100000+100;
const int Q=1000;
struct line
{
    int s,t,a,b,ans,no;
    friend bool operator &lt; (line x,line y)
    {
        return x.a&lt;y.a;
    }
}l[M],l2[M],q[N];
bool cmp1(line x,line y)
{
    return x.a&lt;y.a;
}
bool cmp2(line x,line y)
{
    return x.b&lt;y.b;
}
bool cmp3(line x,line y)
{
    return x.no&lt;y.no;
}
int n,m,K,block[Q];//block[i]:记录第i块的a值
struct SIT
{
    int type,x,num1,num2;//type=0:改fa;type=1:改max
}mstack[N];
int top;
struct UnF
{
    int fa[N],size[N],MAX_a[N],MAX_b[N];
    int FindFather(int x)
    {
        if(fa[x]==0) return x;
        return FindFather(fa[x]);
    }
    void Merge(int x,int y,int a,int b,bool type)//type=0：不撤回;=1:要撤回
    {
        int fa1=FindFather(x),fa2=FindFather(y);
        if(size[fa1]&gt;size[fa2]) 
            swap(x,y),swap(fa1,fa2);
        if(type==1)
            mstack[++top].type=1,mstack[top].x=fa2,
            mstack[top].num1=MAX_a[fa2],mstack[top].num2=MAX_b[fa2];
        MAX_a[fa2]=max(max(MAX_a[fa2],MAX_a[fa1]),a);
        MAX_b[fa2]=max(max(MAX_b[fa2],MAX_b[fa1]),b);   
        if(fa1==fa2)
            return;
        if(type==1)
            mstack[++top].type=0,mstack[top].x=fa1,mstack[top].num1=fa2,mstack[top].num2=size[fa1];
        fa[fa1]=fa2,size[fa2]+=size[fa1];
    }
    void Undo()
    {
        for(;top&gt;0;top--)
        {
            if(mstack[top].type==0)
                fa[mstack[top].x]=0,size[mstack[top].num1]-=mstack[top].num2;
            else
                MAX_a[mstack[top].x]=mstack[top].num1,
                MAX_b[mstack[top].x]=mstack[top].num2;
        }
    }
    int Query(int x,int y,int a,int b)
    {
        if(x==y and a==0 and b==0)
            return size[FindFather(x)]!=1;
        int fa=FindFather(x);
        if(FindFather(x)!=FindFather(y)) return false;
        if(MAX_a[fa]!=a or MAX_b[fa]!=b)
            return false;
        return true;
    }
}unf[Q];
int main()
{
    int t=clock();
    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
    {
        l[i].s=read(),l[i].t=read(),l[i].a=read(),l[i].b=read();
        l2[i]=l[i];
    }
    K=read();
    for(int i=1;i&lt;=K;i++)
        q[i].s=read(),q[i].t=read(),q[i].a=read(),q[i].b=read(),q[i].no=i;

    int size=int(sqrt(m*20)),cnt=m/size;        
    for(int i=0;i&lt;=cnt;i++)
        for(int j=1;j&lt;=n;j++)
            unf[i].size[j]=1;
    sort(l+1,l+1+m,cmp1);
    sort(l2+1,l2+1+m,cmp1);
    for(int i=0;i&lt;=m/size;i++)
        block[i]=l[i*size].a;
    sort(q+1,q+1+K,cmp2);
    sort(l+1,l+1+m,cmp2);

    int to=1;//记录当前执行到第to条边
    for(int i=1;i&lt;=K;i++)
    {
        //cerr&lt;&lt;i&lt;&lt;endl;
        for(;l[to].b&lt;=q[i].b and to&lt;=m;to++)
        {
            int begin=lower_bound(block,block+1+cnt,l[to].a)-block;
            for(int j=begin;j&lt;=cnt;j++)
                unf[j].Merge(l[to].s,l[to].t,l[to].a,l[to].b,0);
        }
        int t=upper_bound(block,block+1+cnt,q[i].a)-block-1;
        line tmp;tmp.a=block[t];
        for(int j=upper_bound(l2+1,l2+1+m,tmp)-l2;j&lt;=m and l2[j].a&lt;=q[i].a;j++)
            if(l2[j].b&lt;=q[i].b)
                unf[t].Merge(l2[j].s,l2[j].t,l2[j].a,l2[j].b,1);
        q[i].ans=unf[t].Query(q[i].s,q[i].t,q[i].a,q[i].b);
        unf[t].Undo();
    }

    sort(q+1,q+1+K,cmp3);
    for(int i=1;i&lt;=K;i++)
        if(q[i].ans==1)
            printf("Yes\n");
        else
            printf("No\n");
    cerr&lt;&lt;clock()-t&lt;&lt;endl;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>356</wp:post_id>
		<wp:post_date><![CDATA[2019-03-19 11:24:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-19 11:24:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3247-hnoi2016%e6%9c%80%e5%b0%8f%e5%85%ac%e5%80%8d%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[309]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[341]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3645] [APIO2015]雅加达的摩天楼</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3645-apio2015%e9%9b%85%e5%8a%a0%e8%be%be%e7%9a%84%e6%91%a9%e5%a4%a9%e6%a5%bc/</link>
		<pubDate>Tue, 19 Mar 2019 13:15:47 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=357</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3645">P3645 [APIO2015]雅加达的摩天楼</a>

<hr />

<h1>Solution</h1>

与其说这题是分块妙题，我更倾向于把这题称为分层图妙题。

这题有一个一眼贪心做法：<strong>对于每只doge，我们都暴力地去建它连向它能跳到的点的边，边权为跳的次数。然后直接求一遍单元最短路即可</strong>。
很显然，这玩意的边的数量是$O(n^2)$的，求一遍最短路的复杂度达到了惊人的$n^2logn^2$

这显然是要T飞的，但是我们会从中发现一个问题：既然一个doge的跳跃是多步的，那我们能否直接把几步拆开来，然后省略重复的边？
例如：
<img src="https://s2.ax1x.com/2019/03/19/Au13S1.png" alt="Au13S1.png" />
优化为：
<img src="https://s2.ax1x.com/2019/03/19/Au8AbT.png" alt="Au8AbT.png" />

这样做看起来很星，很不幸的是，这样是不行的。因为我们在计算最短路的时候，我们有可能直接从中间某个点出发，但是很不幸的是，这样是不可行的。

怎么办呢？这时我们可以考虑把网络流的分层图那一套搬出来。
我们可以考虑使用“拆点”的做法来限制从某个点出发去更新别的点的最短路。
考虑把一个点拆分为size个点，<strong>每个拆分点的含义为所有一次跳x步的都从它出发，并到达它那里</strong>。
<strong>从每个点的拆分点出发，向它的原点连一条边权为0的有向边</strong>
<strong>如果能从某个点出发，则对应的从原点连向那个跳x格远的分点连一条边权为0的边</strong>
<strong>接下来我们从每个点的对应的跳x格远的的点连向其他的点的跳x格的点，边权为1</strong>

一图胜千言：
<img src="https://s2.ax1x.com/2019/03/19/AuUNi8.png" alt="AuUNi8.png" />
变为
<strong>最后一行的所有点即为原来的点</strong>
<strong>从下往上第x行的点即为某个原点的第x个分点</strong>
<a href="https://imgchr.com/i/AuaFfS"><img src="https://s2.ax1x.com/2019/03/19/AuaFfS.png" alt="AuaFfS.png" /></a>

通过这样一轮拆分，我们就已经可以解决问题啦。

啥？你说这样会有$n^2$个点？这是就得用到分块思想啦。你想，如果一个doge一次能跳的距离超过$\sqrt n$格远，那总共连出来的边不会超过$\sqrt n$条，我们直接在原点连就好啦qwq。

<del>根据玄学证明，这里的块大小取100是最好的（我并不会证）</del>
时间复杂度O(能过)

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">// luogu-judger-enable-o2
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=30000+100;
const int M=100+20;
struct edge
{
    int to,w;
    edge (int x,int y)
    {
        to=x,w=y;
    }
};
vector &lt;edge&gt; e[N*M];
int n,m,size,dis[N*M],S,T;
void spfa()
{
    static int InQueue[N*M],mqueue[N*M*10],front,tail;
    memset(dis,0x3f,sizeof dis);
    front=tail=0;
    mqueue[tail++]=S*size,dis[S*size]=0;
    while(tail&gt;front)
    {
        int now=mqueue[front++];
        InQueue[now]=false;
        for(int i=0;i&lt;int(e[now].size());i++)
            if(dis[e[now][i].to]&gt;dis[now]+e[now][i].w)
            {
                dis[e[now][i].to]=dis[now]+e[now][i].w;
                if(InQueue[e[now][i].to]==false)
                {
                    InQueue[e[now][i].to]=true;
                    mqueue[tail++]=e[now][i].to;
                }
            }
    }
}
int main()
{
    //freopen("3645.in","r",stdin);
    //freopen("3645.out","w",stdout);

    int t=clock();
    n=read(),m=read();
    size=min(int(sqrt(n)),50);
    int to=n*size;
    for(int i=1;i&lt;=to;i++)
        e[i].reserve(4);
    for(int i=0;i&lt;n;i++)
        for(int j=1;j&lt;size;j++)
            e[i*size+j].push_back(edge(i*size,0));
    for(int i=1;i&lt;=m;i++)
    {
        int b=read(),p=read();
        if(i==1) S=b;
        if(i==2) T=b;
        if(p&gt;=size)
        {
            for(int j=b+p,k=1;j&lt;n;j+=p,k++)
                e[b*size].push_back(edge(j*size,k));
            for(int j=b-p,k=1;j&gt;=0;j-=p,k++)
                e[b*size].push_back(edge(j*size,k));
        }
        else
        {
            e[b*size].push_back(edge(b*size+p,0));
            for(int j=b;j&lt;n-p;j+=p)
            {
                bool OK=false;
                for(int k=0;k&lt;int(e[j*size+p].size());k++)
                    if(e[j*size+p][k].to==(j+p)*size+p)
                    {
                        OK=true;
                        break;
                    }
                if(OK==true) break;
                e[j*size+p].push_back(edge((j+p)*size+p,1));
            }
            for(int j=b;j&gt;=p;j-=p)
            {
                bool OK=false;
                for(int k=0;k&lt;int(e[j*size+p].size());k++)
                    if(e[j*size+p][k].to==(j-p)*size+p)
                    {
                        OK=true;
                        break;
                    }
                if(OK==true) break;
                e[j*size+p].push_back(edge((j-p)*size+p,1));
            }
        }
    }

    spfa();

    if(dis[T*size]&lt;0x3f3f3f3f)
        printf("%d",dis[T*size]);
    else
        printf("-1");
    cerr&lt;&lt;clock()-t;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>357</wp:post_id>
		<wp:post_date><![CDATA[2019-03-19 13:15:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-19 13:15:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3645-apio2015%e9%9b%85%e5%8a%a0%e8%be%be%e7%9a%84%e6%91%a9%e5%a4%a9%e6%a5%bc]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84"><![CDATA[最短路径]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[395]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[BZOJ 4320] ShangHai2006 Homework</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/bzoj-4320-shanghai2006-homework/</link>
		<pubDate>Tue, 19 Mar 2019 13:39:54 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=360</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4320">4320: ShangHai2006 Homework</a>

<hr />

<h1>Solution</h1>

这是一道分块妙题。

首先，我们发现这题是对一个比较大的任意模数取模，那我们传统的log数据结构可能还真没法下手。

既然如此，我们考虑分块。
我们把原题中的询问分为两类：
1. $p>=\sqrt{300000}$
2. $p&lt;\sqrt{300000}$

对于第二种情况，我们可以开一个桶$f[x]$表示目前为止所有数字%$x$后取得的最小值。这个东西我们在插入数字的时候暴力更新一下即可。

对于第一种情况，事情有点复杂，我们这样做：
把所有数字平铺在数轴上，然后我们假设要求%$p$的ans，我们会发现，<strong>这个ans一定是$p$的整数倍的(右边的最靠近它的数字-它的位置)的最小值</strong>(正确性用草稿纸玩一玩就可以发现了)

那怎么维护某个位置的最右边的最靠近它的数呢？log数据结构显然可以做。问题是log数据结构在这里要T掉。
怎么办呢？我们发现这题可以离线做。
考虑这样做，<strong>我们先把所有数字插入到数轴里面，然后我们维护一个并查集：每一个点的fa指向他的后一个点，如果这个点是有数字的，则他作为一个根。</strong>
我们可以显然发现，<strong>一个点的在它右边的最靠近它的数字一定是它所在的连通块的根</strong>，对于删除数字，我们直接把这个点的fa指向后一个即可。

时间复杂度$O(n\cdot \sqrt{300000})$

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//BZOJ 4320: ShangHai2006 Homework
//Mar,19th,2019
//分块处理膜号妙题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int MAX=300000+100;
int fa[MAX];
int GetFa(int x)
{
    if(x&gt;=300001) return 0x3f3f3f3f;
    if(fa[x]==0) return x;
    return fa[x]=GetFa(fa[x]);
}
int num[N],ans[N],op[N],type[N],f[MAX];//type:0插入；1:询问
int n,size=550;
bool vis[MAX];
int main()
{
    freopen("4320.in","r",stdin);
    freopen("4320.out","w",stdout);

    int msize = 256 &lt;&lt; 20; // 256MB
    char *p = (char*)malloc(msize) + msize;
    __asm__("movl %0, %%esp\n" :: "r"(p));

    n=read();

    memset(f,0x3f,sizeof f);
    for(int i=1;i&lt;=n;i++)
    {
        char OP[4];
        scanf("%s",OP+1);
        op[i]=read();
        if(OP[1]=='A')
        {
            vis[op[i]]=true;
            for(int j=1;j&lt;size;j++)
                f[j]=min(f[j],op[i]%j);
        }
        else
        {
            type[i]=1;
            if(op[i]&lt;size) ans[i]=f[op[i]];
        }
    }
    for(int i=0;i&lt;=300000;i++)
        if(vis[i]==false)
            fa[i]=i+1;
    for(int i=n;i&gt;=1;i--)
        if(type[i]==0)
            fa[op[i]]=op[i]+1;
        else if(op[i]&gt;=size)
        {
            ans[i]=0x3f3f3f3f;
            for(int j=0;j*op[i]&lt;=300000;j++)
                ans[i]=min(ans[i],GetFa(j*op[i])-j*op[i]);
        }

    for(int i=1;i&lt;=n;i++)
        if(type[i]==1)
            printf("%d\n",ans[i]);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>360</wp:post_id>
		<wp:post_date><![CDATA[2019-03-19 13:39:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-19 13:39:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-4320-shanghai2006-homework]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[329]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[BZOJ 3744] Gty的妹子序列</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/bzoj-3744-gty%e7%9a%84%e5%a6%b9%e5%ad%90%e5%ba%8f%e5%88%97/</link>
		<pubDate>Wed, 20 Mar 2019 14:41:38 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=364</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3744">3744: Gty的妹子序列</a>

<hr />

<h1>Solution</h1>

这是一道分块妙题。

区间逆序对......log数据结构应该是没法搞的。
因此，我们考虑用分块解决这个问题。
<strong>设$f[i][j]$表示第$i$块与第$j$块的所有元素的逆序对个数</strong>
这个东西我们可以考虑用线段树/树状数组直接搞，我们把所有数字从大到小插入，(数字相同的时候一起插入),每插入一种数字，我们可以直接计算它到其他所有块会新产生的逆序对数：即那个块的大小-已经填好的数字的个数。
上面的东西可以$O(n\cdot \sqrt n \cdot logn)$预处理出来。

接下来，我们用<strong>$g[i][j]$表示从第$i$块开始，第$i$块与$i-j$块中所有元素的逆序对个数</strong>，这个可以利用$f$直接前缀和计算。

那么$l,r$中所有元素的逆序对个数即为里面整块的$\sum g[i][br]+$零散的值的逆序对个数。对于零散的值的个数，我们可以直接用主席树求即可。

时间复杂度$O(n\cdot \sqrt n \cdot logn)$,卡常。
如果您BZOJ卡不过的话，可以来luogu<a href="https://www.luogu.org/problemnew/show/U66042">这道题试试</a>

就酱，我们又切掉一道题啦ヾ(o´∀｀o)ﾉ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//[BZOJ 3744] Gty的妹子序列
//Mar,20th,2019
//分块求区间逆序对数
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50000+100;
const int Q=225+20;
struct SegmentTree
{
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    #define mid ((now_l+now_r)&gt;&gt;1)
    int sum[N&lt;&lt;2];
    inline void update(int now)
    {
        sum[now]=sum[lson]+sum[rson];
    }
    void Add(int x,int num,int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            sum[now]+=num;
            return;
        }
        if(x&lt;=mid) Add(x,num,lson,now_l,mid);
        else Add(x,num,rson,mid+1,now_r);
        update(now);
    }
    int Query(int l,int r,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
            return sum[now];
        int t_ans=0;
        if(l&lt;=mid) t_ans+=Query(l,r,lson,now_l,mid);
        if(r&gt;mid) t_ans+=Query(l,r,rson,mid+1,now_r);
        return t_ans;
    }
    #undef lson
    #undef rson
    #undef mid
}sgt;
struct PresidentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    static const int M=(50000&lt;&lt;2)*30;
    int sum[M],son[M][2],to;
    inline void update(int now)
    {
        sum[now]=sum[son[now][0]]+sum[son[now][1]];
    }
    void Add(int x,int now,int pre,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            sum[now]=sum[pre]+1;
            return;
        }
        if(x&lt;=mid)
        {
            Add(x,son[now][0]=++to,son[pre][0],now_l,mid);
            son[now][1]=son[pre][1];
        }
        else
        {
            Add(x,son[now][1]=++to,son[pre][1],mid+1,now_r);
            son[now][0]=son[pre][0];
        }
        update(now);
    }
    int Query(int l,int r,int now,int pre,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r) return sum[now]-sum[pre];
        int t_ans=0;
        if(l&lt;=mid)  t_ans+=Query(l,r,son[now][0],son[pre][0],now_l,mid);
        if(r&gt;mid)   t_ans+=Query(l,r,son[now][1],son[pre][1],mid+1,now_r);
        return t_ans;
    } 
    #undef mid
}prt;
struct NUM
{
    int w,no;
}num[N];
bool cmp(NUM x, NUM y)
{
    return x.w&gt;y.w;
}
bool cmp2(NUM x,NUM y)
{
    return x.no&lt;y.no;
}
int t_a[N],n,m,block,cnt[Q],msize[Q];
int f[Q][Q],g[Q][Q],root[N];
int main()
{
    int t=clock();
    freopen("3744.in","r",stdin);
    freopen("3744.out","w",stdout);

    n=read();
    for(int i=1;i&lt;=n;i++)
        num[i].w=t_a[i]=read(),num[i].no=i;

    sort(t_a+1,t_a+1+n);
    m=unique(t_a+1,t_a+1+n)-t_a-1;
    for(int i=1;i&lt;=n;i++)
        num[i].w=lower_bound(t_a+1,t_a+1+m,num[i].w)-t_a;

    sort(num+1,num+1+n,cmp);
    int size=int(sqrt(n));
    msize[0]=size-1,msize[n/size]=n%size+1;
    for(int i=1;i&lt;n/size;i++)
        msize[i]=size;
    block=n/size;
    for(int i=1;i&lt;=n;i++)
        sgt.Add(i,1,1,1,n);
    static int mqueue[N],tail;
    int to=0;
    while(to&lt;n)
    {
        tail=0;
        for(to++;to&lt;=n;to++)
        {
            sgt.Add(num[to].no,-1,1,1,n);
            cnt[num[to].no/size]++;
            mqueue[tail++]=to;
            if(num[to+1].w != num[to].w)
                break;
        }
        for(int t=0;t&lt;tail;t++)
        {
            int i=mqueue[t];
            for(int j=num[i].no/size+1;j&lt;=block;j++)
                f[j][num[i].no/size]+=msize[j]-cnt[j],
                f[num[i].no/size][j]+=msize[j]-cnt[j];
            f[num[i].no/size][num[i].no/size]+=sgt.Query(num[i].no,(num[i].no/size+1)*size-1,1,1,n);
        }
    }
    for(int i=0;i&lt;=block;i++)
    {
        g[i][i]=f[i][i];
        for(int j=i+1;j&lt;=block;j++)
            g[i][j]+=g[i][j-1]+f[i][j];
    }

    /*for(int i=0;i&lt;=block;i++)
    {
        for(int j=i;j&lt;=block;j++)
            cerr&lt;&lt;g[i][j]&lt;&lt;" ";
        cerr&lt;&lt;endl;
    }*/

    sort(num+1,num+1+n,cmp2);
    for(int i=1;i&lt;=n;i++)
    {
        root[i]=++prt.to;
        prt.Add(num[i].w,root[i],root[i-1],0,m);
    }
    int q=read(),ans=0;
    for(int i=1;i&lt;=q;i++)
    {
        int l=read()^ans,r=read()^ans;
        ans=0;
        for(int j=l;j&lt;min((l/size+1)*size,r+1);j++)//左散块
            ans+=prt.Query(0,num[j].w-1,root[r],root[j],0,m);
        if(l/size+1 &lt;= r/size-1)//中间块
            for(int j=l/size+1;j&lt;=r/size-1;j++)
                ans+=g[j][r/size-1];
        if(l/size!=r/size)//右散块
            for(int j=r/size*size;j&lt;=r;j++)
            {
                ans+=prt.Query(0,num[j].w-1,root[r],root[j],0,m);
                if(l/size+1 &lt;= r/size-1)
                    ans+=prt.Query(num[j].w+1,m,root[r/size*size-1],root[(l/size+1)*size-1],0,m);
            }
        printf("%d\n",ans);
    }

    cerr&lt;&lt;clock()-t;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>364</wp:post_id>
		<wp:post_date><![CDATA[2019-03-20 14:41:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-20 14:41:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-3744-gty%e7%9a%84%e5%a6%b9%e5%ad%90%e5%ba%8f%e5%88%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e4%b8%bb%e5%b8%ad%e6%a0%91"><![CDATA[主席树]]></category>
		<category domain="category" nicename="%e5%88%86%e5%9d%97"><![CDATA[分块]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[327]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[LOJ 121] 「离线可过」动态图连通性</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/loj-121-%e3%80%8c%e7%a6%bb%e7%ba%bf%e5%8f%af%e8%bf%87%e3%80%8d%e5%8a%a8%e6%80%81%e5%9b%be%e8%bf%9e%e9%80%9a%e6%80%a7/</link>
		<pubDate>Fri, 22 Mar 2019 03:38:39 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=366</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://loj.ac/problem/121">#121. 「离线可过」动态图连通性</a>

<hr />

<h1>Solution</h1>

这题我们考虑离线下来搞。离线之后，我们会发现，<strong>某条边会在某些询问区间中出现</strong>。
考虑<strong>以询问的编号为下标建线段树</strong>，我们<strong>把每一条边出现的时间段全部加到线段树里面去</strong>。
接下来，直接在线段树上跑dfs,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。
这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询即可。
因为我们这里有撤销（回溯）操作，因此必需使用<strong>按秩合并</strong>的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。

时间复杂度$O(nlog^2n)$？
<del>反正是$O(能过)$</del>

就酱，我们又切掉一道题啦φ(>ω&lt;*)

<hr />

<h1>Code</h1>

<strong>正解</strong>

<pre><code class="language-cpp line-numbers">//LOJ #121. 「离线可过」动态图连通性
//Mar,21st,2019
//线段树分治离线维护动态图连通性
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;ctime&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=5000+100;
const int M=500000+100;
int n,m,q,p,ans[M];
inline int GetID(int s,int t)
{
    if(s&gt;t) swap(s,t);
    return (s-1)*(n+1)+t;
}
struct UnF
{   
    int size[N],fa[N],mstack[M],top;
    void Init()
    {
        for(int i=1;i&lt;=n;i++)
            size[i]=1;
    }
    int FindFather(int x)
    {
        if(fa[x]==0) return x;
        return FindFather(fa[x]);
    }
    void Link(int x,int y)
    {
        mstack[++top]=0;
        int fa_x=FindFather(x),fa_y=FindFather(y);
        if(size[fa_x]&gt;size[fa_y]) 
            swap(x,y),swap(fa_x,fa_y);
        if(fa_x==fa_y) return;
        mstack[top]=fa_x;   
        fa[fa_x]=fa_y,size[fa_y]+=size[fa_x];
    }
    int Query(int x,int y)
    {
        if(FindFather(x)==FindFather(y)) return true;
        return false;
    }
    void Undo()
    {
        if(mstack[top]==0)
        {
            top--;
            return;
        }
        size[fa[mstack[top]]]-=size[mstack[top]];
        fa[mstack[top]]=0;
        top--;
    }
}unf;
struct OP
{
    int s,t,id;
}op[M],op2[M];
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    vector &lt;int&gt; e[M&lt;&lt;2];
    void Insert(int l,int r,int x,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            //cerr&lt;&lt;now_l&lt;&lt;" "&lt;&lt;now_r&lt;&lt;endl;
            e[now].push_back(x);
            return;
        }
        if(l&lt;=mid) Insert(l,r,x,lson,now_l,mid);
        if(r&gt;mid) Insert(l,r,x,rson,mid+1,now_r);
    }
    void dfs(int now,int now_l,int now_r)
    {
        if(now_l&gt;now_r) return;
        for(int i=0;i&lt;int(e[now].size());i++)
        {
            //cerr&lt;&lt;now_l&lt;&lt;" "&lt;&lt;now_r&lt;&lt;" "&lt;&lt; e[now][i]%(n+1)&lt;&lt;" "&lt;&lt;e[now][i]/(n+1)+1&lt;&lt;endl;
            unf.Link(e[now][i]%(n+1),e[now][i]/(n+1)+1);
        }
        if(now_l==now_r)
            ans[now_l]=unf.Query(op[now_l].s,op[now_l].t);
        else
        {
            dfs(lson,now_l,mid);
            dfs(rson,mid+1,now_r);
        }
        for(int i=0;i&lt;int(e[now].size());i++)
            unf.Undo();
    }
    #undef mid
    #undef lson
    #undef rson
}sgt;
int last[N*N];
int main()
{
    freopen("121.in","r",stdin);
    freopen("121.out","w",stdout);

    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
    {
        int top=read(),s=read(),t=read();
        if(top==0)
            last[GetID(s,t)]=q+1;
        else if(top==1)
        {
            op2[++p].s=last[GetID(s,t)],op2[p].t=q,op2[p].id=GetID(s,t);
            last[GetID(s,t)]=0;
        }
        else
            op[++q].s=s,op[q].t=t;
    }
    for(int i=1;i&lt;=(n+1)*(n+1);i++)
        if(last[i]!=0)
            op2[++p].s=last[i],op2[p].t=q,op2[p].id=i;

    for(int i=1;i&lt;=p;i++)
        if(op2[i].s&lt;=op2[i].t)
            sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,q);
    unf.Init();
    sgt.dfs(1,1,q);

    for(int i=1;i&lt;=q;i++)
        if(ans[i]==0)
            printf("N\n");
        else
            printf("Y\n");
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>366</wp:post_id>
		<wp:post_date><![CDATA[2019-03-22 03:38:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-22 03:38:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[loj-121-%e3%80%8c%e7%a6%bb%e7%ba%bf%e5%8f%af%e8%bf%87%e3%80%8d%e5%8a%a8%e6%80%81%e5%9b%be%e8%bf%9e%e9%80%9a%e6%80%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[525]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P5227] [AHOI2013] 连通图</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p5227-ahoi2013-%e8%bf%9e%e9%80%9a%e5%9b%be/</link>
		<pubDate>Fri, 22 Mar 2019 03:50:13 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=368</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P5227">P5227 [AHOI2013]连通图</a>

<hr />

<h1>Solution</h1>

这题可以离线，因此我们可以考虑用线段树分治维护动态图连通性来搞。

这题我们考虑离线下来搞。离线之后，我们会发现，<strong>某条边会在某些询问区间中出现。</strong>
考虑<strong>以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。</strong>
接下来，直接<strong>在线段树上跑dfs</strong>,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。
这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询任意节点的父亲的$size$是否为$n$即可。

因为我们这里有撤销（回溯）操作，因此必需使用**按秩合并的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。

时间复杂度$O(nlog^2n)$ 吗？
问题是这玩意能过啊.....
<del>因此，我们的时间复杂度是$O($能过$)$</del>

就酱，我们又切掉一道题啦。(ﾉﾟ∀ﾟ)ﾉ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P5227 [AHOI2013]连通图
//Mar,22ed,2019
//线段树分治离线维护动态图连通性
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;ctime&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int M=200000+100;
int n,m,q,p,ans[M];
struct UnF
{   
    int size[N],fa[N],mstack[M],top;
    void Init()
    {
        for(int i=1;i&lt;=n;i++)
            size[i]=1;
    }
    int FindFather(int x)
    {
        if(fa[x]==0) return x;
        return FindFather(fa[x]);
    }
    void Link(int x,int y)
    {
        mstack[++top]=0;
        int fa_x=FindFather(x),fa_y=FindFather(y);
        if(size[fa_x]&gt;size[fa_y]) 
            swap(x,y),swap(fa_x,fa_y);
        if(fa_x==fa_y) return;
        mstack[top]=fa_x;   
        fa[fa_x]=fa_y,size[fa_y]+=size[fa_x];
    }
    int Query()
    {
        if(size[FindFather(1)]==n) return true;
        return false;
    }
    void Undo()
    {
        if(mstack[top]==0)
        {
            top--;
            return;
        }
        size[fa[mstack[top]]]-=size[mstack[top]];
        fa[mstack[top]]=0;
        top--;
    }
}unf;
struct OP
{
    int s,t,id;
}op2[M*20],e[M];
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    vector &lt;int&gt; w[M&lt;&lt;2];
    void Insert(int l,int r,int x,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            w[now].push_back(x);
            return;
        }
        if(l&lt;=mid) Insert(l,r,x,lson,now_l,mid);
        if(r&gt;mid) Insert(l,r,x,rson,mid+1,now_r);
    }
    void dfs(int now,int now_l,int now_r)
    {
        if(now_l&gt;now_r) return;
        for(int i=0;i&lt;int(w[now].size());i++)
            unf.Link(e[w[now][i]].s,e[w[now][i]].t);
        if(now_l==now_r)
            ans[now_l]=unf.Query();
        else
        {
            dfs(lson,now_l,mid);
            dfs(rson,mid+1,now_r);
        }
        for(int i=0;i&lt;int(w[now].size());i++)
            unf.Undo();
    }
    #undef mid
    #undef lson
    #undef rson
}sgt;
int last[M],K;
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
        e[i].s=read(),e[i].t=read(),last[i]=1;
    K=read();
    for(int i=1;i&lt;=K;i++)
    {
        int c=read();
        for(int j=1;j&lt;=c;j++)
        {
            int x=read();
            op2[++p].s=last[x],op2[p].t=i-1,op2[p].id=x;
            last[x]=i+1;
        }
    }
    for(int i=1;i&lt;=m;i++)
        if(last[i]!=K+1)
            op2[++p].s=last[i],op2[p].t=K,op2[p].id=i;

    for(int i=1;i&lt;=p;i++)
        if(op2[i].s&lt;=op2[i].t)
        {
            sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,K);
            //cerr&lt;&lt;op2[i].s&lt;&lt;" "&lt;&lt;op2[i].t&lt;&lt;" "&lt;&lt;op2[i].id&lt;&lt;endl;
        }

    unf.Init();
    sgt.dfs(1,1,K);

    for(int i=1;i&lt;=K;i++)
        if(ans[i]==0)
            printf("Disconnected\n");
        else
            printf("Connected\n");
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>368</wp:post_id>
		<wp:post_date><![CDATA[2019-03-22 03:50:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-22 03:50:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p5227-ahoi2013-%e8%bf%9e%e9%80%9a%e5%9b%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[399]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4246] [SHOI2008]堵塞的交通</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p4246-shoi2008%e5%a0%b5%e5%a1%9e%e7%9a%84%e4%ba%a4%e9%80%9a/</link>
		<pubDate>Fri, 22 Mar 2019 04:04:18 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=370</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4246">P4246 [SHOI2008]堵塞的交通</a>

<hr />

<h1>Solution</h1>

<del>这题的确是有线段树上大分类讨论的在线做法</del>，但是本菜鸡还是想主要讲一下离线暴力做法。

这题我们考虑离线下来搞。离线之后，我们会发现，<strong>某条边会在某些询问区间中出现。</strong>
考虑<strong>以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。</strong>
接下来，直接<strong>在线段树上跑dfs</strong>,每到一个区间，就把这个区间里面存的边通通在并查集中连上；每完成一个区间，就把这个区间连上的边通通取消（类似于回溯）。
这样搞，我们每次到一个叶子节点的时候，这个叶子节点代表的询问上所要连的边一定已经全部连上了，直接在并查集中查询任意节点的父亲的$size$是否为$n$即可。

因为我们这里有撤销（回溯）操作，因此必需使用<strong>按秩合并</strong>的并查集。我们只需要开一个栈，把每次修改的fa的节点记录下来即可完成撤销的操作。

对于边和点，我们大力编号一下即可qwq。

时间复杂度$O(nlog^2n)$ 吗？
问题是这玩意能过啊.....
<del>因此，我们的时间复杂度是$O($能过$)$</del>

就酱，我们又切掉一道题啦。(ﾉﾟ∀ﾟ)ﾉ

<hr />

<h1>Code</h1>

<strong>数据生成器</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
using namespace std;
const int N=5;
const int M=25;
int main()
{
    srand(time(NULL));
    freopen("4246.in","w",stdout);

    int n=N;
    cout&lt;&lt;n&lt;&lt;endl;

    for(int i=1;i&lt;=M;i++)
    {
        int op=rand()%5;
        if(op==0 or op==1)
        {
            int x1=rand()%n+1,x2=rand()%n+1,y1=rand()%2+1,y2=rand()%2+1;
            cout&lt;&lt;"Ask "&lt;&lt;y1&lt;&lt;" "&lt;&lt;x1&lt;&lt;" "&lt;&lt;y2&lt;&lt;" "&lt;&lt;x2&lt;&lt;endl;
        }
        else
        {
            int x1=rand()%n+1,x2=rand()%n+1,y1=rand()%2+1,y2=rand()%2+1;
            while(1)
            {
                if(x1==x2 and abs(y2-y1)==1) break;
                if(y1==y2 and abs(x2-x1)==1) break;
                x2=rand()%n+1,y2=rand()%2+1;
            }
            if(op==2) cout&lt;&lt;"Close ";
            else cout&lt;&lt;"Open ";
            cout&lt;&lt;y1&lt;&lt;" "&lt;&lt;x1&lt;&lt;" "&lt;&lt;y2&lt;&lt;" "&lt;&lt;x2&lt;&lt;endl;
        }
    }

    cout&lt;&lt;"Exit";
    return 0;
}

</code></pre>

<strong>正解</strong>

<pre><code class="language-cpp line-numbers">//Luogu P4246 [SHOI2008]堵塞的交通
//Mar,22ed,2019
//线段树分治离线维护动态图连通性
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int M=N*4;
int ans[N];
struct UnF
{   
    int size[N],fa[N],mstack[M],top;
    void Init(int n)
    {
        for(int i=1;i&lt;=n;i++)
            size[i]=1;
    }
    int FindFather(int x)
    {
        if(fa[x]==0) return x;
        return FindFather(fa[x]);
    }
    void Link(int x,int y)
    {
        mstack[++top]=0;
        int fa_x=FindFather(x),fa_y=FindFather(y);
        if(size[fa_x]&gt;size[fa_y]) 
            swap(x,y),swap(fa_x,fa_y);
        if(fa_x==fa_y) return;
        mstack[top]=fa_x;   
        fa[fa_x]=fa_y,size[fa_y]+=size[fa_x];
    }
    int Query(int x,int y)
    {
        if(FindFather(x)==FindFather(y))
            return true; 
        return false;
    }
    void Undo()
    {
        if(mstack[top]==0)
        {
            top--;
            return;
        }
        size[fa[mstack[top]]]-=size[mstack[top]];
        fa[mstack[top]]=0;
        top--;
    }
}unf;
struct OP
{
    int s,t,id;
}op[N],op2[M*20],e[M];
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    vector &lt;int&gt; w[N&lt;&lt;2];
    void Insert(int l,int r,int x,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            w[now].push_back(x);
            return;
        }
        if(l&lt;=mid) Insert(l,r,x,lson,now_l,mid);
        if(r&gt;mid) Insert(l,r,x,rson,mid+1,now_r);
    }
    void dfs(int now,int now_l,int now_r)
    {
        if(now_l&gt;now_r) return;
        for(int i=0;i&lt;int(w[now].size());i++)
            unf.Link(e[w[now][i]].s,e[w[now][i]].t);
        if(now_l==now_r)
            ans[now_l]=unf.Query(op[now_l].s,op[now_l].t);
        else
        {
            dfs(lson,now_l,mid);
            dfs(rson,mid+1,now_r);
        }
        for(int i=0;i&lt;int(w[now].size());i++)
            unf.Undo();
    }
    #undef mid
    #undef lson
    #undef rson
}sgt;
int last[M],n,q,p;//q次询问,p个区间
bool w[3][N][3];
inline int GetID(int x,int y,int type)
{
    return ((y-1)*n+x-1)*3+type;
}
inline int GetID2(int x,int y)
{
    return (y-1)*n+x;
}
int main()
{
    freopen("4246.in","r",stdin);
    freopen("4246.out","w",stdout);

    n=read();
    char OP[10];
    while(1)
    {
        scanf("%s",OP+1);
        if(OP[1]=='E') break;
        else if(OP[1]=='O' or OP[1]=='C')
        {
            int y1=read(),x1=read(),y2=read(),x2=read(),type=1;
            if(OP[1]=='C') type=0;
            if(x1&gt;x2) swap(x1,x2),swap(y1,y2);
            if(y1&gt;y2) swap(x1,x2),swap(y1,y2);
            if(x2==x1+1)
            {
                if(w[y1][x1][0]==type) continue;
                w[y1][x1][0]=type;
                type=0;
            }
            else
            {
                if(w[y1][x1][2]==type) continue;
                w[y1][x1][2]=w[y2][x2][1]=type;
                type=2;
            }

            if(OP[1]=='O')
                last[GetID(x1,y1,type)]=q+1;
            else
            {
                op2[++p].s=last[GetID(x1,y1,type)],op2[p].t=q,op2[p].id=GetID(x1,y1,type);
                last[GetID(x1,y1,type)]=0;
            }
        }
        else
        {
            int y1=read(),x1=read(),y2=read(),x2=read();
            op[++q].s=GetID2(x1,y1),op[q].t=GetID2(x2,y2);
        }
    }
    for(int i=0;i&lt;=6*n+100;i++)
        if(last[i]!=0)
            op2[++p].s=last[i],op2[p].t=q,op2[p].id=i;

    for(int i=1;i&lt;=2;i++)
        for(int j=1;j&lt;=n;j++)
            for(int k=0;k&lt;=2;k++)
            {
                e[GetID(j,i,k)].s=GetID2(j,i);
                if(k==0) e[GetID(j,i,k)].t=GetID2(j+1,i);
                if(k==2) e[GetID(j,i,k)].t=GetID2(j,i+1);
            }
    unf.Init(n*2+1);
    for(int i=1;i&lt;=p;i++)
        if(op2[i].s&lt;=op2[i].t)
        {
            sgt.Insert(op2[i].s,op2[i].t,op2[i].id,1,1,q);
            cerr&lt;&lt;op2[i].s&lt;&lt;" "&lt;&lt;op2[i].t&lt;&lt;" "&lt;&lt;op2[i].id&lt;&lt;endl;
        }

    sgt.dfs(1,1,q);

    for(int i=1;i&lt;=q;i++)
        if(ans[i]==0)
            printf("N\n");
        else
            printf("Y\n");
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>370</wp:post_id>
		<wp:post_date><![CDATA[2019-03-22 04:04:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-22 04:04:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4246-shoi2008%e5%a0%b5%e5%a1%9e%e7%9a%84%e4%ba%a4%e9%80%9a]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[568]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[BZOJ 4025] 二分图</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/bzoj-4025-%e4%ba%8c%e5%88%86%e5%9b%be/</link>
		<pubDate>Mon, 25 Mar 2019 07:43:44 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=376</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4025">4025: 二分图</a>

<hr />

<h1>Solution</h1>

这种每条边出现在一段区间的题，我们可以先考虑使用线段树分治来搞。

这题我们考虑离线下来搞。离线之后，我们会发现，<strong>某条边会在某些询问区间中出现</strong>。
考虑<strong>以询问的编号为下标建线段树，我们把每一条边出现的时间段全部加到线段树里面去。</strong>

接下来，我们考虑如何维护一个图是否为二分图的问题。我们知道，一个图是二分图当且仅当<strong>这个图上所有的环的长度(点的个数)均为偶数</strong>。
知道这一点之后，我们考虑用并查集处理这个问题。对于没有环的时候，我们直接连上就好。对于有环的时候，我们就需要知道这两个点的距离是奇数还是偶数。如果是奇数的，说明之后无论在怎么连，这个图一定gg了，直到这条边取消位置；如果是偶数的，说明这个环是合法的，之后无论有什么边接到这个环上，我们当前这条新插入的边都不会有任何影响。因此，<strong>如果一条边会连城环，无论如何，这条边都不会被加上</strong>。

所以说，我们这里维护的东西是一个<strong>生成树</strong>。我们考虑用并查集维护这个生成树。因为我们这里是按秩合并的并查集，失去了原来的树的结构。<strong>因此，我们考虑在每个点上维护它到它的父亲的真实距离</strong>。我们在连接两个点的时候，我们在并查集上肯定是连接这两个点所在并查集的父亲。这时候，这两个父亲的真实距离一定为<strong>这两个点到父亲的真实距离和+1</strong>，(这里我们的真实距离和直接暴力算即可，因为并查集按秩合并时，高度不会太大)。

我们查询的时候我们算的是它们两个点到并查集的LCA的真实距离，因为并查集的LCA不一定是它们在原树中的LCA，因此我们这里按真实距离算出来的距离并非它们两的真实距离。<strong>但是，我们会发现这里多算的距离一定是2的倍数(两个点同时经过一条边)，因此，我们的奇偶性质还是正确的</strong>。

时间复杂度$O(nlog^2n)$
就酱，我们就可以切掉这道题啦ヾ(◍°∇°◍)ﾉﾞ

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//BZOJ 4025 二分图
//线段树二分+并查集妙题
//Mar,25th,2019
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
struct edge
{
    int s,t;
    edge (int x,int y)
    {
        s=x,t=y;
    }
};
struct UnF
{
    int fa[N],size[N],dis[N],depth[N],top,mstack[N*20];
    void Init(int n)
    {
        for(int i=1;i&lt;=n;i++)
            depth[i]=size[i]=1;
    }
    int GetFa(int x,int &amp;w)
    {
        if(fa[x]==0) 
        {
            w++;
            return x;
        }
        int t=GetFa(fa[x],w+=dis[x]+1);
        depth[x]=depth[fa[x]]+1;
        return t;
    }
    int LCA(int x,int y,int &amp;w)
    {
        w=1;
        if(depth[x]&lt;depth[y]) swap(x,y);
        while(depth[x]&gt;depth[y])
            w+=dis[x]+1,x=fa[x];
        if(x==y) return x;
        w++;
        while(fa[x]!=fa[y])
        {
            w+=dis[x]+1,w+=dis[y]+1;
            x=fa[x],y=fa[y];
        }
        w+=dis[x]+dis[y]+1;
        return fa[x];
    }
    int Link(int x,int y)
    {
        int d1=0,d2=0,fa1=GetFa(x,d1),fa2=GetFa(y,d2);
        if(size[fa1]&gt;size[fa2])
            swap(x,y),swap(fa1,fa2),swap(d1,d2);
        mstack[++top]=0;
        //cerr&lt;&lt;fa1&lt;&lt;" "&lt;&lt;fa2&lt;&lt;" "&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;" "&lt;&lt;d1&lt;&lt;" "&lt;&lt;d2&lt;&lt;endl;
        if(fa1==fa2)
        {
            int t_d=0;
            LCA(x,y,t_d);
            if(t_d%2==1)
                return 1;
            return 0;
        }
        mstack[top]=fa1;
        dis[fa1]=d1+d2-2,fa[fa1]=fa2,size[fa2]+=size[fa1];
        return 0;
    }
    void Undo()
    {
        if(mstack[top]!=0)
            size[fa[mstack[top]]]-=size[mstack[top]],fa[mstack[top]]=0,
            dis[mstack[top]]=0,depth[mstack[top]]=1;
        top--;
    }
}unf;
int ans[N],top,OK;
struct SegmentTree
{
    #define mid ((now_l+now_r)&gt;&gt;1)
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    vector &lt;edge&gt; w[N&lt;&lt;2];
    void Add(int l,int r,edge x,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
        {
            w[now].push_back(x);
            return;
        }
        if(l&lt;=mid) Add(l,r,x,lson,now_l,mid);
        if(r&gt;mid) Add(l,r,x,rson,mid+1,now_r);
    }
    void dfs(int now,int now_l,int now_r)
    {
        int cnt=0;
        for(int i=0;i&lt;int(w[now].size());i++)
            cnt+=unf.Link(w[now][i].s,w[now][i].t);
        OK+=cnt;
        //cerr&lt;&lt;endl;
        //cerr&lt;&lt;now&lt;&lt;" "&lt;&lt;now_l&lt;&lt;" "&lt;&lt;now_r&lt;&lt;" "&lt;&lt;cnt&lt;&lt;endl;
        if(now_l==now_r)
            ans[now_l]=OK;
        else
        {
            dfs(lson,now_l,mid);
            dfs(rson,mid+1,now_r);
        }
        OK-=cnt;
        for(int i=0;i&lt;int(w[now].size());i++)
            unf.Undo();
    }
    #undef mid
    #undef lson
    #undef rson
}sgt;
int n,m,q;
int main()
{
    n=read(),m=read(),q=read();
    unf.Init(n);
    for(int i=1;i&lt;=m;i++)
    {
        int u=read(),v=read(),s=read(),t=read();
        sgt.Add(s+1,t,edge(u,v),1,1,q);
    }
     
    sgt.dfs(1,1,q);
     
    for(int i=1;i&lt;=q;i++)
        if(ans[i]==0)
            printf("Yes\n");
        else
            printf("No\n");
    return 0;
}
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>376</wp:post_id>
		<wp:post_date><![CDATA[2019-03-25 07:43:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-25 07:43:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[bzoj-4025-%e4%ba%8c%e5%88%86%e5%9b%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[328]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3810] 【模板】三维偏序（陌上花开）</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3810-%e3%80%90%e6%a8%a1%e6%9d%bf%e3%80%91%e4%b8%89%e7%bb%b4%e5%81%8f%e5%ba%8f%ef%bc%88%e9%99%8c%e4%b8%8a%e8%8a%b1%e5%bc%80%ef%bc%89/</link>
		<pubDate>Wed, 27 Mar 2019 07:11:54 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=386</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3810">P3810 【模板】三维偏序（陌上花开）</a>

<hr />

<h1>Solution</h1>

这是一道CDQ分治的模板题。

题目要我们求的是$(a,b,c)$这样的三维“顺序对”的数量。
<strong>考虑我们把所有的数按照以$a$为第一关键字，以$b$为第二关键字，以$c$为第三关键字来排序。</strong>
这样子，我们就可以保证<strong>有可能与某个数形成“顺序对”的数一定在它的左边</strong>。

我们都知道，归并排序能用来求逆序对的数量，在这里，也能用类似的方法来求“顺序对”的数量。
接下来我们考虑对这个排好序的序列做<strong>以$b$为关键字的类似于归并排序的操作</strong>。
这里我们要排序的是$[1,n]$这一整个序列，我们要递归下去做，假设我们现在已经求出了$[1,mid]$与$[mid+1,n]$这两个区间内部的“顺序对”的数量，现在我们考虑求出跨越两个区间的顺序对。<strong>因为我们归并排序前已经按照$a$排序过了，所以这里有且只有可能右边块的数会与左边块的数会形成“顺序对”。</strong>
接下来，我们考虑维护左右两个块两个指针，<strong>保证右边块当前看的数的$b$比左边指针扫到的所有的数的$b$都大。</strong>这时候，<strong>我们只需要找到左边扫到的数的$c$有多少个比当前扫到的数的$c$小。</strong>这个东西我们用一个树状数组/线段树直接维护即可。

最后我们以$b$为关键字排序这两个区间，递归回去继续做即可。
注意一点细节：有可能会有几个元素的$(a,b,c)$全部相等，我们在刚刚的计算中是不会算到它们的相互影响的。对于这种情况，我们要提前为他们算上内部的影响，然后去重做即可。

在这里，我们在第二维上做的类似于归并排序的操作即为CDQ分治。

时间复杂度$O(nlog^2n)$
就酱，我们又切掉一道题啦(๑¯∀¯๑)

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P3810 【模板】三维偏序（陌上花开） 
//Mar,26th,2019
//CDQ分治+线段树+排序维护三维偏序
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int M=200000+100;
struct node
{
    int x,y,z,no,ans;
    friend bool operator == (node a,node b)
    {
        return (a.x==b.x and a.y==b.y and a.z==b.z);
    }
}nd[N];
bool cmp(node a,node b)
{
    if(a.x==b.x)
    {
        if(a.y==b.y)
            return a.z&lt;b.z;
        return a.y&lt;b.y;
    }
    return a.x&lt;b.x;
}
bool cmp2(node a,node b)
{
    if(a.y==b.y) return a.z&lt;b.z;
    return a.y&lt;b.y;
}
struct SegmentTree
{
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    #define mid ((now_l+now_r)&gt;&gt;1)
    int sum[M&lt;&lt;2];
    inline void update(int now)
    {
        sum[now]=sum[lson]+sum[rson];
    }
    void Add(int x,int v,int now,int now_l,int now_r)
    {
        if(now_l==now_r)
        {
            sum[now]+=v;
            return ;
        }
        if(x&lt;=mid)  Add(x,v,lson,now_l,mid);
        else Add(x,v,rson,mid+1,now_r);
        update(now);
    }
    int Query(int l,int r,int now,int now_l,int now_r)
    {
        if(now_l&gt;=l and now_r&lt;=r)
            return sum[now];
        int t_ans=0;
        if(l&lt;=mid) t_ans+=Query(l,r,lson,now_l,mid);
        if(r&gt;mid) t_ans+=Query(l,r,rson,mid+1,now_r);
        return t_ans;
    }
    #undef lson
    #undef rson
    #undef mid
}sgt;
int n,m,K,belong[N],cnt[N],ans[N],cnt_belong,ans2[N];
void CDQ(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)/2;
    CDQ(l,mid);
    CDQ(mid+1,r);

    int ptl=l;
    for(int i=mid+1;i&lt;=r;i++)
    {
        for(;nd[ptl].y&lt;=nd[i].y and ptl&lt;=mid;ptl++)
            sgt.Add(nd[ptl].z,cnt[nd[ptl].no],1,0,K);
        ans[nd[i].no]+=sgt.Query(0,nd[i].z,1,0,K);
    }
    ptl=l;
    for(int i=mid+1;i&lt;=r;i++)
        for(;nd[ptl].y&lt;=nd[i].y and ptl&lt;=mid;ptl++)
            sgt.Add(nd[ptl].z,-cnt[nd[ptl].no],1,0,K);

    sort(nd+l,nd+r+1,cmp2);
}
int main()
{
    n=read(),K=read();
    for(int i=1;i&lt;=n;i++)
        nd[i].x=read(),nd[i].y=read(),nd[i].z=read(),nd[i].no=i;

    sort(nd+1,nd+1+n,cmp);
    for(int i=1;i&lt;=n;i++)
        if(nd[i]==nd[i-1])
            cnt[cnt_belong]++,belong[nd[i].no]=cnt_belong;
        else
            cnt[++cnt_belong]++,belong[nd[i].no]=cnt_belong;
    for(int i=1;i&lt;=cnt_belong;i++)
        ans[i]+=cnt[i]-1;
    m=unique(nd+1,nd+1+n)-nd-1;
    for(int i=1;i&lt;=m;i++)
        nd[i].no=i;

    CDQ(1,m);

    for(int i=1;i&lt;=n;i++)
        ans2[ans[belong[i]]]++;
    for(int i=0;i&lt;n;i++)
        printf("%d\n",ans2[i]);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>386</wp:post_id>
		<wp:post_date><![CDATA[2019-03-27 07:11:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-27 07:11:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3810-%e3%80%90%e6%a8%a1%e6%9d%bf%e3%80%91%e4%b8%89%e7%bb%b4%e5%81%8f%e5%ba%8f%ef%bc%88%e9%99%8c%e4%b8%8a%e8%8a%b1%e5%bc%80%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="cdq%e5%88%86%e6%b2%bb"><![CDATA[CDQ分治]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[540]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3527] [POI2011]MET-Meteors</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3527-poi2011met-meteors/</link>
		<pubDate>Wed, 27 Mar 2019 07:38:06 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=389</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3527">P3527 [POI2011]MET-Meteors</a>

<hr />

<h1>Solution</h1>

<del>我是一直奉行坚决不写树状数组只写线段树理论的，直到这题.......</del>
这题是一道整体二分的模板题。

首先，我们考虑只有一个国家的情况。<del>这不SB问题么</del>
我们可以二分一个答案，然后我们用线段树暴力模拟，暴力Check,复杂度$O(mlogn)$。
显然，如果我们每一个国家都这么搞一轮，复杂度达到了惊人的$O(n\cdot m logn)$，这显然是要T飞的。

因此，我们就得请出伟大的整体二分了。整体二分，顾名思义，就是把所有询问一起二分答案。
考虑这样做，一开始，所有询问的答案均在$1,m+1$这个范围内(+1是为了方便判断不可行的情况)。接下来，我们二分一个$mid$，然后把所有答案$&lt;=mid$的询问丢到$1,mid$区间，把所有在mid时间内不能完成的询问丢到右区间。
怎么判断一个询问是否能在mid时间内完成呢？暴力啊。我们直接用线段树暴力做个mid次修改，然后再暴力看每个国家是否满足即可。
接下来，我们只需要把这个东西递归下去做，直到区间长度为$1$为止。

什么你说，这玩意复杂度很大？的确很大，$O(nlog^2n)$呢。
怎么证呢？显然，我们发现这个递归最多log层，每层我们会把所有的修改操作都会做一遍，因此总复杂度两个log。

再给一个参考数据，30w数据下，2个log算出来的东西接近两个亿。好了，我想你知道了要写什么数据结构了.......
啥？所以说你还是义无反馈的写了线段树？<a href="https://www.luogu.org/problemnew/show/U66611">来试试在这里交吧</a>,可以检验你的程序的正确性<del>（以及究竟要跑个多久）</del>。

就酱，我们就把这题给切掉啦(～￣▽￣)～ 
<del>你很有可能被卡常及卡空间，当然，这就是后话了</del>

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P3527 [POI2011]MET-Meteors
//Mar,27th,2019
//整体二分+树状数组
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;ctime&gt;
using namespace std;
int read()
{
    int x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=300000+100;
const int inf=0x3f3f3f3f;
int n,m,K,ans[N],w[N];//w[i]第i个国家需要多少个陨石
struct BIT
{
    long long t[N&lt;&lt;2];
    inline int lowbit(int &amp;x){return x&amp;(-x);}
    void Init()
    {
        memset(t,0,sizeof t);
    }
    long long Query(int x)
    {
        long long sum=0;
        while(x&gt;0)
        {
            sum+=t[x];
            x-=lowbit(x);
        }
        return sum;
    }
    void update(int x,int dlt)
    {
        while(x&lt;=m)
        {   
            t[x]+=dlt;
            x+=lowbit(x);
        }
    }
    void Change(int l,int r,int w)
    {
        update(r+1,-w);
        update(l,w);
    }
}bit;
struct OP
{
    int l,r,w;
}op[N];
vector &lt;int&gt; a[N];
struct DL
{
    int l,r;
    vector &lt;int&gt; c;
}mqueue[N+5000];
int main()
{
    //int t=clock();
    //freopen("3527.in","r",stdin);
    //freopen("3527.out","w",stdout);

    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
        a[read()].push_back(i);
    for(int i=1;i&lt;=n;i++)
        w[i]=read();
    K=read();
    for(int i=1;i&lt;=K;i++)
        op[i].l=read(),op[i].r=read(),op[i].w=read();

    int front=0,tail=0,T=1;//T:当前执行到了T时刻
    mqueue[tail].l=1,mqueue[tail].r=K+1;
    for(int i=1;i&lt;=n;i++)
        mqueue[tail].c.push_back(i);
    tail++;
    while(tail!=front)
    {
        if(mqueue[front].l==mqueue[front].r)
        {
            for(int i=0;i&lt;int(mqueue[front].c.size());i++)
                ans[mqueue[front].c[i]]=mqueue[front].l;
            front=(front+1)%(K+5000);
            continue;
        }
        int mid=(mqueue[front].l+mqueue[front].r)/2;
        if(T&gt;mid)
            T=1,bit.Init();
        for(;T&lt;=mid;T++)
            if(op[T].l&lt;=op[T].r)
                bit.Change(op[T].l,op[T].r,op[T].w);
            else
                bit.Change(op[T].l,m,op[T].w),
                bit.Change(1,op[T].r,op[T].w);
        vector &lt;int&gt; l,r;
        for(int i=0;i&lt;int(mqueue[front].c.size());i++)
        {
            long long t_ans=0,now=mqueue[front].c[i];
            for(int j=0;j&lt;int(a[now].size());j++)
            {
                t_ans+=bit.Query(a[now][j]);
                if(t_ans&gt;inf) break;
            }
            if(t_ans&gt;=w[now])
                l.push_back(now);
            else
                r.push_back(now);
        }
        mqueue[tail].l=mqueue[front].l,mqueue[tail].r=mid,mqueue[tail++].c=l;
        tail%=(K+5000);
        mqueue[tail].l=mid+1,mqueue[tail].r=mqueue[front].r,mqueue[tail++].c=r;
        tail%=(K+5000);
        front=(front+1)%(K+5000);
    }

    for(int i=1;i&lt;=n;i++)
        if(ans[i]==K+1)
            printf("NIE\n");
        else
            printf("%d\n",ans[i]);
    //cerr&lt;&lt;clock()-t&lt;&lt;endl;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>389</wp:post_id>
		<wp:post_date><![CDATA[2019-03-27 07:38:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-27 07:38:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3527-poi2011met-meteors]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86"><![CDATA[整体二分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[319]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3332][ZJOI2013]K大数查询</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p3332zjoi2013k%e5%a4%a7%e6%95%b0%e6%9f%a5%e8%af%a2/</link>
		<pubDate>Wed, 27 Mar 2019 07:55:12 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=391</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3332">P3332 [ZJOI2013]K大数查询</a>

<hr />

<h1>Solution</h1>

这是一道不辣么模板的整体二分题。

首先，我们先来假设一下只有一个询问应该怎么搞。
考虑这样做：我们先二分一个答案，修改中，如果所要修改的数大于mid，则在这段区间中每个数加上1。否则什么都不做。这样一来，最后我们只需要看一下询问的区间的区间和是否大于$K$即可。

接下来，我们考虑如何把所有询问一起来二分。
同样还是二分一个答案，把所有答案大于mid的询问丢到右边，其余丢到左边即可。
接下来，我们可以显然发现对于右边的区间，<strong>所有修改$&lt;=mid$的修改都是没有意义的。因此，我们考虑把所有$&lt;=mid$的修改放在右边，其余的放在左边</strong>。显然，<strong>对于左边所有的询问，$>=mid$的修改一定会对左边造成影响，因此还要把所有在左边的询问减上对应的值</strong>（在这个询问之前所有的操作对它产生的1的数量）。

对于询问和修改的顺序问题：我们分别保证询问与修改按照时间有序，用两个指针分开处理，每次询问之前把在它之前的修改全部做了即可。这样就可以保证时间合法。

时间复杂度$O(nlog^2n)$
就酱，我们又切掉一道题啦(ﾉ≧∀≦)ﾉ

<hr />

<h1>Code</h1>

<strong>数据生成器</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
using namespace std;
const int N=500;
const int NUM=1000;
int cnt[N+5];
int main()
{
    srand(time(NULL));
    freopen("3332.in","w",stdout);

    int n=N,m=N;
    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
    for(int i=1;i&lt;=m;i++)
    {
        int op=rand()%2,a=rand()%n+1,b=rand()%n+1,c=rand()%NUM+1;
        if(a&gt;b) swap(a,b);
        if(op==1)
        {
            cout&lt;&lt;op&lt;&lt;" "&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
            for(int j=a;j&lt;=b;j++)
                cnt[j]++;
        }
        else
        {
            int mtot=0;
            for(int j=a;j&lt;=b;j++)
                mtot+=cnt[j];
            if(mtot==0)
            {
                i--;
                continue;
            }   
            c=rand()%mtot+1;
            cout&lt;&lt;"2"&lt;&lt;" "&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
        }
    }
    return 0;
}

</code></pre>

<strong>正解</strong>

<pre><code class="language-cpp line-numbers">//Luogu P3332 [ZJOI2013]K大数查询 
//Mar,27th,2019
//整体二分+线段树
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=50000+100;
struct SegmentTree
{
    #define lson (now&lt;&lt;1)
    #define rson (now&lt;&lt;1|1)
    #define mid ((now_l+now_r)&gt;&gt;1)
    long long sum[N&lt;&lt;2];
    int lazy[N&lt;&lt;2];
    inline void update(int now)
    {
        sum[now]=sum[lson]+sum[rson];
    }
    inline void pushdown(int now,int now_l,int now_r)
    {
        if(now_l!=now_r)
        {
            sum[lson]+=lazy[now]*(mid-now_l+1),sum[rson]+=lazy[now]*(now_r-mid);
            lazy[lson]+=lazy[now],lazy[rson]+=lazy[now];
        }
        lazy[now]=0;
    }
    void Change(int l,int r,int w,int now,int now_l,int now_r)
    {
        pushdown(now,now_l,now_r);
        if(now_l&gt;=l and now_r&lt;=r)
        {
            lazy[now]=w,sum[now]+=1ll*w*(now_r-now_l+1);
            return;
        }
        if(l&lt;=mid) Change(l,r,w,lson,now_l,mid);
        if(r&gt;mid) Change(l,r,w,rson,mid+1,now_r);
        update(now);
    }
    long long Query(int l,int r,int now,int now_l,int now_r)
    {
        pushdown(now,now_l,now_r);
        if(now_l&gt;=l and now_r&lt;=r)
            return sum[now];
        long long t_ans=0;
        if(l&lt;=mid) t_ans+=Query(l,r,lson,now_l,mid);
        if(r&gt;mid) t_ans+=Query(l,r,rson,mid+1,now_r);
        return t_ans;
    }
    #undef lson
    #undef rson
    #undef mid
}sgt;
struct OP
{
    int l,r,no;
    long long w;
}op1[N],op2[N];//op1:询问，op2:修改
struct DL
{
    int l,r;
    vector &lt;OP&gt; op,qur;
}mqueue[2*N];
int n,m,q,p,K=2*N-20;//q:询问，p:修改
int ans[N];
int main()
{
    freopen("3332.in","r",stdin);
    freopen("3332.out","w",stdout);

    n=read(),m=read();
    for(int i=1;i&lt;=m;i++)
    {
        int op=read();
        if(op==1)
            op2[++p].l=read(),op2[p].r=read(),op2[p].w=read(),op2[p].no=i;
        else
            op1[++q].l=read(),op1[q].r=read(),op1[q].w=read(),op1[q].no=i;
    }

    int front=0,tail=0;
    mqueue[tail].l=-N,mqueue[tail].r=N;
    for(int i=1;i&lt;=p;i++)
        mqueue[tail].op.push_back(op2[i]);
    for(int i=1;i&lt;=q;i++)
        mqueue[tail].qur.push_back(op1[i]);
    tail++;
    memset(ans,0x3f,sizeof ans);

    while(front!=tail)
    {
        //cerr&lt;&lt;front&lt;&lt;" "&lt;&lt;tail&lt;&lt;" "&lt;&lt;mqueue[front].l&lt;&lt;" "&lt;&lt;mqueue[front].r&lt;&lt;endl;
        if(mqueue[front].l==mqueue[front].r)
        {
            for(int i=0;i&lt;int(mqueue[front].qur.size());i++)
                ans[mqueue[front].qur[i].no]=mqueue[front].l;
        }
        else if(mqueue[front].qur.size()&gt;0)
        {
            int mid=int(floor((mqueue[front].l+mqueue[front].r)/2.0)),T=0;
            DL L,R;
            for(int i=0;i&lt;int(mqueue[front].qur.size());i++)
            {
                for(;T&lt;int(mqueue[front].op.size()) and mqueue[front].qur[i].no&gt;mqueue[front].op[T].no;T++)
                {
                    sgt.Change(mqueue[front].op[T].l,mqueue[front].op[T].r,mqueue[front].op[T].w&gt;mid,1,1,n);
                    if(mqueue[front].op[T].w&gt;mid)
                        R.op.push_back(mqueue[front].op[T]);
                    else
                        L.op.push_back(mqueue[front].op[T]);
                }
                long long t=sgt.Query(mqueue[front].qur[i].l,mqueue[front].qur[i].r,1,1,n);
                if(t&gt;=mqueue[front].qur[i].w)
                    R.qur.push_back(mqueue[front].qur[i]);
                else
                {
                    mqueue[front].qur[i].w-=t;
                    L.qur.push_back(mqueue[front].qur[i]);
                }
            }
            for(int i=0;i&lt;T;i++)
                sgt.Change(mqueue[front].op[i].l,mqueue[front].op[i].r,-(mqueue[front].op[i].w&gt;mid),1,1,n);
            L.l=mqueue[front].l,L.r=mid;
            R.l=mid+1,R.r=mqueue[front].r;
            mqueue[tail]=L,tail=(tail+1)%K;
            mqueue[tail]=R,tail=(tail+1)%K;
        }
        front=(front+1)%K;
    }

    for(int i=1;i&lt;=m;i++)
        if(ans[i]!=0x3f3f3f3f)
            printf("%d\n",ans[i]);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>391</wp:post_id>
		<wp:post_date><![CDATA[2019-03-27 07:55:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-27 07:55:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3332zjoi2013k%e5%a4%a7%e6%95%b0%e6%9f%a5%e8%af%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86"><![CDATA[整体二分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[435]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4438] [HNOI/AHOI2018]道路</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p4438-hnoi-ahoi2018%e9%81%93%e8%b7%af/</link>
		<pubDate>Thu, 28 Mar 2019 07:28:09 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=394</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4438">4438 [HNOI/AHOI2018]道路</a>

<hr />

<h1>Solution</h1>

这是一道树形DP妙题。

平时，我们设计树形DP的状态一般都是以子树为基础来设计的。很不幸的是，这题因为那个蜜汁柿子无法化简，导致了极其严重的后效性。因此，我们这里并不能以子树为基础来设计状态了。

这题妙就妙在这个状态设计。这题我们考虑以链为基础来设计状态。
<strong>设$f[i][j][k]$表示从根节点到达第$i$个点，一路上经过了$j$条没有修过的公路及$k$条没有修过的铁路，把它的孩子全部连同到根所需的最小代价</strong>。
这样一来，我们惊讶的发现这样设就没有后效性问题，因为链的状态已经被我们包含在DP的状态里了。

转移非常简单，我们只需要<strong>讨论一下是这个点是修铁路还是公路就好。</strong>
即：$f[i][j][k]=min(f[lson][j][k]+f[rson][j][k+1],f[lson][j+1][k],f[rson][j][k])$

但是这样做还有一个问题，就是我们的空间复杂度是$O(n\cdot40\cdot40)$的，开不下。
仔细观察后可以发现我们上面开辣么大的数组，很多地方是用不到的。因此，我们可以考虑只记录一个映射，然后把值记到一个统一的一维数组里面去。

时间复杂度$O(n\cdot 40 \cdot 40)$
就酱，这题就被我们切掉啦(～￣▽￣)～

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P4438 [HNOI/AHOI2018]道路
//Mar,27th,2019
//你从未见过的船新树形DP
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=20000*2+200;
const int M=40+3;
const long long inf=0x3f3f3f3f3f3f3f3fll;
int f[N][M][M],a[N],b[N],c[N];
long long ans[20000000];
int n,s[N],t[N],to;
long long dfs(int now,long long cnt_s,long long cnt_t)
{
    if(f[now][cnt_s][cnt_t]!=0) 
        return ans[f[now][cnt_s][cnt_t]];
    f[now][cnt_s][cnt_t]=++to;
    if(now&gt;=n)
        return ans[f[now][cnt_s][cnt_t]]=c[now]*(a[now]+cnt_s)*(b[now]+cnt_t);
    long long t_ans=inf;
    t_ans=dfs(s[now],cnt_s,cnt_t)+dfs(t[now],cnt_s,cnt_t+1);
    t_ans=min(t_ans,dfs(s[now],cnt_s+1,cnt_t)+dfs(t[now],cnt_s,cnt_t));
    return ans[f[now][cnt_s][cnt_t]]=t_ans;
}
int main()
{
    n=read();
    for(int i=1;i&lt;n;i++)
    {
        s[i]=read(),t[i]=read();
        if(s[i]&lt;0) s[i]=-s[i]+n-1;
        if(t[i]&lt;0) t[i]=-t[i]+n-1;
    }
    for(int i=1;i&lt;=n;i++)
        a[i+n-1]=read(),b[i+n-1]=read(),c[i+n-1]=read();

    //int tim=clock();

    printf("%lld",dfs(1,0,0));
    //cerr&lt;&lt;endl&lt;&lt;clock()-tim;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>394</wp:post_id>
		<wp:post_date><![CDATA[2019-03-28 07:28:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-28 07:28:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4438-hnoi-ahoi2018%e9%81%93%e8%b7%af]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%bd%a2dp"><![CDATA[树形DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[742]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>61</wp:comment_id>
			<wp:comment_author><![CDATA[一刀]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2158551174@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[60.12.177.108]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-07-17 11:58:38]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-07-17 11:58:38]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主，博主，你代码的计算时间没有注释掉哦，而且在运行的时候没有ctime库哦 ヾ(´･ ･｀｡)ノ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>62</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-07-22 00:19:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-07-22 00:19:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[哇....很抱歉，刚刚才看到。

运行时没有ctime库的确是不严谨.....但是最新的编译器也能无warning编译过嘛....所以说应该是有某个头文件已经包括有了

总之，肥肠感谢您的指点。 
:huaji6:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>61</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P4297] [NOI2006]网络收费</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p4297-noi2006%e7%bd%91%e7%bb%9c%e6%94%b6%e8%b4%b9/</link>
		<pubDate>Fri, 29 Mar 2019 00:03:37 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=396</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4297">P4297 [NOI2006]网络收费 </a>

<hr />

<h1>Solution</h1>

这题喵啊。

首先，我们会发现统计两个点互相的贡献是一个极其困难的问题。
但是，仔细观察那张收费表格后会发现，我们可以重新定义一下这个收费：<strong>我们假设路由器节点的颜色为叶子中数目较多的颜色，当一个叶子结点颜色与路由器节点颜色相同的时候不收钱，否则收一份钱。</strong>我们可以惊讶的发现，这样做之后我们的新收费做法就与原来题目要求的重合了，而且<strong>贡献由点对转到了点上</strong>。

接下来，我们就可以统计每个叶子节点对每个路由器产生的贡献了。<strong>我们设$F[i][j]$表示第$i$个叶子节点在LCA为$j$情况下产生的贡献。</strong>这个非常好搞，我们只需要枚举点对+计算LCA即可，复杂度$O(n^2logn)$

我们会发现一个问题，一个叶子节点的贡献值与它到根路径上所有的路由器的颜色息息相关。因此，我们传统的基于子树的树形DP做法已经行不通了，我们现在需要一个基于某个点到根路径的DP做法。
考虑：<strong>设$f[i][j][k]$表示目前填到了第$i$个点，它到根的路径一路上的颜色为$j$(状压形式表现),它的孩子(叶子节点)要填$k$个颜色B。</strong>
转移非常简单，对于路由器节点，我们只需要像背包一样枚举左右孩子分别分配多少个颜色B即可；对于叶子节点，我们只需要直接一路算上去它的贡献即可。

但是我们会发现一个问题，这样子我们直接设的空间复杂度是$O(2^{3n})$的，并开不下。
我们观察后发现，对于任何一个节点，假设它的深度为$k$,那么，它的叶子节点最多有$2^{(n-k)}$个，它到父亲的距离的情况最多有$2^k$种。<strong>因此，我们发现这两位的状态可以直接压在一起（即放到一起存储，需要时再分开），空间复杂度就可以优化至$O(2^{2n})$</strong>,可以通过这一题。

时间复杂度$O(2^{2n}\cdot n)$
就酱，这题就被我们切掉啦=￣ω￣=

<hr />

<h1>Code</h1>

<strong>数据生成器</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int N=4;
const int MAX=5000;
int main()
{
    srand(time(NULL));
    freopen("4297.in","w",stdout);

    int n=N,m=1&lt;&lt;n;
    cout&lt;&lt;n&lt;&lt;endl;

    for(int i=1;i&lt;=m;i++)
        cout&lt;&lt;rand()%2&lt;&lt;" ";
    cout&lt;&lt;endl;
    for(int i=1;i&lt;=m;i++)
        cout&lt;&lt;rand()%MAX+1&lt;&lt;" ";
    cout&lt;&lt;endl;

    for(int i=1;i&lt;=m;i++)
    {
        for(int j=i+1;j&lt;=m;j++)
            cout&lt;&lt;rand()%MAX+1&lt;&lt;" ";  
        cout&lt;&lt;endl;
    }
    return 0;
}

</code></pre>

<strong>正解</strong>

<pre><code class="language-cpp line-numbers">//Luogu P4297 [NOI2006]网络收费
//Mar,28th,2019
//树形DP+状压DP妙题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2100;
const long long inf=0x3f3f3f3f3f3f3f3fll;
int n,m,a[N],c[N],w[N][N];
long long F[N][N],depth[N],fa[N][21];//F[i][j]:i在LCA=j的时候的贡献
void dfs(int now)
{
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    if(now&lt;(1&lt;&lt;n))
    {
        fa[now*2][0]=now,depth[now*2]=depth[now]+1,dfs(now*2);
        fa[now*2+1][0]=now,depth[now*2+1]=depth[now]+1,dfs(now*2+1);
    }
}
int LCA(int x,int y)
{
    if(depth[y]&gt;depth[x]) swap(x,y);
    for(int i=20;i&gt;=0;i--)
        if(depth[x]-(1&lt;&lt;i)&gt;=depth[y])
            x=fa[x][i];
    if(x==y) return x;
    for(int i=20;i&gt;=0;i--)
        if(fa[x][i]!=fa[y][i])
            x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
long long f[N][N*2];
long long dfs2(int now,int K)
{
    if(f[now][K]!=0) return f[now][K];
    int c_now=0,cnt_B=K/(1&lt;&lt;depth[now]),cnt_A=(1&lt;&lt;(n-depth[now]))-cnt_B;
    if(cnt_B&lt;0 or cnt_A&lt;0) return f[now][K]=inf;
    if(cnt_B&gt;cnt_A) c_now=1;
    if(now&gt;=(1&lt;&lt;n))
    {
        int tmp=K%(1&lt;&lt;depth[now]),t_now=now/2;
        for(;t_now&gt;0;t_now/=2,tmp/=2)
            f[now][K]+=(c_now!=(tmp%2))*F[now][t_now];
        f[now][K]+=c[now]*(a[now]!=c_now);
        return f[now][K];
    }
    long long t_ans=inf;
    for(int i=0;i&lt;=cnt_B;i++)
    {
        long long L=dfs2(now*2,((K%(1&lt;&lt;depth[now]))&lt;&lt;1)+c_now+i*(1&lt;&lt;depth[now*2]));
        long long R=dfs2(now*2+1,((K%(1&lt;&lt;depth[now]))&lt;&lt;1)+c_now+(cnt_B-i)*(1&lt;&lt;depth[now*2+1]));
        t_ans=min(t_ans,L+R);
    }
    return f[now][K]=t_ans;
}
int main()
{
    n=read();
    m=(1&lt;&lt;(n+1))-1;
    for(int i=(1&lt;&lt;n);i&lt;=m;i++)
        a[i]=read();
    for(int i=(1&lt;&lt;n);i&lt;=m;i++)
        c[i]=read();
    for(int i=(1&lt;&lt;n);i&lt;=m;i++)
        for(int j=i+1;j&lt;=m;j++)
            w[i][j]=w[j][i]=read();

    dfs(1);
    for(int i=(1&lt;&lt;n);i&lt;=m;i++)
        for(int j=i+1;j&lt;=m;j++)
            F[i][LCA(i,j)]+=w[i][j],
            F[j][LCA(i,j)]+=w[i][j];

    long long ans=inf;
    for(int i=0;i&lt;=(1&lt;&lt;n);i++)
        ans=min(ans,dfs2(1,i));

    printf("%lld",ans);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>396</wp:post_id>
		<wp:post_date><![CDATA[2019-03-29 00:03:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-03-29 00:03:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4297-noi2006%e7%bd%91%e7%bb%9c%e6%94%b6%e8%b4%b9]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%bd%a2dp"><![CDATA[树形DP]]></category>
		<category domain="category" nicename="%e7%8a%b6%e5%8e%8bdp"><![CDATA[状压DP]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[402]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3233] [HNOI2014]世界树</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p3233-hnoi2014%e4%b8%96%e7%95%8c%e6%a0%91/</link>
		<pubDate>Mon, 01 Apr 2019 01:09:42 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=401</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3233">P3233 [HNOI2014]世界树</a>

<hr />

<h1>Solution</h1>

这是一道虚树妙题。

我们不妨先考虑一下每一次$O(n)$计算的暴力怎么做。
$O(n\cdot m)$的暴力肥肠简单，我们只需要做两遍dfs。<strong>考虑设$f[i]$表示离$i$最近的聚居地是什么，$MIN[i]$表示$i$到最近的聚居地的距离。我们第一遍dfs先找出$i$到它子树内的聚居地的最小距离，之后再做一遍dfs来找$i$往祖先方向后头走能走到的最近聚居地的距离即可。</strong>

观察数据范围后发现，$\sum m&lt;=300000$，因此考虑使用<strong>虚树</strong>。
建出来虚树之后，显然对于在虚树上的点，我们还是能直接暴力做，问题是怎么处理非虚树上的点。
我们会发现，<strong>我们虚树上的一条边在原树种对应一条链(包括链上的子树)。</strong>我们会发现，<strong>这条链上的点上一定是上半部分的最近距离在上面那个点，下半部分的最近距离在下面那个点。</strong>因此，我们考虑用倍增的思想来找出这个“分界点”，找到后计算一下上下分别贡献即可。
这里有个小细节，我们是在原树上做倍增的，因此<strong>我们倍增过程中不应该使用跟DP有关的量</strong>，这里理论上我们只需要使用上端点与下端点的$f,MIN$，以及每个点的深度，$fa$即可实现这个倍增。

时间复杂度$O(mlogn)$
就酱，我们就把这题切掉啦(*≧▽≦)

<hr />

<h1>Code</h1>

<strong>本题细节较多，请各位dalao小心慢行</strong>
<del>直接两行泪就完事了</del>
<strong>数据生成器</strong>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=50;
bool used[N+5];
int main()
{
    srand(time(NULL));
    freopen("3233.in","w",stdout);

    int n=N;
    cout&lt;&lt;n&lt;&lt;endl;
    for(int i=2;i&lt;=n;i++)
        cout&lt;&lt;max(rand()%i,1)&lt;&lt;" "&lt;&lt;i&lt;&lt;endl;

    cout&lt;&lt;n&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++)
    {
        memset(used,0,sizeof used);
        int m=rand()%n+1;
        cout&lt;&lt;m&lt;&lt;endl;

        for(int j=1;j&lt;=m;j++)
        {
            int t=rand()%n+1;
            while(used[t]==true)
                t=rand()%n+1;
            used[t]=true;
            cout&lt;&lt;t&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
    }
    return 0;
}

</code></pre>

<strong>正解</strong>

<pre><code class="language-cpp line-numbers">//Luogu P3233 [HNOI2014]世界树
//Apr,1st,2019
//虚树+DP+倍增神题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=300000+1000;
vector &lt;int&gt; e[N],e2[N];
int n,q,a[N],b[N];
int dfn[N],dfn_to,depth[N],fa[N][21],size[N];
void dfs(int now)
{
    dfn[now]=++dfn_to;
    size[now]=1;
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i&lt;int(e[now].size());i++)
        if(dfn[e[now][i]]==0)
        {
            depth[e[now][i]]=depth[now]+1;
            fa[e[now][i]][0]=now;
            dfs(e[now][i]);
            size[now]+=size[e[now][i]];
        }
}
int LCA(int x,int y)
{
    if(depth[x]&lt;depth[y]) swap(x,y);
    for(int i=20;i&gt;=0;i--)
        if(depth[x]-(1&lt;&lt;i)&gt;=depth[y])
            x=fa[x][i];
    if(x==y) return x;
    for(int i=20;i&gt;=0;i--)
        if(fa[x][i]!=fa[y][i])
            x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
int cmp(int x,int y)
{
    return dfn[x]&lt;dfn[y];
}
bool sp[N];
int MIN[N],f[N],ans[N];
inline int GetDis(int x,int y)
{
    if(depth[x]&lt;depth[y]) swap(x,y);
    return depth[x]-depth[y];
}
void dfs2(int now)
{
    if(sp[now]==true) 
        f[now]=now,MIN[now]=0;
    for(int i=0;i&lt;int(e2[now].size());i++)
    {
        dfs2(e2[now][i]);
        if(MIN[e2[now][i]]+GetDis(e2[now][i],now) &lt; MIN[now] 
        or (MIN[e2[now][i]]+GetDis(e2[now][i],now)==MIN[now] and f[now]&gt;f[e2[now][i]]))
            f[now]=f[e2[now][i]],MIN[now]=MIN[e2[now][i]]+GetDis(e2[now][i],now);
    }
}
void dfs3(int now,int fa) 
{
    if(fa!=0)
    {
        if(MIN[fa]+GetDis(fa,now) &lt; MIN[now] 
        or (MIN[fa]+GetDis(fa,now)==MIN[now] and f[now]&gt;f[fa]))
            f[now]=f[fa],MIN[now]=MIN[fa]+GetDis(fa,now);
    }
    ans[f[now]]++;
    for(int i=0;i&lt;int(e2[now].size());i++)
        dfs3(e2[now][i],now);
}
void GetSum(int x,int y,int &amp;sum_x,int &amp;sum_y)
{
    bool IsSwap=false;
    if(depth[x]&lt;depth[y]) IsSwap=true,swap(x,y);
    int sx=x,dis_x=MIN[x];
    for(int i=20;i&gt;=0;i--)
        if(dis_x+(1&lt;&lt;i) &lt; MIN[y]+depth[x]-depth[y]-(1&lt;&lt;i))
            f[fa[x][i]]=f[x],
            x=fa[x][i],dis_x+=(1&lt;&lt;i);
    if(dis_x+1==MIN[y]+depth[x]-depth[y]-1 and f[x]&lt;f[y])
        x=fa[x][0];
    sum_x=size[x]-size[sx];
    for(int i=20;i&gt;=0;i--)
        if(depth[sx]-(1&lt;&lt;i)&gt;depth[y])
            sx=fa[sx][i];
    sum_y=size[sx]-size[x];
    if(IsSwap==true)
        swap(sum_x,sum_y);
}
void dfs4(int now)
{
    int tmp=size[now]-1;
    for(int i=0;i&lt;int(e2[now].size());i++)
    {
        int sum1,sum2;
        GetSum(now,e2[now][i],sum1,sum2);
        ans[f[now]]+=sum1,ans[f[e2[now][i]]]+=sum2;
        tmp-=(size[e2[now][i]]+sum1+sum2);
        dfs4(e2[now][i]);
    }
    ans[f[now]]+=tmp;
}
int main()
{
    freopen("3233.in","r",stdin);
    freopen("3233.out","w",stdout);

    n=read();
    for(int i=1;i&lt;n;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    fa[1][0]=1;
    dfs(1);

    q=read();
    for(int i=1;i&lt;=q;i++)
    {
        int m=read();
        for(int j=1;j&lt;=m;j++)
            b[j]=a[j]=read();

        sort(a+1,a+1+m,cmp);
        static int mstack[N],top,rec[N],cnt;
        cnt=0;
        mstack[top=1]=1;
        for(int j=(a[1]==1?2:1);j&lt;=m;j++)
        {
            while(LCA(mstack[top],a[j])!=mstack[top])
            {
                int lca=LCA(mstack[top],a[j]);
                if(depth[lca]&gt;depth[mstack[top-1]])
                {
                    e2[lca].push_back(mstack[top]);
                    rec[++cnt]=mstack[top],mstack[top]=lca;
                }
                else
                {
                    e2[mstack[top-1]].push_back(mstack[top]);
                    rec[++cnt]=mstack[top--];
                }
            }
            mstack[++top]=a[j];
        }
        while(top&gt;1)
        {
            e2[mstack[top-1]].push_back(mstack[top]);
            rec[++cnt]=mstack[top--];
        }
        rec[++cnt]=1;

        for(int j=1;j&lt;=m;j++)
            sp[a[j]]=true;
        for(int j=1;j&lt;=cnt;j++)
            MIN[rec[j]]=0x3f3f3f3f,ans[rec[j]]=0;
        dfs2(1); 
        dfs3(1,0);
        dfs4(1);
        for(int j=1;j&lt;=m;j++)
            printf("%d ",ans[b[j]]);
        printf("\n");

        for(int j=1;j&lt;=m;j++)
            sp[a[j]]=false;
        for(int j=1;j&lt;=cnt;j++)
            e2[rec[j]].clear(),ans[rec[j]]=0;
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>401</wp:post_id>
		<wp:post_date><![CDATA[2019-04-01 01:09:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-01 01:09:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3233-hnoi2014%e4%b8%96%e7%95%8c%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%a0%91%e5%bd%a2dp"><![CDATA[树形DP]]></category>
		<category domain="category" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[583]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>手把手带你入门GUIDE</title>
		<link>https://www.goldenpotato.cn/%e5%85%b6%e4%bb%96/%e6%89%8b%e6%8a%8a%e6%89%8b%e5%b8%a6%e4%bd%a0%e5%85%a5%e9%97%a8guide/</link>
		<pubDate>Wed, 03 Apr 2019 07:57:20 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=405</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是GUIDE</h1>

<blockquote>
  GUIDE(GAIT Universal IDE)是由北航GAIT研究组开发的、专门为NOI选手设计的轻型集成开发环境。GUIDE具有跨平台、操作简单、支持C/C++/Pascal三种语言和单文件编译调试等优点。经过近一年的试用和修改之后，GUIDE 1.0.1版目前正式发布。   ——www.noi.cn
</blockquote>

换句话来说，GUIDE是一个NOI官方指定的，<strong>在NOI Linux系统上预装</strong>的一款pascal/c/c++ IDE(集成开发环境)。

<hr />

<h1>GUIDE有什么优点</h1>

<del>我们GUIDE有一点好，就是出了什么bug，用可视化gdb调试调得比什么人都快</del>

首先，GUIDE作为一款IDE，高亮，代码补全，括号匹配什么的肯定是应有尽有。
但对于笔者来说，GUIDE最重要的功能莫过于它的可视化gdb调试，它可以方便地让我们定位bug的位置并解决问题。
其次，GUIDE设计在windows系统下非常简洁美观。

况且，我们平时用的IDE和考场上用的IDE一模一样,可以有效避免因为不习惯的问题造成的翻车，心态爆炸。

<hr />

<h1>GUIDE的基本使用</h1>

<h3>GUIDE的安装</h3>

要使用GUIDE，显然，你必须要有一份GUIDE程序。考虑到读者们大多使用windows编程(<del>以及我并不会用新版ubuntu装GUIDE</del>)的问题，<strong>接下来的所有操作都在笔者的WINDOWS10系统下进行。如果有因系统不同而造成的报道上的偏差，请读者自行推广到其他的系统。</strong>
GUIDE可以到<a href="http://www.noi.cn/newsview.html?id=27&amp;hash=B7759F&amp;type=1">NOI官网下载</a>
但是考虑到GUIDE对MINGW的版本要求比较特殊的问题，为了方便大家使用GUIDE，我为大家特意打包了一份：
<a href="https://nbcc3-my.sharepoint.com/:u:/g/personal/goldenpotato_cctv_admin_edu_pl/EQuLXvqje6tOhRjjS8NyG40BU8Is1B7TAGZrQVa0W7bEcQ?e=72TSog">OFB</a>（推荐）
<a href="https://pan.baidu.com/s/1qo_9iN6u_Rk8zqEVaHNGuQ">度盘</a> 提取码: bbvq

下载完压缩包并解压之后，文件夹内应有以下文件：
<img src="https://s2.ax1x.com/2019/04/03/Ac4DGd.png" alt="Ac4DGd.png" />

接下来，我们可以直接点开主程序GUIDE.exe
打开之后，它应该会让你选择gcc,g++,fpc的目录。<strong>对于MinGW:</strong>我们直接选定<code>GUIDE/MinGW/bin</code>这个文件夹即可；<strong>对于fpc</strong>，请自行安装目录下带有的<code>fpc-2.2.2.i386-win32.exe</code>。

<blockquote>
  为了让GUIDE的调试功能有效，请使用MinGW，如果您不需要gdb调试功能，可以选择MinGW_new
</blockquote>

<img src="https://s2.ax1x.com/2019/04/03/Ac4tr6.png" alt="Ac4tr6.png" />

这样子，我们的安装工作基本上就告一段落了。

<hr />

<h3>GUIDE的基本设置</h3>

<del>俗话说得好，调好字体就是AC的一半。</del>
因此，我们可以在<code>编辑/选项/语法高亮显示/全部字体</code>中选择一个好看的字体及大小。
<img src="https://s2.ax1x.com/2019/04/03/Ac4ozn.png" alt="Ac4ozn.png" />
接下来，我们也可以在这里设置自动补全及括号匹配相关的问题。调整为自己习惯的设定即可。

我们发现GUIDE主程序界面下还有编译结果及文件夹两个额外的文本框。这些都是可以任意拖动的。
<img src="https://s2.ax1x.com/2019/04/03/Ac5AoD.png" alt="Ac5AoD.png" />
我一般习惯关闭文件夹这个文本框，将编译结果框拖到左边来，因为这样子方便调试代码。
<img src="https://s2.ax1x.com/2019/04/03/AcIPpj.md.png" alt="AcIPpj.md.png" />

<hr />

<h3>GUIDE的基本使用</h3>

搞完上述事情后，我们就可以正常使用GUIDE啦。
现在，我将以写<a href="https://www.luogu.org/problemnew/show/P1706">P1706 全排列问题</a>的事例来介绍如何使用GUIDE编辑，运行，调试一个程序。

首先，我们得创建一个新文件，左上角菜单<code>文件/新文件</code>或点击<img src="https://s2.ax1x.com/2019/04/03/AcI0gA.png" alt="AcI0gA.png" />或<code>CTRL+N</code>，来创建一个新的代码文件。
接下来，<strong>我们必须先保存文件，这样GUIDE才知道要用什么语言的语法高亮</strong>。
按下<code>CTRL+s</code>或点击<img src="https://s2.ax1x.com/2019/04/03/AcIIuq.png" alt="AcIIuq.png" />来保存文件
<strong>注意，这里我们设置文件名时一定要打上后缀名，如c语言应该命名为：<code>xxx.c,c++: xxx.cpp,pascal: xxx.pas</code></strong>
<img src="https://s2.ax1x.com/2019/04/03/AcIbUU.png" alt="AcIbUU.png" />

接下来我们就可以在这个新文件里面打上我们的代码。
对于这道题，我们可以发现这题我们做一个全排列即可完成。
<img src="https://s2.ax1x.com/2019/04/03/AcoPUO.md.png" alt="AcoPUO.md.png" />

打完代码之后，你可以通过鼠标点击<img src="https://s2.ax1x.com/2019/04/03/AcoMa8.png" alt="AcoMa8.png" />编译你的代码，也可以通过按下<code>"F7"</code>来编译。
在这里，我故意让程序有一点小问题无法通过编译。<strong>你可以通过双击编译结果中的某一个问题让你快速跳转到有问题的那一行。</strong>(截图并不能截到光标，大家意会一下光标在对应行即可)
<img src="https://s2.ax1x.com/2019/04/03/AcoaZV.png" alt="AcoaZV.png" />
在这里，我们发现我们漏写了一个分号，加上后就可以通过编译了。

接下来，我们可以通过鼠标点击<img src="https://s2.ax1x.com/2019/04/03/AcofIO.png" alt="AcofIO.png" />运行代码，也可以按下<code>CTRL+F5</code>来运行。
我们输入样例：
注意到，和DEVC++类似，GUIDE是会自动帮你在末尾加上“按任意键继续”来方便你的观察的。
<img src="https://s2.ax1x.com/2019/04/03/Aco4iD.png" alt="Aco4iD.png" />

<hr />

<h1>GUIDE的进一步使用</h1>

接下来的才是笔者最想介绍的地方：GUIDE的可视化gdb调试功能

<blockquote>
  如果您安装GUIDE时使用的是MinGW_new这个编译器，请在<code>设置/重设编译器路径</code>这里调整回MinGW以使用GUIDE的逐过程功能。（因为GUIDE并不资磁最新的编译器）
</blockquote>

逐过程，顾名思义，我们可以按照我们的程序逐步逐步观察我们的代码的运行：
通过按下<img src="https://s2.ax1x.com/2019/04/03/Ac7JH0.png" alt="Ac7JH0.png" />来进入gdb模式
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1pguyyg5sj31hc0sy0wo.jpg" alt="" />
我们发现，在调试模式下，在行号标旁边出现了一个小蓝箭头，表示当前程序运行到了第几行。
左边的编译信息框会自动切换到GDB信息框，同时，我们也可以通过点击小箭头以切换到不同的菜单夹并点击对应的按钮来进入对应的界面。
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1pgxb7vx2j307g05ddfo.jpg" alt="" />

接下来，由笔者来介绍如何逐过程：

<h3>逐过程</h3>

顾名思义，就是按照一个一个过程来进行你的程序。对于函数，它将不会带领你进入函数，而是直接运行完这个函数后继续(比如说，我现在要执行<code>cin</code>函数，它将不会带领我进入<code>iostream</code>库中cin的对应位置，而是直接运行完这个函数继续下一行)
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1pgyrpvhgj306i021web.jpg" alt="" />
比如说，现在程序运行到了dfs这句话之前，如果按逐过程，则将直接执行完这个函数，然后进入下一行，而非把运行光标带到函数内部:
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1ph2eze4aj306601uq2r.jpg" alt="" />
按下逐过程后，代码会执行到这一步：(即dfs函数完成之后的下一步)
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1ph3trl4dj31hc0ssjux.jpg" alt="" />

<h3>逐语句</h3>

<img src="https://s2.ax1x.com/2019/04/03/AcHoz4.png" alt="AcHoz4.png" />
顾名思义，按照一个一个语句来执行你的程序。<strong>它会带领你的程序进入函数</strong>
例如说：
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1ph2eze4aj306601uq2r.jpg" alt="" />
按下逐语句后：
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1ph6ahrvdj30ap0dbdgj.jpg" alt="" />

跳出循环的功能我没用过，就不解释了。
运行到光标处就是字面意思，也不多做解释。

<h3>断点设置与运行到断点</h3>

我们可以通过按下<code>F9</code>来在光标行设置断点(断点以红心表示)
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phibvhqaj30cc06ojrm.jpg" alt="" />
接下来，我们可以通过按下<code>F5</code>或<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phj97bq8j307t01ia9v.jpg" alt="" /><br />
来让程序在断点处停下来(在此之前不能有别的中断事情，如别的断点，数据输入没有完成)

<h3>变量查看</h3>

我们在调试过程中，任何时刻都可以查看当前状态下每个变量的值，先点进变量查看栏
<strong>可以通过按下那个加号来查看某个名字的变量的值/函数运行结果。</strong>
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phc0i3zwj309k0qcq32.jpg" alt="" />
也可以：先选定一段字符（变量名），右键：“添加到变量查看”
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phdvx909j30bi05saa5.jpg" alt="" />
效果如下：<strong>(对于长度大于500的数组，我们还能选定显示起始位置和终止位置)</strong>
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phfsqqefj30890amgll.jpg" alt="" />
对于结构体，我们还可以展开来看到所有的元素

<h3>堆栈信息查看</h3>

我们还可以查看我们程序的堆栈情况：
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phh50fdxj30et038dfs.jpg" alt="" />

有了以上调试功能，相信读者一定能如虎添翼，更快的DE出自己程序的BUG，AC掉各种各样的神题。

<hr />

<h1>Tips</h1>

1.要让GUIDE的可视化调试能正常运行，必须使用5.1.4版本的(远古版本)的MinGW。但有时候，我们需要一些先进的编译器，可以暂时放弃调试，在<code>编辑/重设编译器路径</code>这里暂时设置为MinGW_new。这个时候，虽然不能调试，但是其他功能还是可以正常运行的。

2.请不要在展开巨大长度的数组时按下一步，这样操作很有可能导致GUIDE崩溃。

3.我们可以使用一切文本编辑常用快捷键<code>CTRL F、S、C、V、Z、Y</code>等

4.我们可以通过右键文件名来设置编译选项
<img src="http://ww1.sinaimg.cn/large/0061bb0Wly1g1phqe10sgj306h04adft.jpg" alt="" />

<hr />

<h1>后记</h1>

希望大家能用好GUIDE，祝大家在OI赛事中取的理想的成绩！

<del>以及别用DEVCPP了，来用GUIDE吧，DEVCPP的调试功能是在是emmmmmm</del>
当然，各位julao也可以使用各种各样更优秀的编辑器：如Emacas，Vim等。但是考虑到其陡峭的学习曲线，如果您不是julao的话，GUIDE一样能称为您的解题利器。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>405</wp:post_id>
		<wp:post_date><![CDATA[2019-04-03 07:57:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-03 07:57:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%89%8b%e6%8a%8a%e6%89%8b%e5%b8%a6%e4%bd%a0%e5%85%a5%e9%97%a8guide]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>1</wp:is_sticky>
										<category domain="category" nicename="%e5%85%b6%e4%bb%96"><![CDATA[其他]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1681]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[308]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[菜狗]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-07 01:05:19]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-07 01:05:19]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[%%%%%%%%%% :huaji11:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-07 01:06:44]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-07 01:06:44]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:huaji21:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>26</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>28</wp:comment_id>
			<wp:comment_author><![CDATA[菜狗]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-07 01:12:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-07 01:12:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[![](http://images.cnblogs.com/cnblogs_com/lizbaka/1437821/o_TIM%E5%9B%BE%E7%89%8720190407091023.jpg)]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>27</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-07 01:14:14]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-07 01:14:14]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<img src="http://images.cnblogs.com/cnblogs_com/lizbaka/1437821/o_TIM%E5%9B%BE%E7%89%8720190407091023.jpg" alt="" />]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>28</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>30</wp:comment_id>
			<wp:comment_author><![CDATA[菜狗]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1849214604@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-07 01:18:42]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-07 01:18:42]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<img src="http://images.cnblogs.com/cnblogs_com/lizbaka/1437821/o_TIM%E5%9B%BE%E7%89%8720190407091643.jpg" alt="" />]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>29</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>31</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.16.59.38]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-08 08:54:54]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-08 08:54:54]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:huaji9:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>75</wp:comment_id>
			<wp:comment_author><![CDATA[noob]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[3284346435@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-11-11 10:12:57]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-11-11 10:12:57]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[%%%%%%%%%%%%%%%%%xmd学长太强了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>89</wp:comment_id>
			<wp:comment_author><![CDATA[kkksc04]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[6666666@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[218.92.221.152]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-02-24 10:35:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-02-24 10:35:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[%%%%]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2615</wp:comment_id>
			<wp:comment_author><![CDATA[碱式碳酸希]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xi2oh2co3@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://xi2oh2co3.github.io</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[116.252.221.146]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-04 01:48:01]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-04 01:48:01]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[%%%%Tql
请求搬运至NNEZ校内OJ公告中。
展示链接：
请在启天楼内网中访问! :razz: 
<a href="http://172.16.31.233/blog/guava/post/23" rel="nofollow ugc">Guava年报第三期</a>
非常感谢学长的教程！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1604454481.338135;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2616</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.42.148.187]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-04 14:08:26]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-04 14:08:26]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[欢迎欢迎qwq]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2615</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1604498906.455582;s:5:"event";s:9:"check-ham";s:4:"user";s:15:"GoldenPotato137";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2617</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.42.148.187]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-04 14:09:34]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-04 14:09:34]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[stm我咋进二中内网啊，给个vpn请（大雾]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2615</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1604498974.378048;s:5:"event";s:9:"check-ham";s:4:"user";s:15:"GoldenPotato137";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2636</wp:comment_id>
			<wp:comment_author><![CDATA[碱式碳酸希]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xi2oh2co3@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://xi2oh2co3.github.io</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-30 12:06:06]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-30 12:06:06]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[可以先不要告诉老师们吗（偷偷搞的]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1606737972.350802;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2637</wp:comment_id>
			<wp:comment_author><![CDATA[Guava]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[uavaoj@protonmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[47.241.61.152]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-30 12:37:55]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-30 12:37:55]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[@GoldenPotato137 暂时是 guavaoj.tk]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2617</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1606739875.963928;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2638</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.42.148.187]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-30 15:13:57]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-30 15:13:57]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这个网址找不到IP呀，是被墙了吗（大雾]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2617</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1606749237.809848;s:5:"event";s:9:"check-ham";s:4:"user";s:15:"GoldenPotato137";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2639</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.42.148.187]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-30 15:14:27]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-30 15:14:27]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[放心放心，没问题w]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2636</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1606749267.69442;s:5:"event";s:9:"check-ham";s:4:"user";s:15:"GoldenPotato137";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>2640</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.42.148.187]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-11-30 15:16:09]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-11-30 15:16:09]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[草，真被墙了（]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>2617</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
			<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1606749369.475498;s:5:"event";s:9:"check-ham";s:4:"user";s:15:"GoldenPotato137";}]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P2617] Dynamic Rankings</title>
		<link>https://www.goldenpotato.cn/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84/luogu-p2617-dynamic-rankings/</link>
		<pubDate>Sun, 07 Apr 2019 08:46:47 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=406</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P2617"> P2617 Dynamic Rankings</a>

<hr />

<h1>Solution</h1>

这题需要一个比较妙的操作。

首先，我们阅读题面，发现题目要求我们处理区间K大带单点修改的问题。我们考虑用整体二分来解决这个问题。
<del>总所周知</del>，<strong>整体二分中的修改只能以“添加”的形式进行，而不能以“覆盖”的方式进行。但这里，我们修改一个位置的数之后，新的数会把原来的数覆盖掉。</strong>如果我们不能处理好这个问题，整体二分一定会错。

因此，我们考虑添加一个“删除”操作来解决这个问题。<strong>我们可以把这里的修改变为：删除原有的数+加入一个新的数。这样子，我们就把原来的“覆盖”问题转换为了“添加”问题</strong>。

接下来，我们的操作就很套路了。我们直接二分一个$mid$,把所有$ans>mid$的询问和添加后的数$>mid$的修改丢到右边，其他的丢到左边。<strong>对于删除操作，如果删除之前的数$&lt;=mid$，我们就把删除操作丢到左边，否则丢到右边。</strong>
（因为我们会在二分的时候计算右边对左边的贡献，如果改前的数$&lt;=mid$，有可能导致我们重复计算贡献，因此必须把这个删除操作丢到左边防止重复计算）

时间复杂度$O(nlogn^2)$
就酱，这题就被我们切掉啦(～￣▽￣)～

<hr />

<h1>Code</h1>

<h3>数据生成器</h3>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int N=100000;
const int MAX=2000;
int main()
{
    freopen("2617.in","w",stdout);
    srand(time(NULL));

    int n=N,m=N;
    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++)
        cout&lt;&lt;rand()%MAX+1&lt;&lt;" ";
    cout&lt;&lt;endl;

    for(int i=1;i&lt;=m;i++)
    {
        int op=rand()%2;
        if(op==1)
        {
            int r=rand()%n+1,l=rand()%r+1,k=rand()%(r-l+1)+1;
            cout&lt;&lt;"Q "&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;k&lt;&lt;endl;
        }
        else
            cout&lt;&lt;"C "&lt;&lt;rand()%n+1&lt;&lt;" "&lt;&lt;rand()%MAX+1&lt;&lt;endl;
    }
    return 0;
}

</code></pre>

<h3>正解</h3>

<pre><code class="language-cpp line-numbers">//Luogu P2617 Dynamic Rankings
//Apr,7th,2019
//整体二分妙题
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=100000+100;
const int inf=0x3f3f3f3f;
int a[N],n;
struct BitTree
{
    int sum[N*400];
    int lowbit(int x)
    {
        return x&amp;(-x);
    }
    void Add(int x,int w)
    {
        int tmp=Query(x,x);
        if(tmp==1 and w==0) w=-1;
        if(tmp==1 and w==1) w=0;
        for(;x&lt;=n;x+=lowbit(x))
            sum[x]+=w;
    }
    int query(int x)
    {
        int t_ans=0;
        for(;x&gt;=1;x-=lowbit(x))
            t_ans+=sum[x];
        return t_ans;
    }
    int Query(int l,int r)
    {
        return query(r)-query(l-1);
    }
}bit;
struct OP
{
    int l,r,x,no;
}op[N];
struct OP2
{
    int l,r;
    vector &lt;OP&gt; op;
};
queue &lt;OP2&gt; dl;
int m,q,ans[N];
int main()
{
    freopen("2617.in","r",stdin);
    freopen("2617.out","w",stdout);

    int TIME=clock();
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read();
    char type[5];
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%s",type+1);
        if(type[1]=='Q')
            op[i].l=read(),op[i].r=read(),op[i].x=op[i].r-op[i].l+2-read(),op[i].no=++q;
        else
            op[i].l=read(),op[i].r=read();
    }

    OP2 now;
    now.l=1,now.r=inf;
    OP temp;
    for(int i=1;i&lt;=n;i++)
        temp.l=i,temp.r=a[i],temp.no=0,
        now.op.push_back(temp);
    for(int i=1;i&lt;=m;i++)
    {
        temp.no=-1,temp.l=op[i].l;
        if(op[i].no==0)
            now.op.push_back(temp);
        now.op.push_back(op[i]);
    }
    dl.push(now);

    while(dl.empty()==false)
    {
        now=dl.front();
        dl.pop();

        if(now.op.size()==0)
            continue;
        if(now.l==now.r)
        {
            for(int i=0;i&lt;int(now.op.size());i++)
                ans[now.op[i].no]=now.l;
            continue;
        }
        int mid=(now.l+now.r)/2;
        OP2 L,R;
        for(int i=0;i&lt;int(now.op.size());i++)
            if(now.op[i].no==0)
            {
                bit.Add(now.op[i].l,now.op[i].r&gt;mid);
                if(now.op[i].r&gt;mid)
                    R.op.push_back(now.op[i]);
                else
                    L.op.push_back(now.op[i]);
            }
            else if(now.op[i].no==-1)
            {
                if(bit.Query(now.op[i].l,now.op[i].l)==1)
                    R.op.push_back(now.op[i]);
                else
                    L.op.push_back(now.op[i]);
                bit.Add(now.op[i].l,0);
            }
            else
            {
                int tmp=bit.Query(now.op[i].l,now.op[i].r);
                if(tmp&gt;=now.op[i].x)
                    R.op.push_back(now.op[i]);
                else
                {
                    now.op[i].x=now.op[i].x-tmp;
                    L.op.push_back(now.op[i]);
                }
            }

        for(int i=now.op.size()-1;i&gt;=0;i--)
            if(now.op[i].no==0)
                bit.Add(now.op[i].l,0);
        L.l=now.l,L.r=mid;
        R.l=mid+1,R.r=now.r;
        dl.push(R);
        dl.push(L);
    }

    for(int i=1;i&lt;=q;i++)
        printf("%d\n",ans[i]);
    cerr&lt;&lt;clock()-TIME&lt;&lt;endl;
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>406</wp:post_id>
		<wp:post_date><![CDATA[2019-04-07 08:46:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-07 08:46:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p2617-dynamic-rankings]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b4%e4%bd%93%e4%ba%8c%e5%88%86"><![CDATA[整体二分]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[373]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P4606] [SDOI2018]战略游戏</title>
		<link>https://www.goldenpotato.cn/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92/luogu-p4606-sdoi2018%e6%88%98%e7%95%a5%e6%b8%b8%e6%88%8f/</link>
		<pubDate>Mon, 08 Apr 2019 10:09:27 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=409</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P4606">P4606 [SDOI2018]战略游戏</a>

<hr />

<h1>Solution</h1>

<blockquote>
  圆方树上圆方果，
    圆方树下你和我。
    圆方树前建虚树， 
    欢乐多又多。
</blockquote>

<a href="https://imgchr.com/i/A5PwBd"><img src="https://s2.ax1x.com/2019/04/08/A5PwBd.th.png" alt="A5PwBd.th.png" /></a>

.

好吧，我们来说正题。
这题就比较强。<del>根据常识</del>，如果我们爆掉的点能影响这个图的连通性，<strong>那么，这个点一定是割点</strong>。
因此，我们要先对原图做<strong>Tarjan求点双</strong>。接下来，我们考虑用圆方树来解决一个问题。

我们先考虑暴力怎么做，我们先对原图求出圆方树。接下来，我们发现，<strong>对答案有贡献的点一定是孩子有被选定的点的圆点，并且这个点的总共被选定的孩子数不等于总共被选定数</strong>（因为如果这个点被割掉了，其被选定的孩子一定会与其他点断开来，且方点代表一个点双，并不能割）。
因此，我们可以直接统计一下有多少个有贡献的点即可。

接下来，我们进一步观察数据，发现$\sum S$非常小，因此考虑用虚树来解决这个问题。
我们对每个询问的点构建虚树。这时候，我们就要多计算边的贡献，考虑一条边的贡献，即为这条边上有多少个原点，随便转移一下就好了。<del>好个鬼啊，细节比较多，大家注意一下</del>

时间复杂度$O(\sum S \cdot log n)$
就酱，这题就被我们切掉啦ヾ(●´∀｀●)

<hr />

<h1>Code</h1>

<h3>数据生成器</h3>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=10;
const int M=15;
bool vis[N+5];
int main()
{
    srand(time(NULL));
    freopen("4606.in","w",stdout);

    cout&lt;&lt;"1\n";
    int n=N,m=M;
    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
    for(int i=2;i&lt;=n;i++)
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;max(rand()%i,1)&lt;&lt;endl; 
    for(int i=n;i&lt;=m;i++)
    {
        int s=rand()%n+1,t=rand()%n+1;
        cout&lt;&lt;s&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
    }

    int q=N;
    cout&lt;&lt;endl&lt;&lt;q&lt;&lt;endl;
    for(int i=1;i&lt;=q;i++)
    {
        int t=max(2,rand()%n+1);
        memset(vis,0,sizeof vis);
        cout&lt;&lt;t&lt;&lt;" ";
        for(int j=1;j&lt;=t;j++)
        {
            int tmp=rand()%n+1;
            while(vis[tmp]==true) 
                tmp=rand()%n+1;
            vis[tmp]=true;
            cout&lt;&lt;tmp&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
    }
    return 0;
}

</code></pre>

<h3>正解</h3>

<pre><code class="language-cpp line-numbers">//Luogu P4606 [SDOI2018]战略游戏
//Apr,8th,2019
//圆方树+虚树
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2*100000+100;
vector &lt;int&gt; e[N],e2[N],e3[N];
int n,m,q;
int low[N],cnt,dfn_to,dfn[N],mstack[N],top;
bool vis[N];
void Tarjan(int now,int father)
{
    vis[now]=true;
    dfn[now]=low[now]=++dfn_to;
    mstack[++top]=now;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            Tarjan(e[now][i],now);
            low[now]=min(low[now],low[e[now][i]]);
            if(low[e[now][i]]&gt;=dfn[now])
            {
                e2[now].push_back(n+(++cnt));
                while(mstack[top+1]!=e[now][i])
                    e2[n+cnt].push_back(mstack[top--]);
            }
        }
        else if(e[now][i]!=father)
            low[now]=min(low[now],dfn[e[now][i]]);
}
int fa[N][21],depth[N],pre[N];
void dfs(int now,int father)
{
    fa[now][0]=father,depth[now]=depth[father]+1;
    dfn[now]=++dfn_to;
    pre[now]=pre[father]+(now&lt;=n);
    for(int i=1;i&lt;=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i&lt;int(e2[now].size());i++)
        if(e2[now][i]!=father)
                dfs(e2[now][i],now);
}
int LCA(int x,int y)
{
    if(depth[x]&lt;depth[y]) swap(x,y);
    for(int i=20;i&gt;=0;i--)
        if(depth[x]-(1&lt;&lt;i) &gt;= depth[y])
            x=fa[x][i];
    if(x==y) return x;
    for(int i=20;i&gt;=0;i--)
        if(fa[x][i]!=fa[y][i])
            x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
bool cmp(int x,int y)
{
    return dfn[x]&lt;dfn[y];
}
bool sp[N];
int f[N];
int GetSum(int x,int y) //(x,y)
{
    return pre[y]-pre[x]-(y&lt;=n);
}
int dfs2(int now)
{
    f[now]=0;
    for(int i=0;i&lt;int(e3[now].size());i++)
        f[now]+=dfs2(e3[now][i])+GetSum(now,e3[now][i]);
    if(sp[now]==false and now&lt;=n and (now!=1 or e3[now].size()!=1))
        f[now]++;
    if(now==1 and e3[now].size()==1 and sp[now]==false)
        f[now]-=GetSum(now,e3[now][0]);
    return f[now];
}
int main()
{
    freopen("4606.in","r",stdin);
    freopen("4606.out","w",stdout);

    int T=read();

    for(;T&gt;0;T--)
    {
        n=read(),m=read();

        for(int i=1;i&lt;=2*n;i++)
            e[i].clear(),e2[i].clear(),e3[i].clear();
        memset(vis,0,sizeof vis);
        dfn_to=0;

        for(int i=1;i&lt;=m;i++)
        {
            int s=read(),t=read();
            e[s].push_back(t);
            e[t].push_back(s);
        }

        Tarjan(1,1);
        dfn_to=0;
        dfs(1,1);

        q=read();
        static int a[N],rec[N];
        for(int i=1;i&lt;=q;i++)
        {
            m=read();
            for(int j=1;j&lt;=m;j++)
                a[j]=read();

            sort(a+1,a+1+m,cmp);
            mstack[top=1]=1,cnt=0;
            for(int j=(a[1]==1?2:1);j&lt;=m;j++)
            {
                while(LCA(mstack[top],a[j])!=mstack[top])
                {
                    int lca=LCA(mstack[top],a[j]);
                    if(depth[lca] &gt; depth[mstack[top-1]])
                    {
                        e3[lca].push_back(mstack[top]);
                        rec[++cnt]=mstack[top],mstack[top]=lca;
                    }
                    else
                    {
                        e3[mstack[top-1]].push_back(mstack[top]);
                        rec[++cnt]=mstack[top--];
                    }
                }
                mstack[++top]=a[j];
            }
            while(top&gt;1)
            {
                e3[mstack[top-1]].push_back(mstack[top]);
                rec[++cnt]=mstack[top--];
            }
            rec[++cnt]=1;

            for(int i=1;i&lt;=m;i++)
                sp[a[i]]=true;

            printf("%d\n",dfs2(1));

            for(int i=1;i&lt;=cnt;i++)
                sp[rec[i]]=false,e3[rec[i]].clear();
        }
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>409</wp:post_id>
		<wp:post_date><![CDATA[2019-04-08 10:09:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-08 10:09:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p4606-sdoi2018%e6%88%98%e7%95%a5%e6%b8%b8%e6%88%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9c%86%e6%96%b9%e6%a0%91"><![CDATA[圆方树]]></category>
		<category domain="category" nicename="%e7%bc%a9%e7%82%b9-%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f"><![CDATA[缩点/强连通分量]]></category>
		<category domain="category" nicename="%e8%99%9a%e6%a0%91"><![CDATA[虚树]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[653]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[Luogu P3225 [HNOI2012]矿场搭建</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/luogu-p3225-hnoi2012%e7%9f%bf%e5%9c%ba%e6%90%ad%e5%bb%ba/</link>
		<pubDate>Mon, 08 Apr 2019 13:44:54 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=412</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3225">P3225 [HNOI2012]矿场搭建</a>

<hr />

<h1>Solution</h1>

这题比较妙。

首先，<del>根据常识</del>，<strong>如果一个点爆了，当且仅当它是割点的时候才会影响整个图的连通性</strong>。
因此，我们考虑把这道题往点双那方面想。

接下来我们思考这个问题：对于一个点双，我们什么时候需要在它这里面放置逃生通道：
1. 如果与它相连的点双块只有一个：<strong>如果爆的是割点，则必须在当前块中的任意点建一个通道；如果爆的是普通点，则当前块则可以与别的块照样联通。</strong>
2. 如果与它相连的点双块有两个以上：<strong>无论爆的是割点还是普通点，都不影响它里面的其他点到其他块去逃生</strong>。
综上，<strong>我们发现我们只需要在只与1个其他点双块连接的点双块防止逃生通道即可</strong>。我在这里暂时称这种块为“叶子点双”。
如下图：我们只需要在紫色的点双块中每一个都放置一个逃生通道即可。
<img src="http://ww1.sinaimg.cn/large/0061bb0Wgy1g1vjp7xbxmj30el0bt0tm.jpg" alt="" />

因此，要放置的逃生通道的总数为“叶子点双”的个数，总方案为$\prod (size[x]-1)$ （x为叶子点双）（由乘法原理可得）。

但是，我们要小心一个细节：就是我们在做Tarjan的时候，无论如何都会把1号节点认为是割点。但是，1号节点有可能并不是割点。<strong>1号节点有可能属于某一个点双块，而且这个点双块是有可能为叶子节点的</strong>，我们做的时候要小心判断一下。

接下来，实现的话就随便写就好。<del>笔者写的时候脑袋有点犯二，就用了圆方树来实现</del>
时间复杂度$O(\sum n)$
就酱，这道题就被我们切掉啦(～￣▽￣)～

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P3225 [HNOI2012]矿场搭建
//Apr,8th,2019
//Tarjan求点双+圆方树
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2*500+20;
vector &lt;int&gt; e[N],e2[N];
int n,m;
int dfn[N],low[N],dfn_to,mstack[N],top,cnt,size[N];
bool vis[N];
void Tarjan(int now,int father)
{
    vis[now]=true;
    low[now]=dfn[now]=++dfn_to;
    mstack[++top]=now;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            Tarjan(e[now][i],now);
            low[now]=min(low[now],low[e[now][i]]);
            if(low[e[now][i]] &gt;= dfn[now])
            {
                e2[now].push_back(n+ ++cnt);
                size[cnt]=1;
                while(mstack[top+1]!=e[now][i])
                    e2[n+cnt].push_back(mstack[top--]),
                    size[cnt]++;
            }
        }
        else if(e[now][i]!=father)
            low[now]=min(low[now],dfn[e[now][i]]);
}
long long ans,ans2;
int dfs(int now)//返回now的子树内的方点个数
{
    int t_cnt=(now&gt;n);
    for(int i=0;i&lt;int(e2[now].size());i++)
        t_cnt+=dfs(e2[now][i]);
    if(now&gt;n and t_cnt==1)
        ans2++,ans*=(size[now-n]-1);
    return t_cnt;
}
bool Check()//判断1所在块是否为叶子块
{
    int x=e2[1][0],t_cnt=0;
    for(int i=0;i&lt;int(e2[x].size());i++)
        if(e2[e2[x][i]].size()!=0)
            t_cnt++;
    return t_cnt==1;
}
int main()
{
    for(int o=1;;o++)
    {
        m=read();
        if(m==0) break;
        for(int i=1;i&lt;=500*2+5;i++)
            e[i].clear(),e2[i].clear();
        dfn_to=cnt=0;
        memset(vis,0,sizeof vis);   

        n=0;
        for(int i=1;i&lt;=m;i++)
        {
            int s=read(),t=read();
            e[s].push_back(t);
            e[t].push_back(s);
            n=max(max(n,s),t);
        }

        Tarjan(1,0);
        ans=1,ans2=0;
        dfs(1);
        if(e2[1].size()==1 and Check()==true)//特殊处理1号节点
            ans*=(size[e2[1][0]-n]-1),
            ans2++;
        if(cnt==1)//特判只有一个连通块的情况
            ans=(n*(n-1))/2,ans2=2;


        printf("Case %d: %lld %lld\n",o,ans2,ans);
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>412</wp:post_id>
		<wp:post_date><![CDATA[2019-04-08 13:44:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-08 13:44:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3225-hnoi2012%e7%9f%bf%e5%9c%ba%e6%90%ad%e5%bb%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9c%86%e6%96%b9%e6%a0%91"><![CDATA[圆方树]]></category>
		<category domain="category" nicename="%e8%be%b9%e5%8f%8c-%e7%82%b9%e5%8f%8c"><![CDATA[边双/点双]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[581]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[459]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>[USACO06JAN]冗余路径Redundant Paths</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/usaco06jan%e5%86%97%e4%bd%99%e8%b7%af%e5%be%84redundant-paths/</link>
		<pubDate>Mon, 08 Apr 2019 15:02:19 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=414</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P2860">P2860 [USACO06JAN]冗余路径Redundant Paths</a>

<hr />

<h1>Solution</h1>

首先，我们可以发现题目要求每一个点到其他所有点的路径不只有一条，<strong>这本质上就是要我们把这个图所有的桥都消除掉。</strong>

要消除掉桥，首先必须要把边双先缩起来。缩边双很简单：<strong>和求强连通分量一模一样，唯一要注意的是我们要多记录一个$fa$，防止我们求$low$的时候直接把$fa$算进来。</strong>
求完边双之后，我们会发现原图变成一个树的形式。想象一下：我们要把这个树上所有的单边去掉，我们只需要把叶子节点两两连起来即可。<strong>（注意，这里的叶子节点是广义的（即根也有可能是叶子节点））</strong>
还有一个小细节：对于直接就是一个环的情况，我们要特判一下，直接输出0即可。

时间复杂度$O(n)$
就酱，这题就被我们切掉啦︿(￣︶￣)︿

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu P2860 [USACO06JAN]冗余路径Redundant Paths
//Apr,8th,2019
//边双
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=5000+100;
vector &lt;int&gt; e[N],e2[N];
int n,m;
int dfn[N],low[N],dfn_to,InStack[N],mstack[N],top,belong[N],cnt;
bool vis[N];
void Tarjan(int now,int father)
{
    vis[now]=InStack[now]=true;
    dfn[now]=low[now]=++dfn_to;
    mstack[++top]=now;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            Tarjan(e[now][i],now);
            low[now]=min(low[now],low[e[now][i]]);
        }
        else if(e[now][i]!=father and InStack[e[now][i]]==true)
            low[now]=min(low[now],dfn[e[now][i]]);
    if(low[now]==dfn[now])
    {
        cnt++;
        while(mstack[top+1]!=now)
            InStack[mstack[top]]=false,
            belong[mstack[top--]]=cnt;
    }
}
int GetAns(int now,int father)
{
    int ans=0;
    for(int i=0;i&lt;int(e2[now].size());i++)
        if(e2[now][i]!=father)
            ans+=GetAns(e2[now][i],now);
    return max(1,ans);
}
int main()
{
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++)
        e[i].reserve(4);
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read();
        e[s].push_back(t);
        e[t].push_back(s);
    }

    Tarjan(1,0);

    for(int i=1;i&lt;=n;i++)
        for(int j=0;j&lt;int(e[i].size());j++)
            if(belong[i]!=belong[e[i][j]])
                e2[belong[i]].push_back(belong[e[i][j]]);
    int ans=GetAns(belong[1],belong[1])+(e2[belong[1]].size()==1);
    if(cnt==1)//特判只有一个环
        ans=0;
    printf("%d",ans/2+ans%2);
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>414</wp:post_id>
		<wp:post_date><![CDATA[2019-04-08 15:02:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-08 15:02:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[usaco06jan%e5%86%97%e4%bd%99%e8%b7%af%e5%be%84redundant-paths]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e8%be%b9%e5%8f%8c-%e7%82%b9%e5%8f%8c"><![CDATA[边双/点双]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[685]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>UVA610 Street Directions</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/uva610-street-directions/</link>
		<pubDate>Tue, 09 Apr 2019 01:31:53 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=417</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/UVA610">UVA610 Street Directions</a>

<hr />

<h1>Solution</h1>

先来解释一下题面意思：我们现在有一个联通的无向图，<strong>我们要把整个图改造为有向图，在保证强连通的情况下使得双向边尽可能少</strong>。

我们不妨思考一下：如果一条双向边被我们改造为了单向边，会导致某一个方向上的断开。因此，我们先对原图做边双缩点，<strong>桥边是不可能被改造为单向边的</strong>（因为改造后直接导致边双间不能互相联通）。除了桥边之外，其他边都是可以改造为单向边的。

因此，<strong>我们可以在每一个边双里面做一个dfs来连单向边，桥边直接连上双向边即可</strong>。

时间复杂度$O(n)$
就酱，这题就被我们切掉啦ヾ(●´∀｀●)

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//Luogu  UVA610 Street Directions
//Apr,9th,2019
//Tarjan求点双
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=1000+10;
vector &lt;int&gt; e[N],e2[N];
int dfn[N],dfn_to,low[N],mstack[N],top,belong[N],cnt;
bool vis[N],InStack[N];
void Tarjan(int now,int father)
{
    vis[now]=InStack[now]=true;
    mstack[++top]=now;
    dfn[now]=low[now]=++dfn_to;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            Tarjan(e[now][i],now);
            low[now]=min(low[now],low[e[now][i]]);
        }
        else if(e[now][i]!=father and InStack[e[now][i]]==true)
            low[now]=min(low[now],dfn[e[now][i]]);
    if(low[now]==dfn[now])
    {
        cnt++;
        while(mstack[top+1]!=now)
            InStack[mstack[top]]=false,
            belong[mstack[top--]]=cnt;
    }
}
int Find(int now,int x)
{
    for(int i=0;i&lt;int(e[now].size());i++)
        if(e[now][i]==x)
            return i;
    return -1;
}
void dfs2(int now)
{
    if(vis[now]==true) return;
    vis[now]=true;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(belong[e[now][i]]==belong[now])
        {
            printf("%d %d\n",now,e[now][i]);
            e[e[now][i]][Find(e[now][i],now)]=0;
            dfs2(e[now][i]);
        }
}
int n,m;
int main()
{
    for(int o=1;;o++)
    {
        n=read(),m=read();
        if(n==0 and m==0) break;

        for(int i=0;i&lt;=n;i++)
            e[i].clear(),e2[i].clear();
        for(int i=1;i&lt;=n;i++)
            e[i].reserve(4),e2[i].reserve(4);
        for(int i=1;i&lt;=m;i++)
        {
            int s=read(),t=read();
            e[s].push_back(t);
            e[t].push_back(s);
        }

        memset(vis,0,sizeof vis);
        memset(mstack,0,sizeof mstack);
        dfn_to=cnt=0;
        Tarjan(1,0);

        printf("%d\n\n",o);
        memset(vis,0,sizeof vis);
        for(int i=1;i&lt;=n;i++)
            dfs2(i);
        for(int i=1;i&lt;=n;i++)
            for(int j=0;j&lt;int(e[i].size());j++)
                if(belong[i]!=belong[e[i][j]] and e[i][j]!=0)
                    printf("%d %d\n",i,e[i][j]);
        printf("#\n");
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>417</wp:post_id>
		<wp:post_date><![CDATA[2019-04-09 01:31:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-09 01:31:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva610-street-directions]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e8%be%b9%e5%8f%8c-%e7%82%b9%e5%8f%8c"><![CDATA[边双/点双]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[653]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>UVA10972 RevolC FaeLoN</title>
		<link>https://www.goldenpotato.cn/%e5%9b%be%e8%ae%ba/uva10972-revolc-faelon/</link>
		<pubDate>Tue, 09 Apr 2019 03:47:47 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=419</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/UVA10972"> UVA10972 RevolC FaeLoN</a>

<hr />

<h1>Solution</h1>

这题就比较牛皮。

我们先来考虑一下图联通的话怎么做。显然，我们可以先把图按边双缩点，边双内部是肯定不用加任何一条有向边就能改成强连通分量的（易证）。
缩完点之后，图一定会变成一颗树。接下来我们依旧可以像<a href="https://www.luogu.org/problemnew/show/P2860">这道题</a>那样贪心。我们数一下广义叶子数有多少，要加的边的个数一定为$sum/2$（向上取整）。
连边方式如图所示：
<img src="https://ws3.sinaimg.cn/large/0061a3rzly1g1w87gu0f7j30hl0dgjsc.jpg" alt="image" />

接下来再来考虑不连通的情况。显然，我们可以发现，对于多颗树来说，我们依旧可以照样刚刚那样贪心。我们左右两棵树在叶子那里连边即可。
<img src="https://wx3.sinaimg.cn/large/0061a3rzly1g1w8izjx1dj30gi0be751.jpg" alt="image" />
因此，我们的总答案依旧是$sum/2$（向上取整）

时间复杂度$O(n)$
就酱，这题就被我们切掉啦(*≧▽≦)

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">//UVA10972 RevolC FaeLoN
//Apr,9th,2019
//边双
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=1000+10;
vector &lt;int&gt; e[N],e2[N];
int dfn[N],dfn_to,low[N],mstack[N],top,belong[N],cnt;
bool vis[N],InStack[N];
void Tarjan(int now,int father)
{
    vis[now]=InStack[now]=true;
    mstack[++top]=now;
    dfn[now]=low[now]=++dfn_to;
    for(int i=0;i&lt;int(e[now].size());i++)
        if(vis[e[now][i]]==false)
        {
            Tarjan(e[now][i],now);
            low[now]=min(low[now],low[e[now][i]]);
        }
        else if(e[now][i]!=father and InStack[e[now][i]]==true)
            low[now]=min(low[now],dfn[e[now][i]]);
    if(low[now]==dfn[now])
    {
        cnt++;
        while(mstack[top+1]!=now)
            InStack[mstack[top]]=false,
            belong[mstack[top--]]=cnt;
    }
}
int n,m;
int dfs(int now,int father)
{
    vis[now]=true;
    int t_ans=0;
    for(int i=0;i&lt;int(e2[now].size());i++)
        if(e2[now][i]!=father)
            t_ans+=dfs(e2[now][i],now);
    if(e2[now].size()==1)
        t_ans++;
    if(e2[now].size()==0)
        t_ans+=2;
    return t_ans;
}
int main()
{
    for(int o=1;;o++)
    {
        if(scanf("%d%d",&amp;n,&amp;m)==EOF) break;

        for(int i=0;i&lt;=n;i++)
            e[i].clear(),e2[i].clear();
        for(int i=1;i&lt;=n;i++)
            e[i].reserve(4),e2[i].reserve(4);
        for(int i=1;i&lt;=m;i++)
        {
            int s=read(),t=read();
            e[s].push_back(t);
            e[t].push_back(s);
        }

        memset(vis,0,sizeof vis);
        memset(mstack,0,sizeof mstack);
        dfn_to=cnt=0;
        for(int i=1;i&lt;=n;i++)
            if(vis[i]==false)
                Tarjan(i,i);

        for(int i=1;i&lt;=n;i++)
            for(int j=0;j&lt;int(e[i].size());j++)
                if(belong[i]!=belong[e[i][j]])
                    e2[belong[i]].push_back(belong[e[i][j]]);
        memset(vis,0,sizeof vis);
        if(cnt==1)
            printf("0\n");
        else
        {
            int ans=0;
            for(int i=1;i&lt;=n;i++)
                if(vis[belong[i]]==false)
                    ans+=dfs(belong[i],belong[i]);
            printf("%d\n",ans/2+ans%2);
        }
    }
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>419</wp:post_id>
		<wp:post_date><![CDATA[2019-04-09 03:47:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-09 03:47:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[uva10972-revolc-faelon]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e8%be%b9%e5%8f%8c-%e7%82%b9%e5%8f%8c"><![CDATA[边双/点双]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[717]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[453]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>最小树形图构造(朱刘算法)学习笔记</title>
		<link>https://www.goldenpotato.cn/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/%e6%9c%80%e5%b0%8f%e6%a0%91%e5%bd%a2%e5%9b%be%e6%9e%84%e9%80%a0%e6%9c%b1%e5%88%98%e7%ae%97%e6%b3%95%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/</link>
		<pubDate>Tue, 09 Apr 2019 23:33:01 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=421</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>什么是最小树形图</h1>

最小树形图就是给定一个$n$个点的有向图，我们钦定一个根，现在要找$n-1$条边，在根能到达其他所有点的前提条件下，使得$n-1$条边的总长度尽可能小。

<hr />

<h1>怎么找最小树形图</h1>

这里就得用到朱刘算法了。朱刘算法是一个$O(n \cdot m)$的算法。当然，还有Tarjan巨神的$O(nlogn)$的算法。<del>但我太菜了，并学不会</del>

图出自<a href="https://www.luogu.org/blog/i207M/shu-xing-tu-shu-liu-suan-fa-xue-xi-bi-ji-xie-ti-bao-gao-p4716-post">这里</a>
<img src="https://wx4.sinaimg.cn/large/0061a3rzly1g1x6kcbxiaj30m80df0zy.jpg" alt="image" />

上面这张图很好的诠释了朱刘算法的主要内容：
我们算法主要有以下几个步骤：
1. 找到到达每个点的长度最小的<strong>入边（根节点不找）</strong>
2. 这些边如果连成一颗树则结束；
3. 如果这些边中除了根节点以外有孤独一个的点的话，则无解；
4. 否则一定会连出一些环，<strong>我们把这些环缩起来，答案加上这些环上边权和</strong>，然后构建新图：<strong>所有连向这些环的边的边权减去对应的点之前的最小的入边的边权</strong>（即步骤1找到的那一条）。建完新图之后回到步骤1。

<hr />

<h1>朱刘算法如何实现</h1>

从上面的口胡，我们可以发现，我们要实现一个动态缩点，动态构图的过程。可想而知，算法并不好写。

笔者个人的写法是开两个图，辗转使用。魔改Tarjan来实现找环的过程。
代码在这里(丑不忍赌)

<pre><code class="language-cpp line-numbers">//Luogu P4716 【模板】最小树形图
//Apr,9th,2019
//朱刘算法求有向图最小生成树
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=2*100+10;
const int inf=0x3f3f3f3f;
struct edge
{
    int t,w;
    edge (int x=0,int y=0)
    {
        t=x,w=y;
    }
};
vector &lt;edge&gt; e[2][N];
edge e2[N];
int n,m,r,id[N],cnt,t_now;
bool vis[N],gone[N],IsNew[N];
int mstack[N],top;
int dfs(int now)
{
    int t_ans=0;
    mstack[++top]=now;
    vis[now]=gone[now]=true;
    if(vis[e2[now].t]==true)
    {
        cnt++;
        while(mstack[top+1]!=e2[now].t)
            IsNew[mstack[top]]=true,
            id[mstack[top--]]=cnt;
        t_ans+=e2[now].w;
    }
    else if(gone[e2[now].t]==false)
    {
        t_ans=dfs(e2[now].t);
        if(id[now]==cnt)
            t_ans+=e2[now].w;
    }
    vis[now]=false;
    return t_ans;
}
int GetID(int x)
{
    if(id[x]==0) return x;
    return id[x]=GetID(id[x]);
}
int ZhuLiu(int S)
{
    int ans=0;
    while(1)
    {
        for(int i=1;i&lt;=n;i++)
            e2[GetID(i)].w=inf;
        for(int i=1;i&lt;=cnt;i++)
            for(int j=0;j&lt;int(e[t_now][i].size());j++)
                if(e[t_now][i][j].t!=S and e[t_now][i][j].w&lt;e2[e[t_now][i][j].t].w)
                    e2[e[t_now][i][j].t].t=i,
                    e2[e[t_now][i][j].t].w=e[t_now][i][j].w;
        for(int i=1;i&lt;=n;i++)
            if(i!=S and e2[GetID(i)].w==inf)
                return -1;//有单独点
        memset(gone,0,sizeof gone);
        memset(vis,0,sizeof vis);
        memset(IsNew,0,sizeof IsNew);
        int t_ans=0;
        for(int i=1;i&lt;=n;i++)
            if(gone[GetID(i)]==false and i!=S)
                top=0,
                t_ans+=dfs(GetID(i)),gone[cnt]=true;
        ans+=t_ans;
        if(t_ans==0)
        {
            memset(vis,0,sizeof vis);
            bool OK=false;
            for(int i=1;i&lt;=n;i++)
                if(i!=S and vis[GetID(i)]==false)
                    OK=max(OK,e2[GetID(i)].t==S),
                    ans+=e2[GetID(i)].w,vis[GetID(i)]=true;
            if(OK==false) ans=-1;
            break; //无环，完成
        }
        int mnext=(t_now+1)%2;
        for(int i=1;i&lt;=cnt;i++)
            e[mnext][i].clear();
        for(int i=1;i&lt;=cnt;i++)
            for(int j=0;j&lt;int(e[t_now][i].size());j++)
                if(GetID(i)!=GetID(e[t_now][i][j].t))
                {
                    if(IsNew[e[t_now][i][j].t]==true)
                        e[mnext][GetID(i)].push_back(edge(GetID(e[t_now][i][j].t),e[t_now][i][j].w - e2[e[t_now][i][j].t].w));
                    else
                        e[mnext][GetID(i)].push_back(edge(GetID(e[t_now][i][j].t),e[t_now][i][j].w));
                }
        t_now=(t_now+1)%2;
    }
    return ans;
}
int main()
{
    freopen("4716.in","r",stdin);
    freopen("4716.out","w",stdout);

    n=read(),m=read(),r=read();
    for(int i=1;i&lt;=m;i++)
    {
        int s=read(),t=read(),w=read();
        if(s==t) continue;
        e[t_now][s].push_back(edge(t,w));
    }

    cnt=n;
    int ans=ZhuLiu(r);

    printf("%d",ans);
    return 0;
}

</code></pre>

<hr />

<h1>朱刘算法的应用</h1>

<del>目前好像只有模板题</del>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>421</wp:post_id>
		<wp:post_date><![CDATA[2019-04-09 23:33:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-09 23:33:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%80%e5%b0%8f%e6%a0%91%e5%bd%a2%e5%9b%be%e6%9e%84%e9%80%a0%e6%9c%b1%e5%88%98%e7%ae%97%e6%b3%95%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[学习笔记]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1294]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[471]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>73</wp:comment_id>
			<wp:comment_author><![CDATA[456]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[123456@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[222.187.46.192]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-10-26 03:29:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-10-26 03:29:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你好]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>74</wp:comment_id>
			<wp:comment_author><![CDATA[试图在文化课苟活的土豆]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.goldenpotato.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[171.107.58.169]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-11-02 09:57:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-11-02 09:57:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你好呀 |´・ω・)ノ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>73</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>[Luogu P3975] [TJOI2015]弦论</title>
		<link>https://www.goldenpotato.cn/%e5%ad%97%e7%ac%a6%e4%b8%b2/luogu-p3975-tjoi2015%e5%bc%a6%e8%ae%ba/</link>
		<pubDate>Wed, 10 Apr 2019 04:19:42 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=423</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>题面</h1>

<a href="https://www.luogu.org/problemnew/show/P3975">P3975 [TJOI2015]弦论 </a>

<hr />

<h1>Solution</h1>

看到题面要求不同情况下的$K$小串，给人一种自动机上做DP就可以写的感觉。

因此，我们考虑用后缀自动机来解决这个问题。我们先建出SAM。
对于$k=0$的情况，肥肠好写。根据SAM的常识，在SAM上任意走都是原串的一个子串。题目要求求出第$k$小不重复子串，既是让我们求出SAM的前$k$条路径。因为这里的$k$很大，我们是不能暴力走的。因此，我们可以设$f[i]$表示从$i$出发有多少条路径，转移非常显然，$f[i]=\sum f[j]$(j为i能到的点)。我们用记忆话搜索/拓扑序DP即可求出。接下来，我们在SAM上做dfs即可。

对于$k=1$的情况，我们则必须求出每个串的出现次数。这需要sam的一点性质。我们知道，<strong>SAM的fail树上的任何一个节点所代表的的字符串一定是它的孩子节点所代表的的字符串的后缀。</strong>因此，<strong>当前节点所表示的串的出现次数就是1+子孙出现次数</strong>，这里要注意一点，复制出来的节点不需要+1，如果+1就会计算重复。计算出来每个串的出现次数后的事情就和$k=0$的做法一模一样了。

时间复杂度$O(n)$
就酱，这道题就被我们切掉啦ヾ(^Д^*)/

<hr />

<h1>Code</h1>

<pre><code class="language-cpp line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
//const int N=500;
const int N=500000*2+200;
struct SAM
{
    static const int M=26;
    struct node
    {
        int son[M],fail,len,size;
        bool IsNew;
    }nd[N];
    int last,to;
    void Init()
    {
        last=to=1;
    }
    void Insert(char c)
    {
        int x=c-'a',now=last,n_now=++to;
        nd[n_now].len=nd[now].len+1;
        last=n_now;
        for(;now!=0 and nd[now].son[x]==0;now=nd[now].fail)
            nd[now].son[x]=n_now;
        if(now==0)
            nd[n_now].fail=1;
        else
        {
            int tmp=nd[now].son[x];
            if(nd[tmp].len==nd[now].len+1)
                nd[n_now].fail=tmp;
            else
            {
                int n_tmp=++to;
                nd[n_tmp]=nd[tmp],nd[n_tmp].len=nd[now].len+1,nd[tmp].fail=n_tmp,nd[n_tmp].IsNew=true;
                nd[n_now].fail=n_tmp;
                for(;now!=0 and nd[now].son[x]==tmp;now=nd[now].fail)
                    nd[now].son[x]=n_tmp;
            }
        }
    }
    vector &lt;int&gt; e[N];
    void Build()
    {
        for(int i=1;i&lt;=to;i++)
            e[i].reserve(4);
        for(int i=1;i&lt;=to;i++)
            e[nd[i].fail].push_back(i);
    }
    int dfs(int now,bool type)
    {
        nd[now].size=(nd[now].IsNew==false);
        for(int i=0;i&lt;int(e[now].size());i++)
            nd[now].size+=dfs(e[now][i],type);
        if(type==0)
            nd[now].size=1;
        return nd[now].size;
    }
    int mstack[N],top,cnt[N];
    int dfs2(int now)
    {
        if(cnt[now]!=0) return cnt[now];
        cnt[now]+=nd[now].size;
        for(int i=0;i&lt;M;i++)
            if(nd[now].son[i]!=0)
                cnt[now]+=dfs2(nd[now].son[i]);
        return cnt[now];
    }
    bool OK;
    void dfs3(int now,int K)
    {
        if(OK==true) return;
        K-=nd[now].size;
        if(K&lt;=0)
        {
            OK=true;
            for(int i=1;i&lt;=top;i++)
                printf("%c",mstack[i]+'a');
            return;
        }
        for(int i=0;i&lt;M;i++)
            if(nd[now].son[i]!=0)
            {
                if(cnt[nd[now].son[i]]&gt;=K)
                {
                    mstack[++top]=i;
                    dfs3(nd[now].son[i],K);
                }
                else
                    K-=cnt[nd[now].son[i]];
            }
    }
}sam;

char s[N];
int K,type;
int main()
{
    scanf("%s%d%d",s+1,&amp;type,&amp;K);
    int len=strlen(s+1);
    sam.Init();
    for(int i=1;i&lt;=len;i++)
        sam.Insert(s[i]);

    sam.Build();
    sam.dfs(1,type);
    sam.nd[1].size=0;
    sam.dfs2(1);

    sam.dfs3(1,K);
    if(sam.OK==false)
        printf("-1");
    return 0;
}

</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>423</wp:post_id>
		<wp:post_date><![CDATA[2019-04-10 04:19:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-10 04:19:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[luogu-p3975-tjoi2015%e5%bc%a6%e8%ae%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%90%8e%e7%bc%80%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[后缀自动机]]></category>
		<category domain="category" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[646]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>GXOI2019 退役记</title>
		<link>https://www.goldenpotato.cn/%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95/gxoi2019-%e6%b8%b8%e8%ae%b0/</link>
		<pubDate>Thu, 11 Apr 2019 09:52:17 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=426</guid>
		<description></description>
		<content:encoded><![CDATA[DAY1被神题打爆狗头，T1骗了50分就持续自闭了。

DAY2开题5分钟立马锤了一个T1的假DP，然后还对这个假做法有蜜汁自信，拍都没拍就跑路了。
T2有点想法但又没有，总感觉隐隐约约可做但又不会写，最后锤的暴力。
T3暴力很显然，又用splay锤了一个20分的链。

结果是很凄惨的，T1爆零，T2，T3没有意外发生，RANK10退役。

怎么说呢，T1写爆是自己的策略严重失误。平时模拟赛的时候犯这种错误总是安慰自己说考场上不会犯的，事实证明，考场也只是自己平时状态的延续罢了。
如果我T1没有去写DP,就算写那20分的暴力也进队了
如果我T3没有去锤那20分的链，好好去检查T1也进队了
如果我NOIp分数正常一点，DAY2好好写T1不锤T2也进队了
......

可是，人生哪来的如果呢？
发生这种情况，真的也的确是人菜，活该退役。
想想自己的OI生涯，的确是有很多的失误，比如说不善于反省自己，总是找外部原因，而不去找自身的问题；比如说自己不擅长总结，写题不能做到举一反三什么的......

心里有很多话，可是真的到了落笔的时候却什么也写不出。
但是，我相信，OIer们在文化考场上一定能重振旗鼓，一样能通过文化考上自己理想的大学。
各位，我们2020年高考见！

.

关于其他内容，还请移步AFO后记。

<hr />

说是这样说，但是还是要强烈谴责南宁三中，胜之不武的行为会永远被世人所唾弃！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>426</wp:post_id>
		<wp:post_date><![CDATA[2019-04-11 09:52:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-11 09:52:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[gxoi2019-%e6%b8%b8%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%b8%b8%e8%ae%b0-%e8%87%aa%e9%97%ad%e8%ae%b0-%e6%bb%9a%e7%b2%97%e8%ae%b0"><![CDATA[游记/自闭记/滚粗记]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1565]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>32</wp:comment_id>
			<wp:comment_author><![CDATA[hfctf0210]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1340880811@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[183.160.53.32]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-13 07:51:14]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-13 07:51:14]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[催更]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>35</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-13 13:00:47]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-13 13:00:47]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[明天一起更吧（咕）

如果退役的话就没法更了 :huaji9:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>32</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>37</wp:comment_id>
			<wp:comment_author><![CDATA[泅荼]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1150264528@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[113.12.192.12]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-18 08:26:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-18 08:26:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[催更]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>40</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.141.118.31]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-25 14:50:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-25 14:50:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[更完啦~ :huaji10:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>32</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>70</wp:comment_id>
			<wp:comment_author><![CDATA[kkkstra]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[snewt986@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://kkkstra.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.187.87.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-09-30 11:11:12]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-09-30 11:11:12]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[qwq]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>71</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[171.107.58.169]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-09-30 23:29:22]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-09-30 23:29:22]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[poi ~ |´・ω・)ノ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>70</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>78</wp:comment_id>
			<wp:comment_author><![CDATA[Snow_sword]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[lihaoxiang150211@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[115.197.106.110]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-12-28 00:32:15]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-12-28 00:32:15]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[qwwwq]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>92</wp:comment_id>
			<wp:comment_author><![CDATA[GoldenPotato137]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-02-29 16:08:21]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-02-29 16:08:21]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[qwq  :huaji:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>78</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>AFO后记</title>
		<link>https://www.goldenpotato.cn/uncategorized/afo%e5%90%8e%e8%ae%b0/</link>
		<pubDate>Thu, 25 Apr 2019 15:00:57 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=473</guid>
		<description></description>
		<content:encoded><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=30394175&auto=0&height=66"></iframe>

<hr />

<h1>我的OI生涯</h1>

咕咕咕

<hr />

<h1>接下来的博客计划</h1>

接下来呢，我可能就没法刷太多题了，可能只会久不久写一点OI题目。
之后我的博客只要内容会更新学文化课的进度，感想，希望能帮助有困惑的同学，并希望证明一点:OIer是不会被打倒的！

<h1>Update 2020/8/2</h1>

高考 全国三卷 655
大家哈工大见！

<hr />

<h1>致谢</h1>

<strong>感谢无私帮助我的学长们，他们是：</strong>
zyb学长 (泅荼)
hb学长 (nnez_hb)
lx学长 (LQAQC)
xlw学长 (nnez_xiaoliwei)
...
<strong>感谢一路上与我并肩作战的同级同学们，他们是：</strong>
wzj神仙 (Maxwei_wzj)
lbc同学 (lizbaka)
sry同学 (OrionM42)
wpy同学 (Capacitance_core)
hzq同学 (Villard)
lyj同学 (Uchiha_Obito)
...
<strong>感谢一路上陪伴我的学弟们，他们是</strong>
hjq学弟 (ComputerEngine)
hrb学弟 (HRLYB)
cwt学弟 (Mireco)
...
<strong>感谢父母的一路支持，感谢教练的指点教育</strong>
<strong>感谢所有值得感谢但因为各种原因未在该列表中出现的人</strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>473</wp:post_id>
		<wp:post_date><![CDATA[2019-04-25 15:00:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-04-25 15:00:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[afo%e5%90%8e%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[1333]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>41</wp:comment_id>
			<wp:comment_author><![CDATA[冒泡ioa]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1342130847@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://bubbleioa.top/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[111.75.54.86]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-04-28 10:16:18]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-04-28 10:16:18]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[OIer是不会被打倒的！！ |´・ω・)ノ]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>1942</wp:comment_id>
			<wp:comment_author><![CDATA[OItby]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2948900472@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.cnblogs.com/hihocoder/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[218.75.150.124]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-03-09 06:37:49]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-03-09 06:37:49]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[OIer是不会被打倒的！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>NOIp(大雾)  CSP-S 2019 暴力记</title>
		<link>https://www.goldenpotato.cn/%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95/noip%e5%a4%a7%e9%9b%be-csp-s-2019-%e6%9a%b4%e5%8a%9b%e8%ae%b0/</link>
		<pubDate>Sun, 17 Nov 2019 04:36:40 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=486</guid>
		<description></description>
		<content:encoded><![CDATA[咕咕咕

没了，打了整整两天暴力，我太菜了，嘤

目测分数远低于高一那场NOIp

<h3>开 倒 车</h3>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>486</wp:post_id>
		<wp:post_date><![CDATA[2019-11-17 04:36:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-17 04:36:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[noip%e5%a4%a7%e9%9b%be-csp-s-2019-%e6%9a%b4%e5%8a%9b%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e6%b8%b8%e8%ae%b0-%e8%87%aa%e9%97%ad%e8%ae%b0-%e6%bb%9a%e7%b2%97%e8%ae%b0"><![CDATA[游记/自闭记/滚粗记]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b6%af%e7%ba%aa%e5%bd%95"><![CDATA[生涯纪录]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[2102]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[453]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[love]]></wp:meta_key>
		<wp:meta_value><![CDATA[15]]></wp:meta_value>
		</wp:postmeta>
							<wp:comment>
			<wp:comment_id>79</wp:comment_id>
			<wp:comment_author><![CDATA[⑨BIE]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[blackguwc@163.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://ero.ink</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[59.61.164.152]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-01-15 16:56:00]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-01-15 16:56:00]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[:huaji2:  :good: 只要型能够，暴力解决世界一切问题]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>85</wp:comment_id>
			<wp:comment_author><![CDATA[650分挣扎的菜鸡土豆]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>https://www.goldenpotato.cn</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-02-20 15:12:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-02-20 15:12:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[暴力吼啊  :huaji2:  :haha2:]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>79</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>86</wp:comment_id>
			<wp:comment_author><![CDATA[QwQ]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[GoldenPotato137@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.baidu.com</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[192.168.20.1]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2020-02-21 16:00:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2020-02-21 16:00:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[qwq?]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>Ubuntu 20.02LTS 填坑实录</title>
		<link>https://www.goldenpotato.cn/uncategorized/ubuntu-20-02lts-%e5%a1%ab%e5%9d%91%e5%ae%9e%e5%bd%95/</link>
		<pubDate>Thu, 25 Feb 2021 14:44:43 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=492</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>1.Ubuntu启动时如何显示或隐藏启动消息？</strong>
https://qastack.cn/ubuntu/248/how-can-i-show-or-hide-boot-messages-when-ubuntu-starts

<strong>2.cuda版本查看</strong>
https://blog.csdn.net/qq_41368074/article/details/107785536

<strong>3.cudnn安装</strong>
https://blog.csdn.net/weixin_44002829/article/details/111500287

<blockquote>
  注：在运行demon前需安装freeimage库
  sudo apt-get install libfreeimage3 libfreeimage-dev
</blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>492</wp:post_id>
		<wp:post_date><![CDATA[2021-02-25 14:44:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2021-02-25 14:44:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ubuntu-20-02lts-%e5%a1%ab%e5%9d%91%e5%ae%9e%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_7cd35751da89a10a46868eec419a6292]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[459]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_5e2d19fc662c79f0652879e56dbd9c56]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[47]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_668df8ff0a9acba42b5ce3fccbf14c44]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>pyTorch填坑实录</title>
		<link>https://www.goldenpotato.cn/%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0/pytorch%e5%a1%ab%e5%9d%91%e5%ae%9e%e5%bd%95/</link>
		<pubDate>Sun, 14 Mar 2021 11:51:10 +0000</pubDate>
		<dc:creator><![CDATA[GoldenPotato137]]></dc:creator>
		<guid isPermaLink="false">https://www.goldenpotato.cn/?p=495</guid>
		<description></description>
		<content:encoded><![CDATA[<ol>
<li>pytorch: grad can be implicitly created only for scalar outputs:</li>
</ol>

<pre><code class="language-python line-numbers">z.backward(torch.ones_like(x))
</code></pre>

原因：backward必须使用标量来进行

<ol start="2">
<li>python本身看起来数据类型不敏感，但是pytorch极其敏感，int与double不能直接相加，出现想干错误后应查看数据类型：</li>
</ol>

<pre><code class="language-python line-numbers">print(tx.dtype) 
tx=tx.to(dtype=torch.float64)
</code></pre>

<ol start="3">
<li><p>torch.nn.functional.Softmax 和 torch.nn.softmax不是一个东西
前者本质是一个函数，用于最后的lost计算，后者是一个神经元节点的定义</p></li>
<li><p>小心tensor的维度，用xxx.size()查看tensor的维度及范围</p></li>
</ol>

<pre><code class="language-python line-numbers">print(out.size())
</code></pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>495</wp:post_id>
		<wp:post_date><![CDATA[2021-03-14 11:51:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2021-03-14 11:51:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[pytorch%e5%a1%ab%e5%9d%91%e5%ae%9e%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>1</wp:is_sticky>
										<category domain="category" nicename="%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0"><![CDATA[深度学习]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wpcom_is_markdown]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[454]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[views]]></wp:meta_key>
		<wp:meta_value><![CDATA[26]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	