---
title: MSM GPU加速相关文章阅读笔记
date: 2024-09-07 09:40:37
tags: HPC
plugins:
  - mathjax
---

## GZKP: A GPU Accelerated Zero-Knowledge Proof System
> 2023 - 5

### 并行化方法
称把一个桶的点加起来的计算位一个点合并任务。将多个点合并任务分配到一个block上。每个点合并任务都分配一个warp。

其中，warp内使用合作组（cooperative groups）来并行执行点加运算。同一个warp会被拆分为多个合作组，每个合作组都独立执行点加运算。

考虑到不同点合并任务的负载（点的个数）不同，文章会按照任务负载将任务分配到不同的blcok上，一个block可能会被分配多个任务。

### 预计算
与其于把各个window分开计算并最后通过window reduction合并到一起，本文预先计算了每个点在各个windows下经过对应偏移量的值(i.e. 乘以对应窗口的系数)。如此操作过后，不同窗口但标量相同的点就可以使用同一个桶了。从而增大了单个桶的大小，去除了窗口合并时的点乘。

核心原理： 

原来的Pippenger计算方法为把标量$k_i$按位分块，从而把原本完整的MSM计算拆分位多个在不同位上的MSM子问题（窗口），如下公式所示。

$$\sum k_i \cdot P_i = \sum_j 2^{(j-1) \cdot S} \sum_i k_{ij} \cdot P_i$$

其中，$S$为每个子问题位长，$k_{ij}$表示第$i$个标量的第$j$段。

上式可以变为：

$$\sum_j \sum_i k_{ij} \cdot (2^{j-1} \cdot P_i)$$

考虑到对于固定问题的ZKP，其$P_i$是在不同批次的MSM中保持不变的，变的只有标量，故预计算只需要进行一次即可。

但是预计算需要存储巨量的点在显存中，会造成巨大的显存压力。故文章是分段预计算的，没有被预计算覆盖过的点需要在点合并的时候找到最近的有预计算的点，再点乘相应的位数后才能被加到桶中。

### 有限域计算优化

不只是运用SM上的整数计算单元，把浮点计算单元也利用上以共同执行大整数计算。